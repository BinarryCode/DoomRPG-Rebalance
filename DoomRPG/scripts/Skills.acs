#library "Skills"

#include "zcommon.acs"

#import "Stats.acs"
#import "Shop.acs"
#import "Utils.acs"
#import "Menu.acs"
#import "Shield.acs"

#libdefine MAX_CATEGORIES		6
#libdefine MAX_SKILLS			17

// Energy Points (EP)
global int 2 : EP;
global int 3 : EPMax;

// Skill-related vars
global int 5 : Aura;
global int 6 : AuraTimer;
global int 25 : AuraTimerHUD;
global int 26 : SkillCatagory[];
global int 27 : SkillIndex[];
global int 28 : SkillLevel[];
global int 29 : CurrentSkillLevel[];

/* Skill descriptions for SBARINFO (WIP) - Add these when/if I actually need them, no point wasting precious Global vars :P
global str 58 : SkillDescriptionRecovery;
global str 59 : SkillDescriptionPowerup;
global str 60 : SkillDescriptionAura;
global str 61 : SkillDescriptionAttack;
global str 62 : SkillDescriptionSummon;
global str 63 : SkillDescriptionUtility;
*/

bool Overdrive;
int SummonID = 2100;
int MaxSummons;
int SkillCostMult;
int BulletTimeMode;
int BulletTimeTimer;

// Portal stuff
int Portal1[4];
int Portal2[4];
bool Portal1Active;
bool Portal2Active;

// Skill Catagories
str SkillCategories[MAX_CATEGORIES] =
{
	"Healing",
	"Powerups",
	"Auras",
	"Attacks",
	"Summoning",
	"Utility",
};

int CategoryMax[MAX_CATEGORIES] =
{
	2, 9, 9, 4, 17, 6
};

// Skill Max Levels
int SkillLevelMax[MAX_CATEGORIES][MAX_SKILLS] =
{
	// Healing
	{ 1, 1 },
	// Powerups
	{ 10, 10, 2, 1, 1, 1, 1, 1, 1 },
	// Auras
	{ 3, 5, 5, 1, 3, 4, 3, 4, 7 },
	// Attacks
	{ 1, 10, 1, 10 },
	// Summoning
	{ 8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
	// Utility
	{ 1, 2, 1, 2, 1, 1 }
};

int SkillCosts[MAX_CATEGORIES][MAX_SKILLS] =
{
	// Healing
	{ 50, 50 },
	// Powerups
	{ 50, 25, 250, 250, 250, 500, 500, 250, 250 },
	// Auras
	{ 100, 100, 100, 100, 100, 100, 100, 100, 100, 100 },
	// Attacks
	{ 5, 25, 10, 50 },
	// Summoning
	{ 50, 25, 50, 75, 75, 75, 100, 150, 200, 100, 500, 500, 500, 500, 750, 1000, 1000, },
	// Utility
	{ 50, 50, 50, 0, 50, 25 }
};

// Skill Icons
str SkillIcons[MAX_CATEGORIES][MAX_SKILLS] =
{
	// Healing
	{
		"Heal",			// Heal
		"Repair",		// Repair Armor
	},
	// Powerups
	{
		"Invuln",		// Invulnerability
		"Invis",		// Invisibility
		"TimeStop",		// Time Freeze
		"IronFeet",		// Iron Feet
		"NVision",		// Nightvision
		"Berserk",		// Berserk
		"Mapping",		// Mental Mapping
		"RuneDrop",		// Rune Drop
		"AmmoDrop",		// Ammo Drop
	},
	// Auras
	{
		"AuraRed",		// Red Aura
		"AuraGree",		// Green Aura
		"AuraWhit",		// White Aura
		"AuraPink",		// Pink Aura
		"AuraCyan",		// Blue Aura
		"AuraPurp",		// Purple Aura
		"AuraOran",		// Orange Aura
		"AuraBlue",		// Dark Blue Aura
		"AuraYell",		// Yellow Aura
	},
	// Attacks
	{
		"Fireball",		// Fireball
		"Fireball",		// Fireball Nova
		"IceMiss",		// Ice Missile
		"IceMiss",		// Ice Nova
	},
	// Summoning
	{
		"Marine",		// Summon Marine
		"Zombie1",		// Summon Zombieman
		"Zombie2",		// Summon Shotgun Guy
		"Zombie3",		// Summon ChainGun Guy
		"Demon1",		// Summon Imp
		"Demon2",		// Summon Demon
		"Demon3",		// Summon Cacodemon
		"Knight1",		// Summon Hell Knight
		"Knight2",		// Summon Baron of Hell
		"LostSoul",		// Summon Lost Soul
		"PainElem",		// Summon Pain Elemental
		"Skeleton",		// Summon Revenant
		"Mancubus",		// Summon Fatso
		"Spider",		// Summon Arachnotron
		"ArchVile",		// Summon Arch-Vile
		"Boss1",		// Summon Cyberdemon
		"Boss2",		// Summon Spider Mastermind
	},
	// Utility
	{
		"Wrench",		// Breakdown Armor
		"FField",		// Force Wall
		"Rally",		// Rally
		"Unsummon",		// Unsummon
		"Magnet",		// Magnetize
		"Teleport",		// Transport
	},
};

// Skill Data
int SkillData[MAX_CATEGORIES][MAX_SKILLS][20] =
{
	// Name, Description (Level 1), Description (Level 2), ...
	
	// Healing
	{
		{
			"Heal",
			"Recover (Energy * 10) HP",
			"Recover (Energy * 20) HP",
			"Recover (Energy * 30) HP",
			"Recover (Energy * 40) HP",
			"Recover (Energy * 50) HP"
		},
		{
			"Repair Armor",
			"Repair (Energy * 10) Armor",
			"Repair (Energy * 20) Armor",
			"Repair (Energy * 30) Armor",
			"Repair (Energy * 40) Armor",
			"Repair (Energy * 50) Armor"
		}
	},
	
	// Powerups
	{
		{
			"Invulnerability",
			"Invulnerability to all attacks\n\cd(6 Sec)",
			"Invulnerability to all attacks\n\cd(12 Sec)",
			"Invulnerability to all attacks\n\cd(18 Sec)",
			"Invulnerability to all attacks\n\cd(24 Sec)",
			"Invulnerability to all attacks\n\cd(30 Sec)",
			"Invulnerability to all attacks\nProjectiles are reflectedback at enemies\n\cd(36 Sec)",
			"Invulnerability to all attacks\nProjectiles are reflectedback at enemies\n\cd(42 Sec)",
			"Invulnerability to all attacks\nProjectiles are reflectedback at enemies\n\cd(48 Sec)",
			"Invulnerability to all attacks\nProjectiles are reflectedback at enemies\n\cd(54 Sec)",
			"Invulnerability to all attacks\nProjectiles are reflectedback at enemies\n\cd(60 Sec)"
		},
		{
			"Invisibility",
			"Makes you invisible to enemies\nUse again to increase effect\n\cd(6 sec)",
			"Makes you invisible to enemies\nUse again to increase effect\n\cd(12 sec)",
			"Makes you invisible to enemies\nUse again to increase effect\n\cd(18 sec)",
			"Makes you invisible to enemies\nUse again to increase effect\n\cd(24 sec)",
			"Makes you invisible to enemies\nUse again to increase effect\n\cd(30 sec)",
			"Makes you invisible to enemies\nUse again to increase effect\n\cd(36 sec)",
			"Makes you invisible to enemies\nUse again to increase effect\n\cd(42 sec)",
			"Makes you invisible to enemies\nUse again to increase effect\n\cd(48 sec)",
			"Makes you invisible to enemies\nUse again to increase effect\n\cd(54 sec)",
			"Makes you invisible to enemies\nUse again to increase effect\n\cd(60 sec)"
		},
		{
			"Freeze Time",
			"Stutter Time",
			"Freeze Time"
		},
		{
			"Iron Feet",
			"Protection from Damage Floors"
		},
		{
			"Night Vision",
			"Allows you to see in the dark"
		},
		{
			"Berserk",
			"Full Health\nIncreased Melee Damage"
		},
		{
			"Mental Mapping",
			"Full Map\nItem/Enemy Tracking"
		},
		{
			"Rune Drop",
			"Drops a random Rune at your locations"
		},
		{
			"Ammo Drop",
			"Drops a Backpack of ammo at your location"
		},
	},
	
	// Auras
	{
		{
			"Red Aura",
			"2x Damage",
			"4x Damage",
			"4x Damage\nInfinite Ammo",
		},
		{
			"Green Aura",
			"-2x Damage Taken",
			"-4x Damage Taken",
			"-4x Damage Taken\nDamage Floor Protection",
			"Invulnerable",
			"Invulnerable\nReflective Projectiles"
		},
		{
			"White Aura",
			"Double Combo",
			"Double Combo\nConstant Combo",
			"Double Combo\nConstant Combo\n2x XP per kill",
			"Double Combo\nConstant Combo\n2x XP per kill\nSlow XP Gain",
			"Double Combo\nConstant Combo\n2x XP per kill\nFast XP Gain",
		},
		{
			"Pink Aura",
			"Drain Enemy HP"
		},
		{
			"Blue Aura",
			"25% Skill Cost Reduction",
			"50% Skill Cost Reduction",
			"75% Skill Cost Reduction"
		},
		{
			"Purple Aura",
			"2x HP/EP Regen Rate",
			"3x HP/EP Regen Rate",
			"4x HP/EP Regen Rate",
			"4x HP/EP Regen Rate\nInstant Shield Charge"
		},
		{
			"Orange Aura",
			"Double Movement Speed",
			"Double Movement Speed\nHigh Jump",
			"Double Movement Speed\nHigh Jump\nDouble Firing Speed",
		},
		{
			"Dark Blue Aura",
			"Clip Regen",
			"Clip Regen\nShell Regen",
			"Clip Regen\nShell Regen\nRocket Regen",
			"Clip Regen\nShell Regen\nRocket Regen\nCell Regen"
		},
		{
			"Yellow Aura",
			"Gradual Money Gain\n2x Credit Drop Chance",
			"Slow Money Gain\n2x Credit Drop Chance\n2x Health Drop Chance",
			"Medium Money Gain\n2x Credit Drop Chance\n2x Health Drop Chance\n2x Armor Drop Chance",
			"Fast Money Gain\n2x Credit Drop Chance\n2x Health Drop Chance\n2x Armor Drop Chance\n2x Powerup Drop Chance",
			"Very Fast Money Gain\n2x Credit Drop Chance\n2x Health Drop Chance\n2x Armor Drop Chance\n2x Powerup Drop Chance\n2x Rune Drop Chance",
			"Super Money Gain\n2x Credit Drop Chance\n2x Health Drop Chance\n2x Armor Drop Chance\n2x Powerup Drop Chance\n2x Rune Drop Chance\n2x Token Drop Chance",
			"Ultra Money Gain\n2x Credit Drop Chance\n2x Health Drop Chance\n2x Armor Drop Chance\n2x Powerup Drop Chance\n2x Rune Drop Chance\n2x Token Drop Chance\n2x Augmentation/Shield Part Drop Chance"
		}
	},
	
	// Attacks
	{
		{
			"FireBall",
			"Shoots a fireball\n\caFire Damage"
		},
		{
			"Fireball Nova",
			"Shoots fireballs in a circular nova around you\n\caFire Damage"
		},
		{
			"Ice Missile",
			"Shoots an ice missile\n\cnIce Damage"
		},
		{
			"Ice Nova",
			"Shoots ice missles in a circular nova around you\n\cnIce Damage"
		}
	},
	
	// Summoning
	{
		{
			"Summon Marine",
			"Summons a Marine to fight with you\n\cjPistol",
			"Summons a Marine to fight with you\n\cjShotgun",
			"Summons a Marine to fight with you\n\cjSuper Shotgun",
			"Summons a Marine to fight with you\n\cjChaingun",
			"Summons a Marine to fight with you\n\cjRocket Launcher",
			"Summons a Marine to fight with you\n\cjPlasma Rifle",
			"Summons a Marine to fight with you\n\cjRailgun",
			"Summons a Marine to fight with you\n\cjBFG 9000",
		},
		{
			"Summon Zombieman",
			"Summons a Zombieman to fight with you",
		},
		{
			"Summon Shotgun Guy",
			"Summons a Shotgun Guy to fight with you",
		},
		{
			"Summon Chaingun Guy",
			"Summons a Chaingun Guy to fight with you",
		},
		{
			"Summon Imp",
			"Summons an Imp to fight with you",
		},
		{
			"Summon Demon",
			"Summons a Demon to fight with you",
		},
		{
			"Summon Cacodemon",
			"Summons a Cacodemon to fight with you",
		},
		{
			"Summon Hell Knight",
			"Summons a Hell Knight to fight with you",
		},
		{
			"Summon Baron of Hell",
			"Summons a Baron of Hell to fight with you",
		},
		{
			"Summon Lost Soul",
			"Summons a Lost Soul to fight with you",
		},
		{
			"Summon Pain Elemental",
			"Summons a Pain Elemental to fight with you",
		},
		{
			"Summon Revenant",
			"Summons a Revenant to fight with you",
		},
		{
			"Summon Fatso",
			"Summons a Fatso to fight with you",
		},
		{
			"Summon Arachnotron",
			"Summons an Arachnotron to fight with you",
		},
		{
			"Summon Arch-Vile",
			"Summons an Arch-Vile to fight with you",
		},
		{
			"Summon Cyberdemon",
			"Summons a Cyberdemon to fight with you",
		},
		{
			"Summon Spider Mastermind",
			"Summons a Spider Mastermind to fight with you",
		},
	},
	
	// Utility
	{
		{
			"Breakdown Armor",
			"Breaks down your current Armor into Credits",
		},
		{
			"Force Wall",
			"Creates a small force wall in front of you to absorb damage",
			"Creates a large force wall in front of you to absorb damage",
		},
		{
			"Rally",
			"Teleports your summoned monsters to you",
		},
		{
			"Unsummon",
			"Banishes all of the friendly creatures under your control",
			"Banishes all of the friendly creatures under your control\nEach creature banished restores\n25 EP",
		},
		{
			"Magnetize",
			"Pulls some dropped items to you",
		},
		{
			"Transport",
			"Brings you to the UAC Outpost\nUse in Outpost to return to current level"
		},
	}
};

function int GetSkillSlot(int Slot)
{
	return (SkillCatagory[Slot] * MAX_SKILLS) + SkillIndex[Slot];
}

function int GetSkillID(int Catagory, int ID)
{
	return (Catagory * MAX_SKILLS) + ID;
}

function int ScaleEPCost(int Cost)
{
	if (!GetCVAR("drpg_skill_costscale")) return Cost;

	switch (GameSkill())
	{
		case 5: Cost = FixedMul(Cost, 1.5); break;
		case 6: Cost = FixedMul(Cost, 2.0); break;
		case 7: Cost = FixedMul(Cost, 2.5); break;
	}
	
	return Cost;
}

// Use Skill Script
script "UseSkill" (int Index)
{
	// If you're dead, terminate
	if (GetActorProperty(0, APROP_HEALTH) <= 0) terminate;

	int EPCost = FixedDiv(SkillCosts[SkillCatagory[Index]][SkillIndex[Index]] * CurrentSkillLevel[GetSkillSlot(Index)], SkillCostMult);
	int Buttons = GetPlayerInput(0, INPUT_BUTTONS);
	int OldButtons = GetPlayerInput(0, INPUT_OLDBUTTONS);
	int Success;
	
	// Overdrive?
	Overdrive = false;
	if (Buttons & BT_SPEED)
		Overdrive = true;

	// Scale EP costs to skill level
	EPCost = ScaleEPCost(EPCost);

	// If you're in the Skills menu, assign the key to the selected skill
	if (InMenu && Menu == 3)
	{
		if (Buttons & BT_SPEED)
		{
			ActivatorSound("menu/move", 127);
			SkillCatagory[Index] = -1;
			SkillIndex[Index] = -1;
			terminate;
		}

		for (int i = 0; i < 5; i++)
			if (SkillCatagory[i] == SkillPage && SkillIndex[i] == MenuIndex)
			{
				ActivatorSound("menu/error", 127);
				terminate;
			}
		
		ActivatorSound("menu/move", 127);
		SkillCatagory[Index] = SkillPage;
		SkillIndex[Index] = MenuIndex;
		terminate;
	}
	
	// If the key is unassigned, terminate
	if (SkillCatagory[Index] == -1 || SkillIndex[Index] == -1) terminate;

	// Overdriving an unlearnt skill will learn it
	if (Overdrive && CheckInventory("SkillToken") > 0 && SkillLevel[GetSkillSlot(Index)] == 0)
	{
		SkillLevel[GetSkillSlot(Index)]++;
		CurrentSkillLevel[GetSkillSlot(Index)]++;
		TakeInventory("SkillToken", 1);
		FadeRange(0, 255, 255, 0.5, 0, 255, 255, 0.0, 0.5);
		terminate;
	}
	
	// Check if the Skill has been learned yet
	if (SkillLevel[GetSkillSlot(Index)] == 0)
	{
		SetFont("BIGFONT");
		Print(s:"\cgYou don't know this skill yet");
		ActivatorSound("skills/fail", 127);
		terminate;
	}

	// Can't use skills while burned out
	if (EP < 0)
	{
		SetFont("BIGFONT");
		Print(s:"\chYou can't use skills while burned out");
		ActivatorSound("skills/fail", 127);
		terminate;
	}
	
	// Normal skills
	if (EP >= EPCost || Overdrive)
	{
		switch (SkillCatagory[Index])
		{
			case 0: // Healing
				switch (SkillIndex[Index])
				{
					case 0:		Success = Heal();					break; // Heal
					case 1:		Success = Repair();					break; // Repair Armor
				}
				break;
			
			case 1: // Powerups
				switch (SkillIndex[Index])
				{
					case 0:		Success = Powerup(1);				break; // Invulnerability
					case 1:		Success = Powerup(2);				break; // Invisibility
					case 2:		Success = Powerup(3);				break; // Time Freeze
					case 3:		Success = Powerup(4);				break; // Iron Feet
					case 4:		Success = Powerup(5);				break; // Night Vision
					case 5:		Success = Powerup(6);				break; // Berserk
					case 6:		Success = Powerup(7);				break; // Mind Mapping
					case 7:		Success = Powerup(8);				break; // Drop Rune
					case 8:		Success = Powerup(9);				break; // Drop Ammo
				}
				break;
			
			case 2: // Auras
				ActivatorSound("skills/buff", 127);
				if (SkillIndex[Index] == Aura - 1)
					AuraTimer += 1050 + FixedMul(Energy, 5.25);
				else
					AuraTimer = 1050 + FixedMul(Energy, 5.25);
				switch (SkillIndex[Index])
				{
					case 0:		Aura = 1;							break; // Red Aura
					case 1:		Aura = 2;							break; // Green Aura
					case 2:		Aura = 3;							break; // White Aura
					case 3:		Aura = 4;							break; // Pink Aura
					case 4:		Aura = 5;							break; // Blue Aura
					case 5:		Aura = 6;							break; // Purple Aura
					case 6:		Aura = 7;							break; // Orange Aura
					case 7:		Aura = 8;							break; // Dark Blue Aura
					case 8:		Aura = 9;							break; // Yellow Aura
				}
				Success = true;
				break;
			
			case 3: // Attacks
				switch (SkillIndex[Index])
				{
					case 0:		Success = Attack(1, 1);				break; // Fireball
					case 1:		Success = Attack(1, 2);				break; // Fireball Nova
					case 2:		Success = Attack(2, 1);				break; // Ice Missile
					case 3:		Success = Attack(2, 2);				break; // Ice Nova
				}
				break;
			
			case 4: // Summoning
				switch (SkillIndex[Index])
				{
					case 0:		Success = Summon(1);				break; // Summon Marine
					case 1:		Success = Summon(2);				break; // Summon Zombieman
					case 2:		Success = Summon(3);				break; // Summon Shotgun Guy
					case 3:		Success = Summon(4);				break; // Summon Chaingun Guy
					case 4:		Success = Summon(5);				break; // Summon Imp
					case 5:		Success = Summon(6);				break; // Summon Demon
					case 6:		Success = Summon(7);				break; // Summon Cacodemon
					case 7:		Success = Summon(8);				break; // Summon Hell Knight
					case 8:		Success = Summon(9);				break; // Summon Baron of Hell
					case 9:		Success = Summon(10);				break; // Summon Lost Soul
					case 10:	Success = Summon(11);				break; // Summon Pain Elemental
					case 11:	Success = Summon(12);				break; // Summon Revenant
					case 12:	Success = Summon(13);				break; // Summon Fatso
					case 13:	Success = Summon(14);				break; // Summon Arachnotron
					case 14:	Success = Summon(15);				break; // Summon Arch-Vile
					case 15:	Success = Summon(16);				break; // Summon Cyberdemon
					case 16:	Success = Summon(17);				break; // Summon Spider Mastermind
				}
				break;
				
			case 5: // Utility
				switch (SkillIndex[Index])
				{
					case 0:		Success = BreakdownArmor();			break; // Breakdown Armor
					case 1:		Success = ForceWall();				break; // Force Wall
					case 2:		Success = Rally();					break; // Rally
					case 3:		Success = Unsummon();				break; // Unsummon
					case 4:		Success = Magnet();					break; // Magnetize
					case 5:		ACS_NamedExecute("Transport", 0);	break; // Transport
				}
				break;
		}
		
		if (Success)
			EP -= EPCost;
	}
	else // Not enough EP
	{
		SetFont("BIGFONT");
		Print(s:"\cgNot enough EP to use this skill!");
		ActivatorSound("skills/fail", 127);
	}

	// Special skills that need different behaviour
	{
	}
}

// Skill HUD Script
script "DrawSkillHUD" enter
{
	while (1)
	{
		// If you're dead, terminate
		if (GetActorProperty(0, APROP_HEALTH) <= 0) terminate;
	
		int x = GetCVAR("drpg_skill_x");
		int y = GetCVAR("drpg_skill_y");

		for (int i = 4; i >= 0; i--)
		{
			// If the skill key is blank, skip
			if (SkillCatagory[i] == -1 || SkillIndex[i] == -1) continue;
			
			int SkillCost = FixedDiv(ScaleEPCost(SkillCosts[SkillCatagory[i]][SkillIndex[i]] * CurrentSkillLevel[GetSkillSlot(i)]), SkillCostMult);
			int Color = CR_GREEN;

			if (EP < SkillCost)
				Color = CR_RED;
			
			if (CurrentSkillLevel[GetSkillSlot(i)] == 0)
			{
				Color = CR_RED;
				
				HudMessage(s:SkillData[SkillCatagory[i]][SkillIndex[i]][0];
						   HUDMSG_PLAIN, 0, Color,
						   x, y, 0.05);
			}
			else
				HudMessage(s:SkillData[SkillCatagory[i]][SkillIndex[i]][0],
						   s:" (",
						   d:CurrentSkillLevel[GetSkillSlot(i)],
						   s:"/",
						   d:SkillLevel[GetSkillSlot(i)],
						   s:") [\cn",
						   d:SkillCost,
						   s:"\c-]";
						   HUDMSG_PLAIN, 0, Color,
						   x, y, 0.05);
			
			y -= 0.025;
		}
		
		/* WIP for displaying the skill description stuff using SBARINFO instead of ACS
		str Color;
		int SkillCost;
		str Description;
		
		for (int i = 0; i <= MAX_CATEGORIES - 1; i++)
		{
			Color = "\cd";
			SkillCost = FixedDiv(ScaleEPCost(SkillCosts[i][SkillIndex[i]] * CurrentSkillLevel[(i * MAX_SKILLS) + SkillIndex[i]]), SkillCostMult);
			
			// Set color to red if not learned or not enough EP
			if (SkillLevel[(i * MAX_SKILLS) + SkillIndex[i]] == 0 || EP < SkillCost)
				Color = "\cg";
			
			if (SkillLevel[(i * MAX_SKILLS) + SkillIndex[i]] == 0)
				Description = StrParam(s:Color,
									   s:SkillData[i][SkillIndex[i]][0]);
			else
				Description = StrParam(s:Color,
									   s:SkillData[i][SkillIndex[i]][0],
									   s:" (",
									   d:CurrentSkillLevel[(i * MAX_SKILLS) + SkillIndex[i]],
									   s:"/",
									   d:SkillLevel[(i * MAX_SKILLS) + SkillIndex[i]],
									   s:") [\cn",
									   d:SkillCost,
									   s:Color,
									   s:"]");

			
			if (i == 0) SkillDescriptionRecovery = Description;
			if (i == 1) SkillDescriptionPowerup = Description;
			if (i == 2) SkillDescriptionAura = Description;
			if (i == 3) SkillDescriptionAttack = Description;
			if (i == 4) SkillDescriptionSummon = Description;
			if (i == 5) SkillDescriptionUtility = Description;
		}
		*/
		
		delay(1);
	}
}

// Handles the Transportation system
script "Transport" (void)
{
	// Fade Screen
	FadeRange(255, 255, 255, 0.0, 255, 255, 255, 1.0, 1.0);
	
	// Freeze Player
	SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
	
	// Delay and unfreeze Player
	Delay(35);
	SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
	
	// Transport
	if (!InBase)
	{
		LevelNum = GetLevelInfo(LEVELINFO_LEVELNUM);
		Teleport_NewMap(999, 0, 0);
		InBase = true;
		Transported = true;
	}
	else
	{
		EP += ScaleEPCost(25);
		Teleport_NewMap(LevelNum, 0, 0);
		InBase = false;
		Transported = true;
	}
}

// Heal
function int Heal(void)
{
	// Refund - If your health is max or above
	if (!Overdrive && GetActorProperty(0, APROP_HEALTH) >= GetActorProperty(0, APROP_SPAWNHEALTH))
	{
		ActivatorSound("menu/error", 127);
		return false;
	}

	FadeRange(255, 0, 0, 0.5, 255, 0, 0, 0, 1.0);
	HealThing(Energy * 10);
	ActivatorSound("skills/heal", 127);
	
	// Overdrive - Heal Summoned Monsters
	if (Overdrive)
		for (int i = SummonID; i <= SummonID + MaxSummons; i++)
			SetActorProperty(i, APROP_HEALTH, GetActorProperty(i, APROP_SPAWNHEALTH));
	
	return true;
}

// Repair Armor
function int Repair(void)
{
	if (CheckInventory("Armor") < ArmorMax && CheckArmorType() != "")
	{
		print(d:ArmorMax);
		
		FadeRange(0, 255, 0, 0.5, 0, 255, 0, 0, 1.0);
		GiveInventory("ArmorBonus", Energy * 10);
		
		if (CheckInventory("Armor") > ArmorMax)
		{
			int ArmorOverflow = CheckInventory("BasicArmor") - ArmorMax;
			TakeInventory("BasicArmor", ArmorOverflow);
		}
		
		ActivatorSound("skills/repair", 127);
		return true;
	}
	else
	{
		ActivatorSound("menu/error", 127);
		return false;
	}
	
	return false;
}

// Powerups
function int Powerup(int Type)
{
	// Levels
	int InvulnLevel = CurrentSkillLevel[MAX_SKILLS + 0];
	int InvisLevel = CurrentSkillLevel[MAX_SKILLS + 1];
	int TimeLevel = CurrentSkillLevel[MAX_SKILLS + 2];
	
	switch (Type)
	{
		case 1: // Invulnerability
			ActivatorSound("powerups/protect", 127);
			GiveInventory(StrParam(s:"SkillInvulnerability", d:InvulnLevel), 1);
			break;
		case 2: // Invisibility
			ActivatorSound("powerups/invis", 127);
			GiveInventory(StrParam(s:"SkillInvisibility", d:InvisLevel), 1);
			break;
		case 3: // Time Freeze
			BulletTime(TimeLevel);
			break;
		case 4: // Iron Feet
			ActivatorSound("powerups/suit", 127);
			GiveInventory("PowerIronFeet", 1);
			break;
		case 5: // Night Vision
			ActivatorSound("powerups/light", 127);
			GiveInventory("PowerLightAmp", 1);
			break;
		case 6: // Berserk
			ActivatorSound("powerups/berserk", 127);
			GiveInventory("Berserk", 1);
			break;
		case 7: // Mind Mapping
			ActivatorSound("powerups/map", 127);
			GiveInventory("AllMap", 1);
			break;
		case 8: // Drop Rune
			return DropRune();
			break;
		case 9: // Drop Ammo
			return DropAmmo();
			break;
	}
	
	return true;
}

// Drops a random Rune in front of you
function int DropRune(void)
{
	int Angle = GetActorAngle(0);
	int X = GetActorX(0) + cos(Angle) * 96;
	int Y = GetActorY(0) + sin(Angle) * 96;
	int Z = GetActorZ(0) + 48.0;
	str Rune;
	
	switch (Random(1, 9))
	{
		case 1: Rune = "StrengthRune";		break;
		case 2: Rune = "DrainRune";			break;
		case 3: Rune = "EndlessRune";		break;
		case 4: Rune = "ResistanceRune";	break;
		case 5: Rune = "RegenerationRune";	break;
		case 6: Rune = "FrightRune";		break;
		case 7: Rune = "GhostRune";			break;
		case 8: Rune = "HighJumpRune";		break;
		case 9: Rune = "HasteRune";			break;
	}
	
	if (!Spawn(Rune, X, Y, Z, 0, Angle) == 0)
	{
		ActivatorSound("skills/drop", 127);
		Spawn("TeleportFog", X, Y, Z, 0, Angle);
		return true;
	}
	else
	{
		ActivatorSound("menu/error", 127);
		return false;
	}
	
	return false;
}

// Drops a backpack in front of you
function int DropAmmo(void)
{
	int Angle = GetActorAngle(0);
	int X = GetActorX(0) + cos(Angle) * 96;
	int Y = GetActorY(0) + sin(Angle) * 96;
	int Z = GetActorZ(0) + 48.0;
	
	if (!Spawn("BigBackPack", X, Y, Z, 0, Angle) == 0)
	{
		ActivatorSound("skills/drop", 127);
		Spawn("TeleportFog", X, Y, Z, 0, Angle);
		return true;
	}
	else
	{
		ActivatorSound("menu/error", 127);
		return false;
	}

	return false;
}

// Attack skills will use this
function int Attack(int Element, int Type)
{
	int X = GetActorX(0);
	int Y = GetActorY(0);
	int Z = GetActorZ(0);
	int Pitch = GetActorPitch(0);
	int Angle = GetActorAngle(0);
	int XSpeed = FixedMul(cos(Angle), 16.0);
	int YSpeed = FixedMul(sin(Angle), 16.0);
	int ZSpeed = -FixedMul(sin(Pitch), 16.0);
	int FireHeight = GetActorViewHeight(0) * 780 / 1000;
	int Offset = 8.0;
	int AngleAdd;
	str AttackType;
	int AttackLevel;
	int Projectiles;
	int i;
	
	// Hack - Can't use projectile skills in the water)
	if (Type == 1 && GetActorProperty(0, APROP_WATERLEVEL) > 0)
	{
		AmbientSound("menu/error", 127);
		return false;
	}
	
	// Apply proper projectile type from the specified element
	switch (Element)
	{
		case 1: AttackType = "Fireball";	break;
		case 2: AttackType = "IceMissile";	break;
	}
	
	if (Type == 1) // Projectile
	{
		AttackLevel = SkillLevel[GetSkillID(3, Element * 2)];
		SpawnProjectile(0, AttackType, 0, 0, 0, 0, 2001);
		SetActorVelocity(2001, XSpeed, YSpeed, ZSpeed, 0, 0);
		SetActorAngle(2001, Angle);
		SetActorPosition(2001, X, Y, Z + FireHeight + Offset, 0);
		Thing_ChangeTID(2001, UniqueTID());
		return true;
	}
	if (Type == 2) // Nova
	{
		AttackLevel = SkillLevel[GetSkillID(3, (Element * 2) - 1)];
		Projectiles = AttackLevel * 8;
		AngleAdd = FixedDiv(1.0, Projectiles) >> 16;
		
		for (i = 0; i < Projectiles; i++)
		{
			XSpeed = FixedMul(cos(Angle), 16.0);
			YSpeed = FixedMul(sin(Angle), 16.0);
			ZSpeed = -FixedMul(sin(Pitch), 16.0);
			
			SpawnProjectile(0, AttackType, 0, 0, 0, 0, 2001);
			SetActorVelocity(2001, XSpeed, YSpeed, ZSpeed, 0, 0);
			SetActorAngle(2001, Angle);
			SetActorPosition(2001, X, Y, Z + FireHeight + Offset, 0);
			Thing_ChangeTID(2001, UniqueTID());
			
			Angle += AngleAdd;
		}
	
		return true;
	}
	if (Type == 3) // Hitscan?
	{
		return true;
	}
	// etc
	
	return false;
}

// Summoning
function int Summon(int Type)
{
	int Angle = GetActorAngle(0);
	int X = GetActorX(0) + cos(Angle) * 96;
	int Y = GetActorY(0) + sin(Angle) * 96;
	int Z = GetActorZ(0);
	int MarineLevel = CurrentSkillLevel[GetSkillID(4, 0)];
	int NewID = SummonID + MaxSummons;
	bool Success;
	
	switch (Type)
	{
		// Marines
		case 1:
			if (GetCVAR("drpg_ext_brutal"))
				switch (MarineLevel)
				{
					case 1: Success = Spawn("Marine_Pistol", X, Y, Z, NewID, Angle);			break;
					case 2: Success = Spawn("Marine_Shotgun", X, Y, Z, NewID, Angle);			break;
					case 3: Success = Spawn("Marine_SSG", X, Y, Z, NewID, Angle);				break;
					case 4: Success = Spawn("Marine_Minigun", X, Y, Z, NewID, Angle);			break;
					case 5: Success = Spawn("Marine_Rocket", X, Y, Z, NewID, Angle);			break;
					case 6: Success = Spawn("Marine_Plasma", X, Y, Z, NewID, Angle);			break;
					case 7: Success = Spawn("Marine_Railgun", X, Y, Z, NewID, Angle);			break;
					case 8: Success = Spawn("Marine_BFG", X, Y, Z, NewID, Angle);				break;
				}
			else if (GetCVAR("drpg_ext_extras"))
				switch (MarineLevel)
				{
					case 1: Success = Spawn("MarinePistol2", X, Y, Z, NewID, Angle);			break;
					case 2: Success = Spawn("MarineShotgun2", X, Y, Z, NewID, Angle);			break;
					case 3: Success = Spawn("MarineSSG2", X, Y, Z, NewID, Angle);				break;
					case 4: Success = Spawn("MarineChaingun2", X, Y, Z, NewID, Angle);;			break;
					case 5: Success = Spawn("MarineRocket2", X, Y, Z, NewID, Angle);			break;
					case 6: Success = Spawn("MarinePlasma2", X, Y, Z, NewID, Angle);			break;
					case 7: Success = Spawn("MarineRailgun2", X, Y, Z, NewID, Angle);			break;
					case 8: Success = Spawn("MarineBFG2", X, Y, Z, NewID, Angle);				break;
				}
			else
				switch (MarineLevel)
				{
					case 1: Success = Spawn("MarinePistol", X, Y, Z, NewID, Angle);				break;
					case 2: Success = Spawn("MarineShotgun", X, Y, Z, NewID, Angle);			break;
					case 3: Success = Spawn("MarineSSG", X, Y, Z, NewID, Angle);				break;
					case 4: Success = Spawn("MarineChaingun", X, Y, Z, NewID, Angle);;			break;
					case 5: Success = Spawn("MarineRocket", X, Y, Z, NewID, Angle);				break;
					case 6: Success = Spawn("MarinePlasma", X, Y, Z, NewID, Angle);				break;
					case 7: Success = Spawn("MarineRailgun", X, Y, Z, NewID, Angle);			break;
					case 8: Success = Spawn("MarineBFG", X, Y, Z, NewID, Angle);				break;
				}
			break;
		
		// Monsters
		case 2: 			Success = Spawn("Zombieman", X, Y, Z, NewID, Angle);				break;
		case 3: 			Success = Spawn("ShotgunGuy", X, Y, Z, NewID, Angle);				break;
		case 4: 			Success = Spawn("ChaingunGuy", X, Y, Z, NewID, Angle);				break;
		case 5: 			Success = Spawn("DoomImp", X, Y, Z, NewID, Angle);					break;
		case 6: 			Success = Spawn("Demon", X, Y, Z, NewID, Angle);					break;
		case 7: 			Success = Spawn("Cacodemon", X, Y, Z, NewID, Angle);				break;
		case 8: 			Success = Spawn("HellKnight", X, Y, Z, NewID, Angle);				break;
		case 9: 			Success = Spawn("BaronOfHell", X, Y, Z, NewID, Angle);				break;
		case 10: 			Success = Spawn("LostSoul", X, Y, Z, NewID, Angle);					break;
		case 11: 			Success = Spawn("PainElemental", X, Y, Z, NewID, Angle);			break;
		case 12: 			Success = Spawn("Revenant", X, Y, Z, NewID, Angle);					break;
		case 13: 			Success = Spawn("Fatso", X, Y, Z, NewID, Angle);					break;
		case 14: 			Success = Spawn("Arachnotron", X, Y, Z, NewID, Angle);				break;
		case 15: 			Success = Spawn("Archvile", X, Y, Z, NewID, Angle);					break;
		case 16: 			Success = Spawn("Cyberdemon", X, Y, Z, NewID, Angle);				break;
		case 17: 			Success = Spawn("SpiderMastermind", X, Y, Z, NewID, Angle);			break;
	}
	
	SpawnForced("TeleportFog", X, Y, Z, NewID, Angle);
	SetActorAngle(NewID, Angle);
	SetActorProperty(NewID, APROP_FRIENDLY, 1);
	SetActorState(NewID, "Spawn");
	MaxSummons++;
	
	// Refund - Give EP back if the summon failed
	if (!Success)
	{
		ActivatorSound("menu/error", 127);
		return false;
	}
	
	return true;
}

// Breaks down current Armor into Credits
function int BreakdownArmor(void)
{
	int Armor = CheckInventory("BasicArmor");
	
	// Can't use Breakdown Armor while the Shield is active
	if (CheckInventory("Shield"))
	{
		ActivatorSound("menu/error", 127);
		return false;
	}

	if (Armor > 0)
	{
		for (int i = 0; i <= Armor - 1; i++)
		{
			TakeInventory("BasicArmor", 1);
			GiveInventory("Credits1", 1);
		}
		ActivatorSound("skills/breakdown", 127);
		return true;
	}
	else
	{
		ActivatorSound("menu/error", 127);
		return false;
	}
	
	return false;
}

// Drops a Force Field in front of you
function int ForceWall(void)
{
	int Angle = GetActorAngle(0);
	int X = GetActorX(0) + cos(Angle) * 96;
	int Y = GetActorY(0) + sin(Angle) * 96;
	int Z = GetActorZ(0);
	int WallLevel = CurrentSkillLevel[GetSkillID(5, 1)];
	
	switch (WallLevel)
	{
		case 1:
			if (!Spawn("ForceField", X, Y, Z, 1998, Angle) == 0) return true;
			else
			{
				ActivatorSound("menu/error", 127);
				return false;
			}
			break;
		case 2:
			if (!Spawn("ForceField2", X, Y, Z, 1998, Angle) == 0) return true;
			else
			{
				ActivatorSound("menu/error", 127);
				return false;
			}
			break;
	}

	return false;
}

// Rallies (teleports) your summoned monster/marines around you
function int Rally(void)
{
	int X = GetActorX(0);
	int Y = GetActorY(0);
	int Z = GetActorZ(0);
	int Angle = GetActorAngle(0);
	
	// Fail if you have no summons active
	if (MaxSummons == 0)
	{
		ActivatorSound("menu/error", 127);
		return false;
	}
	
	for (int i = SummonID; i < SummonID + MaxSummons; i++)
		if (GetActorProperty(i, APROP_HEALTH) > 0)
			SetActorPosition(i, X, Y, Z, true);
	
	ActivatorSound("skills/rally", 127);
	return true;
}

// Unsummon - Removes all actors under the player's control
function int Unsummon(void)
{
	bool Kill = Overdrive;
	int UnsummonLevel = CurrentSkillLevel[GetSkillID(5, 2)];
	int EPAdd;
	
	// Fail if you have no summons active
	if (MaxSummons == 0)
	{
		ActivatorSound("menu/error", 127);
		return false;
	}
	
	for (int i = SummonID; i <= SummonID + MaxSummons; i++)
	{
		if (!Kill && UnsummonLevel == 2 && GetActorProperty(i, APROP_HEALTH) > 0)
			EPAdd += 25;
		
		// Overdrive - Remove summons (teleport out) instead of killing them
		if (Kill && GetActorProperty(i, APROP_HEALTH) > 0)
			Thing_Destroy(i, 1, 0);
		else
		{
			SpawnForced("TeleportFog", GetActorX(i), GetActorY(i), GetActorZ(i), 0, 0);
			Thing_Remove(i);
		}
	}
	
	if (Kill)
		ActivatorSound("skills/unsummon", 127);
	
	if (UnsummonLevel == 2)
		EP += EPAdd;

	MaxSummons = 0;
	FadeRange(192, 0, 0, 0.5, 192, 0, 0, 0.0, 1.0);
	return true;
}

// Magnetize - Pull some (Luck based for now) items to the player's position
function int Magnet(void)
{
	int X;
	int Y;
	int Z;
	int Angle;
	int AngleAdd;
	int Radius;
	
	// Fail if there are no pullable items on the ground
	if (MaxItems == 0)
	{
		ActivatorSound("menu/error", 127);
		return false;
	}
	
	// Determine Circie Size
		AngleAdd += MaxItems;
	
	// Set Circle Size
	Radius = GetCVAR("drpg_skill_radius");
	AngleAdd = FixedDiv(1.0, AngleAdd);

	// Create the Circle
	for (int i = ItemID; i <= ItemID + MaxItems; i++)
	{
		X = GetActorX(0) + FixedMul(cos(Angle), Radius);
		Y = GetActorY(0) + FixedMul(sin(Angle), Radius);
		Z = GetActorZ(0) + 48.0;
		
		if (!IsTIDUsed(i)) continue;
		
		if (Overdrive)
			SetActorPosition(i, GetActorX(0), GetActorY(0), GetActorZ(0), 0);
		else
			SetActorPosition(i, X, Y, Z, 0);
			
		Angle += AngleAdd;
	}
	
	// FX
	FadeRange(0, 0, 0, 0.75, 0, 0, 0, 0.0, 1.0);
	ActivatorSound("skills/magnet", 127);
	return true;
}

// Abuse PowerTimeFreezer to create a bullet-time effect
function void BulletTime(int Mode)
{
	BulletTimeMode = Mode;
	BulletTimeTimer = 350;
	
	// Remove duplicate TimeFreezerSounds
	Thing_Remove(1999);
	
	if (Mode == 1) // Stutter Time
	{
		SpawnForced("TimeFreezerQuickSound", GetActorX(0), GetActorY(0), GetActorZ(0), 1999, 0);
		SetActorState(1999, "Spawn");
		TakeInventory("PowerTimeFreezer", 1);
		GiveInventory("TimeFreezerQuick", 1);
	}
	if (Mode == 2) // Freeze Time
	{
		SpawnForced("TimeFreezerSound", GetActorX(0), GetActorY(0), GetActorZ(0), 1999, 0);
		SetActorState(1999, "Spawn");
		GiveInventory("TimeFreezer", 1);
	}
}

function void CheckSkills(void)
{
	// Aura-related vars to save typing :P
	int X = GetActorX(0);
	int Y = GetActorY(0);
	int Z = GetActorZ(0);
	int RedAuraLevel = CurrentSkillLevel[GetSkillID(2, 0)];
	int GreenAuraLevel = CurrentSkillLevel[GetSkillID(2, 1)];
	int WhiteAuraLevel = CurrentSkillLevel[GetSkillID(2, 2)];
	int PinkAuraLevel = CurrentSkillLevel[GetSkillID(2, 3)];
	int BlueAuraLevel = CurrentSkillLevel[GetSkillID(2, 4)];
	int PurpleAuraLevel = CurrentSkillLevel[GetSkillID(2, 5)];
	int OrangeAuraLevel = CurrentSkillLevel[GetSkillID(2, 6)];
	int DarkBlueAuraLevel = CurrentSkillLevel[GetSkillID(2, 7)];
	int YellowAuraLevel = CurrentSkillLevel[GetSkillID(2, 8)];
	int Gained = 0;
	
	// Reset the Skill multiplier from the Blue Aura
	if (Aura != 5)
		SkillCostMult = 1.0;
	
	// Give the player the Aura item while an Aura is active (for SBARINFO hax)
	if (AuraTimer > 0)
		GiveInventory("Aura", 1);
	else
		TakeInventory("Aura", 1);
	
	// Aura Timer handling
	if (AuraTimer > 0)
	{
		if (!CheckInventory("MenuFreezer")) // lolhax
			switch (Aura)
			{
				// Red Aura
				case 1:
					SpawnForced("RedAura", X, Y, Z + 32, 2300, 0);
					FadeRange(255, 0, 0, 0.1, 255, 0, 0, 0.0, 1.0);
					if (RedAuraLevel == 1)
						Damage *= 2;
					if (RedAuraLevel >= 2)
						Damage *= 4;
					if (RedAuraLevel >= 3)
						GiveInventory("RedAura1", 1);
					break;
				// Green Aura
				case 2:
					SpawnForced("GreenAura", X, Y, Z + 32, 2300, 0);
					FadeRange(0, 255, 0, 0.1, 0, 255, 0, 0.0, 1.0);
					if (GreenAuraLevel >= 1 && GreenAuraLevel < 2)
						DamageFactor /= 2;
					if (GreenAuraLevel >= 2)
						DamageFactor /= 4;
					if (GreenAuraLevel == 3)
						GiveInventory("GreenAura1", 1);
					if (GreenAuraLevel == 4)
						GiveInventory("GreenAura2", 1);
					if (GreenAuraLevel >= 5)
						GiveInventory("GreenAura3", 1);
					break;
				// White Aura
				case 3:
					SpawnForced("WhiteAura", X, Y, Z + 32, 2300, 0);
					FadeRange(255, 255, 255, 0.1, 255, 255, 255, 0.0, 1.0);
					if (WhiteAuraLevel >= 2)
					{
						if (Combo == 0) Combo++;
						ComboTimer = 100;
					}
					if (WhiteAuraLevel >= 3)
						if (Random(1, 350) < 35)
							TotalGained++;
					if (WhiteAuraLevel >= 4)
						if (Random(1, 350) < 35)
							TotalGained++;
					break;
				// Pink Aura
				case 4:
					SpawnForced("PinkAura", X, Y, Z + 32, 2300, 0);
					FadeRange(255, 0, 255, 0.1, 255, 0, 255, 0.0, 1.0);
					if (PinkAuraLevel >= 1)
						GiveInventory("PinkAura2", 1);
					break;
				// Blue Aura
				case 5:
					SpawnForced("CyanAura", X, Y, Z + 32, 2300, 0);
					FadeRange(0, 255, 255, 0.1, 0, 255, 255, 0.0, 1.0);
					if (BlueAuraLevel == 1)
						SkillCostMult = 1.33;
					if (BlueAuraLevel == 2)
						SkillCostMult = 2.0;
					if (BlueAuraLevel == 3)
						SkillCostMult = 4.0;
					break;
				// Purple Aura
				case 6:
					SpawnForced("PurpleAura", X, Y, Z + 32, 2300, 0);
					FadeRange(255, 0, 128, 0.1, 255, 0, 128, 0.0, 1.0);
					if (PurpleAuraLevel == 1)
					{
						HPRate += FixedMul(Vitality, 1.25) + FixedMul(Regeneration, 1.25);
						EPRate += FixedMul(Energy, 1.25) + FixedMul(Energy, 1.25);
					}
					if (PurpleAuraLevel == 2)
					{
						HPRate += FixedMul(Vitality, 1.25) + FixedMul(Regeneration, 1.25) * 2;
						EPRate += FixedMul(Energy, 1.25) + FixedMul(Energy, 1.25) * 2;
					}
					if (PurpleAuraLevel == 3)
					{
						HPRate += FixedMul(Vitality, 1.25) + FixedMul(Regeneration, 1.25) * 3;
						EPRate += FixedMul(Energy, 1.25) + FixedMul(Energy, 1.25) * 3;
					}
					if (PurpleAuraLevel == 4)
					{
						HPRate += FixedMul(Vitality, 1.25) + FixedMul(Regeneration, 1.25) * 3;
						EPRate += FixedMul(Energy, 1.25) + FixedMul(Energy, 1.25) * 3;
						ShieldTimer = 0;
					}
					break;
				// Orange Aura
				case 7:
					SpawnForced("OrangeAura", X, Y, Z + 32, 2300, 0);
					FadeRange(255, 128, 0, 0.1, 255, 128, 0, 0.0, 1.0);
					if (OrangeAuraLevel >= 1)
						GiveInventory("OrangeAura1", 1);
					if (OrangeAuraLevel >= 2)
						GiveInventory("OrangeAura2", 1);
					if (OrangeAuraLevel >= 3)
						GiveInventory("OrangeAura3", 1);
					break;
				// Dark Blue Aura
				case 8:
					SpawnForced("BlueAura", X, Y, Z + 32, 2300, 0);
					FadeRange(0, 0, 128, 0.1, 0, 0, 128, 0.0, 1.0);
					if (Random(1, 350) < 35)
					{
						if (DarkBlueAuraLevel >= 1)
							GiveInventory("Clip", 1);
						if (DarkBlueAuraLevel >= 2)
							GiveInventory("Shell", 1);
						if (DarkBlueAuraLevel >= 3)
							GiveInventory("RocketAmmo", 1);
						if (DarkBlueAuraLevel >= 4)
							GiveInventory("Cell", 1);
					}
					break;
				// Yellow Aura
				case 9:
					SpawnForced("YellowAura", X, Y, Z + 32, 2300, 0);
					FadeRange(255, 255, 0, 0.1, 255, 255, 0, 0.0, 1.0);
					if (YellowAuraLevel >= 1)
					{
						if (Random(1, 350) < 35)
							GiveInventory("Credits", Random(0, RankLevel + 1));
						MoneyChance[0] *= 2;
						MoneyChance[1] *= 2;
						MoneyChance[2] *= 2;
						MoneyChance[3] *= 2;
						MoneyChance[4] *= 2;
						MoneyChance[5] *= 2;
						MoneyChance[6] *= 2;
					}
					if (YellowAuraLevel >= 2)
					{
						if (Random(1, 350) < 35)
							GiveInventory("Credits", Random(0, RankLevel + 1));
						HealthChance[0] *= 2;
						HealthChance[1] *= 2;
						HealthChance[2] *= 2;
					}
					if (YellowAuraLevel >= 3)
					{
						if (Random(1, 350) < 35)
							GiveInventory("Credits", Random(0, RankLevel + 1));
						ArmorChance[0] *= 2;
						ArmorChance[1] *= 2;
						ArmorChance[2] *= 2;
						ArmorChance[3] *= 2;
						ArmorChance[4] *= 2;
					}
					if (YellowAuraLevel >= 4)
					{
						if (Random(1, 350) < 35)
							GiveInventory("Credits", Random(0, RankLevel + 1));
						PowerupChance *= 2;
					}
					if (YellowAuraLevel >= 5)
					{
						if (Random(1, 350) < 35)
							GiveInventory("Credits", Random(0, RankLevel + 1));
						RuneChance *= 2;
					}
					if (YellowAuraLevel >= 6)
					{
						if (Random(1, 350) < 35)
							GiveInventory("Credits", Random(0, RankLevel + 1));
						TokenChance *= 2;
					}
					if (YellowAuraLevel >= 7)
					{
						if (Random(1, 350) < 35)
							GiveInventory("Credits", Random(0, RankLevel + 1));
						AugChance *= 2;
						ShieldChance *= 2;
					}
					break;
			}
		
		// Stupid hack so that the AuraTimer doesn't decrease when PowerTimeFreezer is active
		if (AuraTimer > 0 && CheckInventory("MenuFreezer") > 0)
			AuraTimer++;

		// Decrease timer this tic and calculate HUD timer amount
		AuraTimer--;
		AuraTimerHUD = AuraTimer / 35 + 1;
	}
	
	// Force Wall Handling
	if (GetActorProperty(1998, APROP_ALPHA) > 0)
	{
		int WallAngle = GetActorAngle(0);
		int WallX = GetActorX(0) + cos(WallAngle) * 96;
		int WallY = GetActorY(0) + sin(WallAngle) * 96;
		int WallZ = GetActorZ(0);
		
		SetActorPosition(1998, WallX, WallY, WallZ, false);
		SetActorAngle(1998, WallAngle);
	}
	
	// Bullet-Time timer handling
	if (BulletTimeTimer >= 0)
	{
		/* Sigh, this is broken because SOMEBODY decided sounds shouldn't play
		   when PowerTimeFreezer is active -_-
		if (BulletTimeTimer % 100)
			ActivatorSound("skills/bullettime", 127);
		*/
		
		if (BulletTimeTimer % 3)
			GiveInventory("TimeFreezerQuick", 1);
		
		BulletTimeTimer--;
	}
}

// Used from DECORATE to get dynamic projectile damage rates
script "SetProjectileDamage" (int Type)
{
	switch (Type)
	{
		case 1: SetResultValue(Round(Energy * 0.25));	break;	// Fire
		case 2: SetResultValue(Round(Energy * 0.3));	break;	// Ice
	}
}

// Updates Skills with dynamic descriptions (calculations, etc)
function void CheckSkillDescriptions(void)
{
	int i;
	
	// Healing - Heal
	for (i = 1; i <= SkillLevelMax[0][0]; i++)
		SkillData[0][0][i] = StrParam(s:"Recover ", d:Energy * 10, s:" HP");

	// Healing - Repair Armor
	for (i = 1; i <= SkillLevelMax[0][1]; i++)
		SkillData[0][1][i] = StrParam(s:"Repair ", d:Energy * 10, s:" Armor");
	
	// Attacks - Fireball
	for (i = 1; i <= SkillLevelMax[3][0]; i++)
		SkillData[3][0][i] = StrParam(s:"Shoots a fireball\n\ca", d:Round(Energy * 0.25), s:" Fire Damage");

	// Attacks - Fireball Nova
	for (i = 1; i <= SkillLevelMax[3][1]; i++)
		SkillData[3][1][i] = StrParam(s:"Shoots fireballs in a circular nova around you\n\ca", d:Round(Energy * 0.25), s:" Fire Damage");

	// Attacks - Ice Missile
	for (i = 1; i <= SkillLevelMax[3][2]; i++)
		SkillData[3][2][i] = StrParam(s:"Shoots an Ice Missile\n\cn", d:Round(Energy * 0.3), s:" Ice Damage\n");
	
	// Attacks - Ice Nova
	for (i = 1; i <= SkillLevelMax[3][3]; i++)
		SkillData[3][3][i] = StrParam(s:"Shoots ice missiles in a circular nova around you\n\cn", d:Round(Energy * 0.3), s:" Ice Damage\n");
}
