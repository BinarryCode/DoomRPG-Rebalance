#include "Globals.dh"
#include "ItemData.dh"
#include "Map.dh"
#include "RPG.dh"
#include "Shield.dh"
#include "Shop.dh"
#include "Stats.dh"
#include "Skills.dh"
#include "Utils.dh"

// Stat Caps
int SoftStatCap = 100;
int HardStatCap = 1000;

// XP & Rank Tables
int[MAX_LEVEL] XPTable;
int[MAX_RANK] RankTable;

// Rank strings
str[25] Ranks =
{
	"None";
	"Pvt"; "Pvt +";
	"PFC"; "PFC +";
	"LCpl"; "LCpl +";
	"Cpl"; "Cpl +";
	"Sgt"; "Sgt +";
	"SSgt"; "SSgt +";
	"GySgt"; "GySgt +";
	"MSgt"; "MSgt +";
	"1stSgt"; "1stSgt +";
	"MGySgt"; "MGySgt +";
	"SgtMaj"; "SgtMaj +";
	"SgtMajMarCor"; "MSgtMarCor";
};

str[25] LongRanks =
{
	"None";
	"Private"; "Private +";
	"Private First Class"; "Private First Class +";
	"Lance Corporal"; "Lance Corporal +";
	"Corporal"; "Corporal +";
	"Sergeant"; "Sergeant +";
	"Staff Sergeant"; "Staff Sergeant +";
	"Gunnery Sergeant"; "Gunnery Sergeant +";
	"Master Sergeant"; "Master Sergeant +";
	"First Sergeant"; "First Sergeant +";
	"Master Gunnery Sergeant"; "Master Gunnery Sergeant +";
	"Sergeant Major"; "Sergeant Major +";
	"Sergeant Major of the Marine Corps"; "Master Sergeant Major of the Marine Corps";
};

// Add XP
acscript AddXP(int PlayerNum, int XP, int Rank, bool Reduced)
{
	// Scale XP/Rank Gains using the XP Scaling Option
	switch (GetCVar("drpg_scalexp"))
	{
		case 2: XP *= 2;				break;	// 2x
		case 3: XP *= 4;				break;	// 4x
		case 4: XP *= 8;				break;	// 8x
		case 5: XP = XP * 3 / 4;	    break;	// 0.75x
		case 6: XP /= 2;				break;	// 0.5x
		case 7: XP /= 4;				break;	// 0.25x
	};
	
	if (GetCVar("drpg_combo"))
	{
		Players(PlayerNum).ComboTimer = COMBO_MAX;
		Players(PlayerNum).Combo++;
		
		if (Reduced)
		{
			if (XP > 0)
				Players(PlayerNum).XPGained += XP / 3;
		}
		else
		{
			if (XP > 0)
				Players(PlayerNum).XPGained += XP;
			Players(PlayerNum).RankGained += Rank;
		};
		
		if (Players(PlayerNum).Aura == 3)
		{
			if (Players(PlayerNum).AuraTimer > 0)
				Players(PlayerNum).Combo++;
			if (Skills[2][2].CurrentLevel >= 3 && XP > 0 && Rank > 0)
				Players(PlayerNum).BonusGained += XP + Rank;
		};
	}
	else
	{
		if (Reduced)
		{
			if (XP > 0)
				Players(PlayerNum).XP += XP / 3;
			Players(PlayerNum).Rank += Rank / 3;
		}
		else
		{
			if (XP > 0)
				Players(PlayerNum).XP += XP;
			Players(PlayerNum).Rank += Rank;
		};
	};
};

function void InitTables()
{
    // XP
    for (int i = 0; i < MAX_LEVEL; i++)
        XPTable[i] = ((XPTable[i - 1] / 2000) + 1) * (200 + XPCurve) + XPTable[i - 1];
    
    // Rank
    for (int i = 0; i < MAX_RANK; i++)
        RankTable[i] = ((RankTable[i - 1] / 20000) + 1) * (7500 + (XPCurve * 50)) + RankTable[i - 1];
};

function void CheckCombo()
{
	if (GetCVar("drpg_combo"))
	{
		// Time Freeze special handling
		if (Player.Combo > 0 && CheckInventory("PowerTimeFreezer") && Player.ComboTimer >= COMBO_MAX)
			Player.ComboTimer = COMBO_MAX - 1;
        
		// Subtract the combo timer each tic
		if ((Player.Combo > 0 || Player.ComboTimer < COMBO_MAX) && !CheckInventory("PowerTimeFreezer") && !CheckInventory("MenuFreezer"))
			Player.ComboTimer--;
		
		// Reset values if you start the combo again while it was cooling down
		if (Player.ComboTimer == COMBO_MAX)
		{
			Player.BonusGained = 0;
			Player.XPGained = 0;
			Player.RankGained = 0;
		};
		
		// Add up and randomize the XP and Rank gain
		if (Player.ComboTimer == COMBO_STOP)
		{
			int ComboBonus = (int)((((fixed)Player.Combo / (fixed)GameSkill()) * (Player.XPGained + Player.RankGained)) / 10.0);
			if (ComboBonus < 0) ComboBonus = 0;
			
			// You cannot gain Negative XP, but you can lose Rank
			if (Player.XPGained < 0) Player.XPGained = 0;
			
			if (Player.Combo > 1)
			{
				Player.BonusGained += ComboBonus;
				Player.XP += Player.XPGained + ComboBonus;
				Player.Rank += Player.RankGained + ComboBonus;
			}
			else
			{
				Player.XP += Player.XPGained;
				Player.Rank += Player.RankGained;
			};
			
			Player.XPGained = 0;
			Player.RankGained = 0;
		};
		
		if (Player.ComboTimer < 0)
		{
			Player.Combo = 0;
			Player.ComboTimer = COMBO_MAX;
			Player.BonusGained = 0;
			Player.XPGained = 0;
			Player.RankGained = 0;
		};
	}
	else
		Player.ComboTimer = 0;
};

// Keeps current level and XP updated
function void CheckLevel()
{
	if (Player.Level < MAX_LEVEL)
		Player.XPNext = XPTable[Player.Level];
	
	if (Player.Level >= MAX_LEVEL)
	{
		Player.XP = XPTable[MAX_LEVEL - 1];
		Player.XPNext = XPTable[MAX_LEVEL - 1];
	};
	
	// Now check for a level up
	if (Player.XP >= XPTable[Player.Level] && Player.Level < MAX_LEVEL)
	{
		int StatTokens;
		int SkillTokens;
		
		if (GetCVar("drpg_levelup_type") == 0) // Skill-level
		{
			StatTokens = (6 - GameSkill()) + (Player.Level / 10);
			SkillTokens = (Player.Level % GameSkill()) == 1;
			
			// If you're on Armegeddon (DRLA), Only get one Stat Token per level
			if (GameSkill() == 6) StatTokens = 1;
			
			// If you're on easy, just give one Skill Token per level
			if (GameSkill() == 1) SkillTokens = 1;
		};
		if (GetCVar("drpg_levelup_type") == 1) // Static
		{
			StatTokens = 5 + (Player.Level / 10);
			SkillTokens = 1;
		};
		
		// Level Up
		ActivatorSound("misc/levelup", 96);
		
		Player.Level++;
		
		GiveInventory("StatToken", StatTokens);
		GiveInventory("SkillToken", SkillTokens);
		
		if (GetCVar("drpg_levelup_heal"))
		{
			if (Player.EP < 0) Player.EP = 0 else Player.EP = Player.EPMax;
			HealThing(1000000);
		};
		
		FadeRange(255, 255, 255, 0.5, 255, 255, 255, 0, 2.0);
		SetFont("BIGFONT");
		SetHudSize(0, 0, false);
		HudMessage("You have reached level %d\n", Player.Level,
					HUDMSG_FADEOUT | HUDMSG_LOG, MENU_ID, CR_WHITE, 0.5, 0.4, 2.0, 2.0);
        
        SpawnForced("LevelUpArrow", GetActorX(0), GetActorY(0), GetActorZ(0) + GetActorPropertyFixed(Player.TID, APROP_Height), 0, 0);
	};
};

// Keeps current Rank updated
function void CheckRank()
{
	Player.RankString = Ranks[Player.RankLevel];
	
	if (Player.RankLevel < MAX_RANK)
		Player.RankNext = RankTable[Player.RankLevel];
	
	if (Player.RankLevel >= MAX_RANK)
	{
		Player.Rank = RankTable[MAX_RANK - 1];
		Player.RankNext = RankTable[MAX_RANK - 1];
	};
	
	// Rank Demotion
	if (Player.RankLevel > 0 && Player.Rank < RankTable[Player.RankLevel - 1])
	{
		Player.RankLevel--;
		FadeRange(255, 0, 64, 0.25, 255, 0, 64, 0, 2.0);
		
		SetFont("BIGFONT");
		SetHudSize(0, 0, false);
		HudMessage("You have been demoted to rank %d: %s\n",
				   Player.RankLevel, LongRanks[Player.RankLevel],
				   HUDMSG_FADEOUT | HUDMSG_LOG, MENU_ID + 1, CR_BRICK, 1.5, 0.5, 4.0, 2.0);
	};
	
	// Rank Promotion
	if (Player.Rank >= RankTable[Player.RankLevel] && Player.RankLevel < MAX_RANK)
	{
		int NewItems;
		
		Player.RankLevel++;

		ActivatorSound("misc/rankup", 96);
		FadeRange(255, 255, 0, 0.5, 255, 255, 0, 0, 2.0);
		
		// Determine how many new items you've unlocked in the shop
		BuildItemData();
		for (int i = 0; i < ItemCategories; i++)
			for (int j = 0; j < ItemMax[i]; j++)
				if (ItemData[i][j].Rank == Player.RankLevel)
					NewItems++;
		
		SetFont("BIGFONT");
		SetHudSize(0, 0, false);
		HudMessage("You have been promoted to rank %d: %s\n",
				   Player.RankLevel, LongRanks[Player.RankLevel],
				   HUDMSG_FADEOUT | HUDMSG_LOG, MENU_ID + 1, CR_GOLD, 1.5, 0.5, 4.0, 2.0);
        
        SpawnForced("RankUpArrow", GetActorX(0), GetActorY(0), GetActorZ(0) + GetActorPropertyFixed(Player.TID, APROP_Height), 0, 0);
		
		// Tells you if you've unlocked new items in the Shop
		if (NewItems > 0)
		{
			SetFont("SMALLFONT");
			HudMessage("You have unlocked %d new items in the shop\n", NewItems, HUDMSG_FADEOUT | HUDMSG_LOG, MENU_ID + 2, CR_GOLD, 0.5, 0.6, 4.0, 2.0);
		};
	};
	
	// Payment
    if (!CheckInventory("PowerTimeFreezer") && !CheckInventory("MenuFreezer"))
        Player.PayTimer--;
	if (Player.PayTimer <= 0)
	{
		if (Player.RankLevel > 0)
		{
			int Pay = CalculatePay();
			
			GiveInventory("Credits", Pay);
			
			FadeRange(0, 255, 0, 0.1, 0, 255, 0, 0, 2.0);
			DrawPay(Pay);
			ActivatorSound("credits/payout", 127);
			if (InMultiplayer && Arbitrator && PlayerCount() > 1)
				Log("\cfYour group has been paid by the UAC\n")
			else if (!InMultiplayer)
				Log("\cfYou have been paid %d Credits by the UAC\n", Pay);
		};
		
		Player.PayTimer = 35 * 60 * GetCVar("drpg_pay_interval");
		Player.PayKills = 0;
		Player.PayBonus++;
	};
};

// Gives rewards for finding a secret and 100% Kills/Items/Secrets
function void CheckLevelInfo()
{
	int LevelNumber = GetLevelInfo(LEVELINFO_LEVELNUM);
	int CurrentKills = GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
	int CurrentItems = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
	int CurrentSecretsFound = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
	
	int XPBonus;
	int RankBonus;
	
	// Skip these checks if we're in the Outpost
	if (GetLevelInfo(LEVELINFO_LEVELNUM) == 999) return;
	
	// Set HUD Size and Font
	SetHudSize(0, 0, false);
	SetFont("SMALLFONT");
	
	// Check to see if any total stats are 0, if they are, silently flag them as received already
	if (GetLevelInfo(LEVELINFO_TOTAL_MONSTERS) == 0)
		LevelBonus[LevelNumber].KillBonus = true;
	if (GetLevelInfo(LEVELINFO_TOTAL_ITEMS) == 0)
		LevelBonus[LevelNumber].ItemsBonus = true;
	if (GetLevelInfo(LEVELINFO_TOTAL_SECRETS) == 0)
		LevelBonus[LevelNumber].SecretsBonus = true;
	
	// If all the total stats are 0, no bonuses at all
	if (GetLevelInfo(LEVELINFO_TOTAL_MONSTERS) == 0 && GetLevelInfo(LEVELINFO_TOTAL_ITEMS) == 0 && GetLevelInfo(LEVELINFO_TOTAL_SECRETS) == 0)
		LevelBonus[LevelNumber].AllBonus = true;
	
	// 100% Kills
	if (CurrentKills >= GetLevelInfo(LEVELINFO_TOTAL_MONSTERS) && !LevelBonus[LevelNumber].KillBonus)
	{
		FadeRange(255, 0, 0, 0.25, 255, 0, 0, 0, 1.0);
		
		XPBonus = XPTable[Player.Level] / 10;
		Player.XP += XPBonus;
		
		HudMessageBold("100%% Monsters Killed!\n%d XP Bonus\n", XPBonus,
					   HUDMSG_FADEOUT, 0, CR_BRICK, 1.5, 0.4, 3.0, 3.0);
		
		LevelBonus[LevelNumber].KillBonus = true;
	};
	
	// 100% Items
	if (CurrentItems >= GetLevelInfo(LEVELINFO_TOTAL_ITEMS) && !LevelBonus[LevelNumber].ItemsBonus)
	{
		FadeRange(0, 255, 255, 0.25, 0, 255, 255, 0, 1.0);
		
		Player.EP = Player.EPMax;
		HealThing(1000000);
		
		HudMessageBold("100%% Items Found!\nFull HP/EP Restore\n",
					   HUDMSG_FADEOUT, 0, CR_LIGHTBLUE, 1.5, 0.6, 3.0, 3.0);
		
		LevelBonus[LevelNumber].ItemsBonus = true;
	};

	// Secrets
	if (CurrentSecretsFound == SecretsFound + 1)
	{
		FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0, 1.0);
		
		RankBonus = RankTable[Player.RankLevel] / 100;
		Player.Rank += RankBonus;
		
		// 100% Secrets
		if (CurrentSecretsFound >= GetLevelInfo(LEVELINFO_TOTAL_SECRETS) && !LevelBonus[LevelNumber].SecretsBonus)
		{
			FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0, 1.0);
			
			RankBonus = RankTable[Player.RankLevel] / 20;
			Player.Rank += RankBonus;

			HudMessageBold("100%% Secrets Found!\n%d Rank Bonus\n", RankBonus,
						   HUDMSG_FADEOUT, 0, CR_YELLOW, 1.5, 0.8, 3.0, 3.0);
			
			LevelBonus[LevelNumber].SecretsBonus = true;
		};
	};
	
	// All Kills/Items/Secrets 100%
	if ((LevelBonus[LevelNumber].KillBonus && LevelBonus[LevelNumber].ItemsBonus && LevelBonus[LevelNumber].SecretsBonus) && !LevelBonus[LevelNumber].AllBonus)
	{
		FadeRange(255, 255, 255, 0.25, 255, 255, 255, 0, 1.0);
		
		XPBonus = XPTable[Player.Level] / 10;
		RankBonus = RankTable[Player.RankLevel] / 20;
		
		Player.XP += XPBonus;
		Player.Rank += RankBonus;
		
		Player.EP = Player.EPMax;
		HealThing(1000000);
		
		HudMessageBold("\ca100%% Monsters killed!\n\cn100%% Items Found!\n\ck100%% Secrets Found!\n\n\cj%d XP Bonus\n\ck%d Rank Bonus\n\cnFull HP/EP Restore\n",
					   XPBonus, RankBonus,
					   HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.2, 5.0, 5.0);
		
		LevelBonus[LevelNumber].AllBonus = true;
		
		// Payout Bonus Increase
		for (int i = 0; i < MAX_PLAYERS; i++)
			Players(i).PayBonus++;
	};
	
	Kills = CurrentKills;
	Items = CurrentItems;
	SecretsFound = CurrentSecretsFound;
};

function void CheckHealth()
{
	if (Player.LowHealthTimer >= 100 && GetActorProperty(Player.TID, APROP_Health) > 0)
	{
		ActivatorSound("health/low", 64);
		Player.LowHealthTimer = 0;
	};
	
	// Strength, Defense and Vitality Perks
	if (GetActorProperty(Player.TID, APROP_Health) <= GetActorProperty(Player.TID, APROP_SpawnHealth) / 10)
	{
		if (Player.Perks[STAT_STRENGTH])
			Player.TotalDamage *= 2;
		if (Player.Perks[STAT_DEFENSE])
			Player.DamageFactor /= 2;
		if (Player.Perks[STAT_VITALITY])
			Player.HPTime /= 2;
	};
	
	if (GetActorProperty(Player.TID, APROP_Health) <= GetActorProperty(Player.TID, APROP_SpawnHealth) / 10 && GetActorProperty(Player.TID, APROP_Health) > 0 && !Player.Perks[STAT_VITALITY])
	{
		FadeRange(Player.LowHealthTimer + 155, 0, 0, 0.25, Player.LowHealthTimer + 155, 0, 0, 0.0, 1.0);
		Player.LowHealthTimer++;
		
		// Halve Movement Speed and Jump Height
		Player.Speed /= 2;
		Player.JumpHeight /= 2;
	};
};

function void CheckArmorMax()
{
	int PlayerNum = PlayerNumber();
	
	if (!GetArmorType("none", PlayerNum)) 					Player.ArmorMax = 0;
	if (GetArmorType("ArmorBonus", PlayerNum) > 0) 			Player.ArmorMax = 100;
	if (GetArmorType("UsedGreenArmor", PlayerNum) > 0) 		Player.ArmorMax = 50;
	if (GetArmorType("GreenArmor", PlayerNum) > 0) 			Player.ArmorMax = 100;
	if (GetArmorType("UsedBlueArmor", PlayerNum) > 0) 		Player.ArmorMax = 50;
	if (GetArmorType("BlueArmor", PlayerNum) > 0) 			Player.ArmorMax = 100;
	if (GetArmorType("UsedYellowArmor", PlayerNum) > 0) 	Player.ArmorMax = 100;
	if (GetArmorType("YellowArmor", PlayerNum) > 0) 		Player.ArmorMax = 200;
	if (GetArmorType("UsedRedArmor", PlayerNum) > 0) 		Player.ArmorMax = 100;
	if (GetArmorType("RedArmor", PlayerNum) > 0) 			Player.ArmorMax = 200;
	if (GetArmorType("UsedWhiteArmor", PlayerNum) > 0) 		Player.ArmorMax = 100;
	if (GetArmorType("WhiteArmor", PlayerNum) > 0) 			Player.ArmorMax = 200;
	
	// DoomRL Compatibility
	if (GetCVar("drpg_ext_doomrl"))
	{
		if (CheckInventory("RL100ArmorWorn"))				Player.ArmorMax = 100;
		if (CheckInventory("RL150ArmorWorn"))				Player.ArmorMax = 150;
		if (CheckInventory("RL200ArmorWorn"))				Player.ArmorMax = 200;
		if (CheckInventory("RL100RegenArmorWorn"))			Player.ArmorMax = 100;
		
		// Nano Ablative Armor is special and shit
		if (CheckInventory("RLNanoAblativeArmorToken"))		Player.ArmorMax = 200;
	};
};

function void CheckStats()
{
	// VERY IMPORTANT CODE RIGHT HERE
	// If you're reading this and you'd like to modify stat curves, this is where you'd do it
	Player.LevelDamage = Player.Level * (10 - GameSkill());
	Player.BonusDamage = Player.Strength;
	Player.TotalDamage = Player.LevelDamage + Player.BonusDamage;
	Player.DamageFactor = 1.0 - 0.25 * ((fixed)Player.Defense / 100);
	Player.Mass = 100 + (Player.Defense * 10);
	Player.HealthMax = Player.Vitality * 10;
	Player.EPMax = Player.Energy * 10;
	Player.ToxicityRegenBonus = Player.Regeneration / 10;
	Player.Speed = 1.0 + 0.25 * ((fixed)Player.Agility / 100);
	Player.JumpHeight = 8.0 + (8.0 * ((fixed)Player.Agility / 100));
	Player.WeaponSpeed = Player.Agility;
	SetAmmoCapacity("Clip", Player.Capacity * 20);
	SetAmmoCapacity("Shell", Player.Capacity * 5);
	SetAmmoCapacity("RocketAmmo", Player.Capacity * 5);
	SetAmmoCapacity("Cell", Player.Capacity * 30);
	Player.Stim.VialMax = Player.Capacity * 10;
	Player.SurvivalBonus = (fixed)Player.Agility / 10.0;
};

function void CheckStatBonus()
{
	Player.Strength += Player.StrengthBonus;
	Player.Defense += Player.DefenseBonus;
	Player.Vitality += Player.VitalityBonus;
	Player.Energy += Player.EnergyBonus;
	Player.Regeneration += Player.RegenerationBonus;
	Player.Agility += Player.AgilityBonus;
	Player.Capacity += Player.CapacityBonus;
	Player.Luck += Player.LuckBonus;
	
	Player.StrengthBonus = 0;
	Player.DefenseBonus = 0;
	Player.VitalityBonus = 0;
	Player.EnergyBonus = 0;
	Player.RegenerationBonus = 0;
	Player.AgilityBonus = 0;
	Player.CapacityBonus = 0;
	Player.LuckBonus = 0;
};

function void CheckRegen()
{
	// Determine the max timer amounts
	Player.HPTime = (350 - (Player.Regeneration * 1.575)) * 2;
	Player.EPTime = (350 - (Player.Regeneration * 1.575)) * 2;
	
	// Determine the max regen amounts
	Player.HPAmount = 1 + Player.Vitality / 50;
	Player.EPAmount = 1 + Player.Energy / 50;
};

// Regeneration
function void DoRegen()
{
	int HPAmount = 1;
	int EPAmount = 1;
	
	// HP Regen
	if (Player.HPRate >= Player.HPTime && GetActorProperty(Player.TID, APROP_Health) >= 0)
	{
		HealThing(Player.HPAmount);
		Player.HPRate = 0;
	};
	
	// EP Regen
	if (Player.EPRate >= Player.EPTime && Player.EP < Player.EPMax)
	{
		Player.EP += Player.EPAmount;
		if (Player.EP > Player.EPMax)
			Player.EP = Player.EPMax;
		Player.EPRate = 0;
	};
	
	// If damaged, reset the Healing timer
	if (Player.HealthLoss != 0)
		Player.HPRate = 0;
	
	// Now increment the timers
	if (!CheckInventory("MenuFreezer"))
	{
		int Buttons = GetPlayerInput(PlayerNumber(), MODINPUT_BUTTONS);
		
		// Regen Boost
		if (Player.RegenBoostTimer > 0)
		{
			fixed X = GetActorX(0);
			fixed Y = GetActorY(0);
			fixed Z = GetActorZ(0);
			int Angle = GetActorAngle(0) * 256;
			SpawnForced("RegenSphereEffect", X, Y, Z + 32.0, AuraTID, Angle);
			
			Player.HPRate += Player.RegenBoostTimer / (GameSkill() * GameSkill());
			Player.EPRate += Player.RegenBoostTimer / (GameSkill() * GameSkill());
			Player.RegenBoostTimer--;
			FadeRange(255, 0, 128, 0.1, 255, 0, 128, 0.0, 1.0);
			
			// Pass Radius and Height to the Auras for DECORATE usage
			SetUserVariable(AuraTID, "user_radius", (int)GetActorPropertyFixed(Player.TID, APROP_Radius));
			SetUserVariable(AuraTID, "user_height", (int)GetActorPropertyFixed(Player.TID, APROP_Height));
			Thing_ChangeTID(AuraTID, 0);
		};
		
		// Regeneration Perk
		if (Player.Perks[STAT_REGENERATION])
		{
			// Health
			HPAmount = 1 + (GetActorProperty(Player.TID, APROP_SpawnHealth) / GetActorProperty(Player.TID, APROP_Health));
			
			// EP
			int EP = Player.EP;
			if (EP == 0) EP = 1;
			EPAmount = Abs(1 + (Player.EPMax / EP));
		};
		
		// Movement/Crouching/Idling mechanics
		if (GetCVar("drpg_regen_movement"))
		{
			if (GetPlayerInput(PlayerNumber(), MODINPUT_FORWARDMOVE) || // Movement - 50% Regen Rate
				GetPlayerInput(PlayerNumber(), MODINPUT_SIDEMOVE) ||
				GetPlayerInput(PlayerNumber(), MODINPUT_UPMOVE))
			{
				Player.HPRate += HPAmount;
				Player.EPRate += EPAmount;
			}
			else if (Buttons & BT_CROUCH) // Crouch - 150% Regen Rate
			{
				Player.HPRate += HPAmount + 3;
				Player.EPRate += EPAmount + 3;
			}
			else // Idle - 100% Regen Rate
			{
				Player.HPRate += HPAmount + 2;
				Player.EPRate += EPAmount + 2;
			};
		}
		else
		{
				Player.HPRate += HPAmount;
				Player.EPRate += EPAmount;
		};
	};
};

// Keep stats capped at certain values
function void CheckStatCaps()
{
	Player.StatCap = SoftStatCap + CheckInventory("StatCapToken");

	if (Player.Strength > Player.StatCap)		Player.Strength = Player.StatCap;
	if (Player.Defense > Player.StatCap)		Player.Defense = Player.StatCap;
	if (Player.Vitality > Player.StatCap)		Player.Vitality = Player.StatCap;
	if (Player.Energy > Player.StatCap)			Player.Energy = Player.StatCap;
	if (Player.Regeneration > Player.StatCap)	Player.Regeneration = Player.StatCap;
	if (Player.Agility > Player.StatCap)		Player.Agility = Player.StatCap;
	if (Player.Capacity > Player.StatCap)		Player.Capacity = Player.StatCap;
	if (Player.Luck > Player.StatCap)			Player.Luck = Player.StatCap;
};

// Keep stats capped at the hard value
function void CheckHardStatCaps()
{
	if (Player.Strength > HardStatCap)		Player.Strength = HardStatCap;
	if (Player.Defense > HardStatCap)		Player.Defense = HardStatCap;
	if (Player.Vitality > HardStatCap)		Player.Vitality = HardStatCap;
	if (Player.Energy > HardStatCap)		Player.Energy = HardStatCap;
	if (Player.Regeneration > HardStatCap)	Player.Regeneration = HardStatCap;
	if (Player.Agility > HardStatCap)		Player.Agility = HardStatCap;
	if (Player.Capacity > HardStatCap)		Player.Capacity = HardStatCap;
	if (Player.Luck > HardStatCap)			Player.Luck = HardStatCap;
};

function void CheckStatBounds()
{
	/* Prevent Overflow of EP - I'd rather we not do this, just for things like Stims
	if (Player.EP > Player.EPMax)
		Player.EP = Player.EPMax; */
	
	// Cap Defense/DamageFactor
	if (Player.DamageFactor < 0.01)
		Player.DamageFactor = 0.01;
	
	// Cap the max regen timer amounts to 1 second
	if (Player.HPTime < 35)
		Player.HPTime = 35;
	if (Player.EPTime < 35)
		Player.EPTime = 35;
	
	// Cap Toxicity Regen Bonus
	if (Player.ToxicityRegenBonus > 20)
		Player.ToxicityRegenBonus = 20;
	
	// Prevent Underflow of DamageFactor
	if (Player.DamageFactor < 0.01)
		Player.DamageFactor = 0.01;
	
	// Prevent Shield Capacity from under/overflowing
	if (Player.Shield.Charge < 0)
		Player.Shield.Charge = 0;
	if (Player.Shield.Charge > Player.Shield.Capacity)
		Player.Shield.Charge = Player.Shield.Capacity;
	
	// Cap Weapon Speed
	if (Player.WeaponSpeed > 100)
		Player.WeaponSpeed = 100;
	
	// Cap Survival Bonus
	if (Player.SurvivalBonus > 75)
		Player.SurvivalBonus = 75;
	
	// Cap chances at 100%
	if (Player.CreditChance > 100) 	Player.CreditChance = 100;
	if (Player.HealthChance > 100) 	Player.HealthChance = 100;
	if (Player.EPChance > 100) 		Player.EPChance = 100;
	if (Player.ArmorChance > 100) 	Player.ArmorChance = 100;
	if (Player.PowerupChance > 100) Player.PowerupChance = 100;
	if (Player.WeaponChance > 100) 	Player.WeaponChance = 100;
	if (Player.TokenChance > 100) 	Player.TokenChance = 100;
	if (Player.AugChance > 100) 	Player.AugChance = 100;
	if (Player.ShieldChance > 100) 	Player.ShieldChance = 100;

	// Speed capping CVAR
	if (Player.Speed > GetCVarFixed("drpg_maxspeed"))
		Player.Speed = GetCVarFixed("drpg_maxspeed");
		
	// Jump Height capping CVAR
	if (Player.JumpHeight > GetCVarFixed("drpg_maxjump"))
		Player.JumpHeight = GetCVarFixed("drpg_maxjump");
};

// Luck Chances
function void CheckLuck()
{
	Player.CreditChance = 10 + Player.Luck * 0.9;
	Player.HealthChance = Player.Luck * 0.025;
	Player.EPChance = Player.Luck * 0.025;
	Player.ArmorChance = Player.Luck * 0.025;
	Player.PowerupChance = Player.Luck * 0.0125;
	Player.WeaponChance = Player.Luck * 0.0125;
	Player.TokenChance = Player.Luck * 0.01;
	Player.AugChance = Player.Luck * 0.0025;
	Player.ShieldChance = Player.Luck * 0.005;
	Player.StimChance = Player.Luck * 0.0125;
};

function void CheckBurnout()
{
	// Energy Burnout Effect
	if (Player.EP < 0)
	{
		// Dynamic Intensity
		fixed Intensity = -((fixed)Player.EP / (fixed)Player.EPMax);
		if (Intensity > 0.75) Intensity = 0.75;
		
		// Screen Effect
		FadeRange(0, 128, 255, Intensity, 0, 128, 255, 0, 0.25);
		
		// Penalties
		Player.TotalDamage /= 2;
		Player.DamageFactor *= 2;
		Player.Mass /= 2;
		Player.HealthMax /= 2;
		Player.EPMax /= 2;
		Player.Speed /= 2;
		Player.JumpHeight /= 2;
		Player.SurvivalBonus /= 2;
		
		// Energy Perk
		if (Player.Perks[STAT_ENERGY])
			Player.EPTime /= 2;
	};
};

function void CheckPerks()
{
	if (Player.Strength >= 100) 	Player.Perks[STAT_STRENGTH] = true		else Player.Perks[STAT_STRENGTH] = false;
	if (Player.Defense >= 100) 		Player.Perks[STAT_DEFENSE] = true		else Player.Perks[STAT_DEFENSE] = false;
	if (Player.Vitality >= 100) 	Player.Perks[STAT_VITALITY] = true		else Player.Perks[STAT_VITALITY] = false;
	if (Player.Energy >= 100) 		Player.Perks[STAT_ENERGY] = true		else Player.Perks[STAT_ENERGY] = false;
	if (Player.Regeneration >= 100)	Player.Perks[STAT_REGENERATION] = true	else Player.Perks[STAT_REGENERATION] = false;
	if (Player.Agility >= 100) 		Player.Perks[STAT_AGILITY] = true		else Player.Perks[STAT_AGILITY] = false;
	if (Player.Capacity >= 100) 	Player.Perks[STAT_CAPACITY] = true		else Player.Perks[STAT_CAPACITY] = false;
	if (Player.Luck >= 100) 		Player.Perks[STAT_LUCK] = true			else Player.Perks[STAT_LUCK] = false;
	
	// Agility Perk
	if (Player.Perks[STAT_AGILITY])
		Player.SurvivalBonus += 30;
	
	// Capacity Perk
	if (Player.Perks[STAT_CAPACITY] && (Timer() % (35 * 30)) == 1)
	{
		GiveInventory("Clip", GetAmmoAmount("Clip"));
		GiveInventory("Shell", GetAmmoAmount("Shell"));
		GiveInventory("RocketAmmo", GetAmmoAmount("RocketAmmo"));
		GiveInventory("Cell", GetAmmoAmount("Cell"));
	};
	
	// Luck Perk
	// TODO: Ability to see secrets
	if (Player.Perks[STAT_LUCK])
	{
		GiveInventory("AllMapRevealer", 1);
		GiveInventory("AllMapScanner", 1);
	};
};

function void CheckToxicity()
{
	// Prevent Underflow
	if (Player.Toxicity < 0)
		Player.Toxicity = 0;
	
	// Check Damage Type for Toxicity
	if (Player.DamageType == DT_TOXIC && !CheckInventory("PowerIronFeet"))
		AddToxicity(Random(1, GameSkill()));
	
	// Slowly decrease Toxicity
	if (Player.Toxicity > 0 && Timer() % (35 * (30 - Player.ToxicityRegenBonus)) == 0)
    {
		Player.Toxicity--;
        Player.ToxicTimer = 0;
        Player.ToxicOffset = 0;
        Player.ToxicStage = 0;
    };
	
	// Toxicity Penalties
	if (GetCVar("drpg_toxicity_penalties"))
	{
		if (Player.Toxicity >= 25 && Timer() % 35 == 0 && Player.EP > 0)
		{
			Player.HPRate = 0;
			Player.EPRate = 0;
		};
		if (Player.Toxicity >= 50 && Timer() % 35 == 0)
			Player.EP--;
		if (Player.Toxicity >= 75)
		{
			Player.Speed /= 2;
			Player.JumpHeight /= 2;
		};
	};
	
	// Death at 100% Toxicity
	if (Player.Toxicity >= 100)
	{
		Thing_Damage2(Player.TID, 1000000000, "Toxicity");
        SetActorState(Player.TID, "Death.Toxicity");
		Player.Toxicity = 0;
	};
};
