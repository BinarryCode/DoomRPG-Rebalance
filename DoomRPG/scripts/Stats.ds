#include <zcommon.acs>

#include "Stats.dh"

// CVARS/options
int RandomizedStartTokens;

// Level & XP
int Level;
int XP;
int XPNext;

// Rank
str RankString;
int RankLevel;
int Rank;
int RankNext;
int PayTimer;

// HUD Stuff
int Credits;
int Continues;

// Combo System
int Combo;
int ComboTimer;
int TotalGained;
int XPGained;
int RankGained;
fixed XPMult;
fixed StyleMult;

// Primary Stats
int Strength;					// Increases Damage
int Defense9;					// Reduces Damage taken
int Vitality;					// Increases max Health and HP regen rate
int Energy;						// Increases max EP and EP regen rate
int Regeneration;				// Increases both HP/EP regen rate
int Agility;					// Increases movement speed and jump height (and optionally weapon speed)
int Capacity;					// Increases max ammo capacities
int Luck;						// Increases Survivability bonus and drop chances
int HealthMax;					// Max player Health
int ArmorMax;					// Max Armor that the player's current armor can go up to

// Secondary Stats
fixed Damage;					// The player's DamageFactor against monsters
fixed DamageFactor;				// General damage the player will defend against
fixed Speed;					// Movement Speed
fixed JumpHeight;				// Jump Height
int WeaponSpeed;				// Weapon Speed Increase bsed on Agility
int SurvivalBonus;				// Chance that you will survive a fatal hit

// Misc stat/token stuff
int StatTokens;					// Current Stat Tokens
int SkillTokens;				// Current Skill Tokens
int StatCap;					// Current Stat Cap
int SoftStatCap = 100;			// Soft Stat Cap, this cannot be passed with tokens
int HardStatCap = 1000;			// Hard Stat Cap, this cap cannot be passed period

// 100% Bonuses
int Kills;
int KillBonus;
int Items;
int ItemsBonus;
int SecretsFound;
int SecretsBonus;
int AllBonus;

// HP/EP Regen Timers
int HPRate;
int EPRate;
int LowHealthTimer;

// XP & Rank Tables
int[1001] XPTable;
int[25] RankTable;

// Luck Chance Percentages
int[7] MoneyChance;
int[4] HealthChance;
int[5] ArmorChance;
int PowerupChance;
int RuneChance;
int TokenChance;
int AccessoryChance;
int ShieldChance;
int EPChance;

// Rank strings
str[25] Ranks = {
	"None";
	"Pvt"; "Pvt +";
	"PFC"; "PFC +";
	"LCpl"; "LCpl +";
	"Cpl"; "Cpl +";
	"Sgt"; "Sgt +";
	"SSgt"; "SSgt +";
	"GySgt"; "GySgt +";
	"MSgt"; "MSgt +";
	"1stSgt"; "1stSgt +";
	"MGySgt"; "MGySgt +";
	"SgtMaj"; "SgtMaj +";
	"SgtMajMarCor"; "MSgtMarCor";
};

str[25] LongRanks = {
	"None";
	"Private"; "Private +";
	"Private First Class"; "Private First Class +";
	"Lance Corporal"; "Lance Corporal +";
	"Corporal"; "Corporal +";
	"Seargent"; "Seargent +";
	"Staff Seargent"; "Staff Seargent +";
	"Gunnery Seargent"; "Gunnery Seargent +";
	"Master Seargent"; "Master Seargent +";
	"First Seargent"; "First Seargent +";
	"Master Gunnery Seargent"; "Master Gunnery Seargent +";
	"Seargent Major"; "Seargent Major +";
	"Seargent Major of the Marine Corps"; "Master Seargent Major of the Marine Corps";
};

function void CheckCombo()
{
	if (GetCVar("drpg_combo"))
	{
		// Stupid hack so that the ComboTimer doesn't decrease when PowerTimeFreezer is active
		if ((ComboTimer > 0 || ComboTimer < 100) && CheckInventory("MenuFreezer") > 0)
			if (ComboTimer != 0)
				ComboTimer++;
		
		// Subtract the combo timer each tic
		if ((Combo > 0 || ComboTimer < 100) && !CheckInventory("PowerTimeFreezer"))
			ComboTimer--;
		
		// Set your Inventory Combo Item to the current ComboTimer aunt
		if (ComboTimer < 100)
		{
			TakeInventory("Combo", 100);
			TakeInventory("Combo2", 100);
			GiveInventory("Combo", ComboTimer);
		};
		if (ComboTimer < 0)
		{
			TakeInventory("Combo", 100);
			TakeInventory("Combo2", 100);
			GiveInventory("Combo2", ComboTimer + 100);
		};
		
		// Add up and randomize the XP and Rank gain
		if (ComboTimer == 0)
		{
			int BonusXP = MapNumber * 0.1 + 1;
			int BonusRank = MapNumber * 0.1 + 1;
			
			XPGained += TotalGained + Random(0, Combo + Combo * Level) * BonusXP * XPMult;
			RankGained += TotalGained + Random(0, Combo + Combo * RankLevel) * BonusRank * StyleMult;
			
			XP += XPGained;
			Rank += RankGained;
			
			TotalGained = 0;
			Combo = 0;
		};
		
		if (ComboTimer < -100)
		{
			TotalGained = 0;
			XPGained = 0;
			RankGained = 0;
			ComboTimer = 100;
		};
	}
	else ComboTimer = -100;
};

// Keeps current level and XP updated
function void CheckLevel()
{
	if (Level < 1000)
		XPNext = XPTable[Level];

	if (Level > 999)
	{
		XP = XPTable[Level - 1];
		XPNext = XPTable[Level - 1];
	};
	
	// Now check for a level up
	if (XP >= XPTable[Level] && Level < 1000)
	{
		// Level Up
		ActivatorSound("misc/levelup", 127);
		Level++;
		GiveInventory("StatToken", 10 - GameSkill());
		GiveInventory("SkillToken", 1);
		if (EP <= 0) EP = 0 else EP = ACS_NamedExecuteWithResult("GetEPMax", 0);
		HealThing(1000000);
		FadeRange(255, 255, 255, 0.75, 255, 255, 255, 0, 1.0);
		// Log(s:"You have reached level ", d:Level);
	};
};

// Keeps current Rank updated
function void CheckRank()
{
	str RankString = Ranks[RankLevel];
	
	if (RankLevel < 25)
		RankNext = RankTable[RankLevel];
	
	if (RankLevel >= 24)
	{
		Rank = RankTable[RankLevel];
		RankNext = RankTable[RankLevel];
	};
		
	if (Rank >= RankTable[RankLevel] && RankLevel < 24)
	{
		ActivatorSound("misc/rankup", 127);
		RankLevel++;
		FadeRange(255, 255, 0, 0.75, 255, 255, 0, 0, 1.0);
		// Log(s:"\ckYou have reached rank level ", d:RankLevel, s:": ", s:LongRanks[RankLevel]);
	};
	
	// Payment
	PayTimer++;
	if (PayTimer >= 35 * 60 * 5) // 5 Minutes
	{
		PayTimer = 0;
		
		if (RankLevel > 0)
		{
			GiveInventory("Credits", 100 * RankLevel + 100);
			
			FadeRange(0, 255, 0, 0.1, 0, 255, 0, 0, 2.0);
			ActivatorSound("credits/payout", 127);
			// Log(s:"\cfYou have been paid ", d:100 * RankLevel + 100, s:" Credits by the UAC");
		};
	};
};

// Gives rewards for finding a secret and 100% Kills/Items/Secrets
function void CheckLevelInfo()
{
	int CurrentKills = GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
	int CurrentItems = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
	int CurrentSecretsFound = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
	
	int XPBonus = Random(XPGained * 100, RankLevel * 100 + Random(0, 100));
	int RankBonus = RankLevel * 10000;
	
	// Set HUD Size and Font
	SetHudSize(0, 0, false);
	SetFont("SMALLFONT");
	
	// Check to see if any total stats are 0, if they are, silently flag them as recieved already
	if (GetLevelInfo(LEVELINFO_TOTAL_MONSTERS) == 0)
		KillBonus = true;
	if (GetLevelInfo(LEVELINFO_TOTAL_ITEMS) == 0)
		ItemsBonus = true;
	if (GetLevelInfo(LEVELINFO_TOTAL_SECRETS) == 0)
		SecretsBonus = true;
	
	// 100% Kills
	if (CurrentKills >= GetLevelInfo(LEVELINFO_TOTAL_MONSTERS) && !KillBonus)
	{
		FadeRange(255, 0, 0, 0.25, 255, 0, 0, 0, 1.0);
		XPBonus = Random(Level * 10, Level * 100);
		XPGained += XPBonus;
		ComboTimer = 100;
		if (GetCVar("drpg_combo")) Combo += GetLevelInfo(LEVELINFO_TOTAL_MONSTERS);
		HudMessage("100%% Monsters Killed!\n%d XP Bonus", XPBonus,
				   HUDMSG_TYPEON, 0, CR_BRICK, 1.5, 0.4, 3.0, 0.1, 3.0);
		KillBonus = true;
	};
	
	// 100% Items
	if (CurrentItems >= GetLevelInfo(LEVELINFO_TOTAL_ITEMS) && !ItemsBonus)
	{
		FadeRange(0, 255, 255, 0.25, 0, 255, 255, 0, 1.0);
		EP = ACS_NamedExecuteWithResult("GetEPMax", 0);
		ComboTimer = 100;
		if (GetCVar("drpg_combo")) Combo += GetLevelInfo(LEVELINFO_TOTAL_ITEMS);
		HealThing(1000000);
		HudMessage("100% Items Found!\nFull HP/EP Restore",
				   HUDMSG_TYPEON, 0, CR_LIGHTBLUE, 1.5, 0.6, 3.0, 0.1, 3.0);
		ItemsBonus = true;
	};

	// Secrets
	if (CurrentSecretsFound == SecretsFound + 1 && RankLevel < 25)
	{;
		FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0, 1.0);
		RankGained += Random(RankLevel * 1000, RankLevel * 1000 + Random(0, 1000));
		ComboTimer = 100;
		if (GetCVar("drpg_combo")) Combo++;
		
		// 100% Secrets
		if (CurrentSecretsFound >= GetLevelInfo(LEVELINFO_TOTAL_SECRETS) && !SecretsBonus)
		{
			FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0, 1.0);
			RankBonus = Random(RankLevel * 1000, RankLevel * 1000 + Random(0, 1000));
			Rank += RankBonus;
			ComboTimer += 100;
			if (GetCVar("drpg_combo")) Combo += GetLevelInfo(LEVELINFO_TOTAL_SECRETS);
			HudMessage("100%% Secrets Found!\n%d Rank Bonus", RankBonus,
					   HUDMSG_TYPEON, 0, CR_YELLOW, 1.5, 0.8, 3.0, 0.1, 3.0);
			SecretsBonus = true;
		};
	};
	
	// All Kills/Items/Secrets 100%
	if ((KillBonus && ItemsBonus && SecretsBonus) && !AllBonus)
	{
		FadeRange(255, 255, 255, 0.25, 255, 255, 255, 0, 1.0);
		XPBonus = Random(Level * 100, Level * 1000);
		RankBonus = Random(RankLevel * 1000, RankLevel * 1000 + Random(0, 1000));
		XPGained += XPBonus;
		RankGained += RankBonus;
		EP = ACS_NamedExecuteWithResult("GetEPMax", 0);
		ComboTimer = 100;
		if (GetCVar("drpg_combo")) Combo += GetLevelInfo(LEVELINFO_TOTAL_MONSTERS);
		if (GetCVar("drpg_combo")) Combo += GetLevelInfo(LEVELINFO_TOTAL_ITEMS);
		if (GetCVar("drpg_combo")) Combo += GetLevelInfo(LEVELINFO_TOTAL_SECRETS);
		HealThing(1000000);
		HudMessage("100%% Monsters killed!\n100%% Items Found!\n100%% Secrets Found!\n\n%d XP Bonus\n%d Rank Bonus\nFull HP/EP Restore",
				   XPBonus, RankBonus,
				   HUDMSG_TYPEON, 0, CR_WHITE, 0.5, 0.2, 3.0, 0.1, 3.0);
		AllBonus = true;
	};
	
	
	CurrentKills = Kills;
	CurrentItems = Items;
	SecretsFound = CurrentSecretsFound;
};

function void CheckHealth()
{
	if (LowHealthTimer >= 100 && CheckInventory("Health") > 0)
	{
		ActivatorSound("health/low", 64);
		LowHealthTimer = 0;
	};
	
	if (CheckInventory("Health") <= GetActorProperty(0, APROP_SpawnHealth) / 10 && CheckInventory("Health") > 0)
	{
		FadeRange(LowHealthTimer + 155, 0, 0, 0.25, LowHealthTimer + 155, 0, 0, 0.0, 1.0);
		LowHealthTimer++;
		
		// Halve Movement Speed and Jump Height
		Speed /= 2;
		JumpHeight /= 2;
		SetActorProperty(0, APROP_Speed, Speed);
		SetActorProperty(0, APROP_JumpZ, JumpHeight);
	};
};

function void CheckArmorMax()
{
	if (!GetArmorType("none", 0)) 				ArmorMax = 0;
	if (GetArmorType("ArmorBonus", 0) > 0) 		ArmorMax = 100;
	if (GetArmorType("UsedGreenArmor", 0) > 0) 	ArmorMax = 50;
	if (GetArmorType("GreenArmor", 0) > 0) 		ArmorMax = 100;
	if (GetArmorType("UsedBlueArmor", 0) > 0) 	ArmorMax = 125;
	if (GetArmorType("BlueArmor", 0) > 0) 		ArmorMax = 250;
	if (GetArmorType("UsedYellowArmor", 0) > 0) ArmorMax = 250;
	if (GetArmorType("YellowArmor", 0) > 0) 	ArmorMax = 500;
	if (GetArmorType("UsedRedArmor", 0) > 0) 	ArmorMax = 375;
	if (GetArmorType("RedArmor", 0) > 0) 		ArmorMax = 750;
	if (GetArmorType("UsedWhiteArmor", 0) > 0) 	ArmorMax = 500;
	if (GetArmorType("WhiteArmor", 0) > 0) 		ArmorMax = 1000;
};

// Keep stats capped at certain values
function void CapStats(int Cap)
{
	if (Strength < 0)			Strength = 0;
	if (Strength > Cap)			Strength = Cap;
	if (Defense < 0)			Defense = 0;
	if (Defense > Cap)			Defense = Cap;
	if (Vitality < 0)			Vitality = 0;
	if (Vitality > Cap)			Vitality = Cap;
	if (Energy < 0)				Energy = 0;
	if (Energy > Cap)			Energy = Cap;
	if (Regeneration < 0)		Regeneration = 0;
	if (Regeneration > Cap)		Regeneration = Cap;
	if (Agility < 0)			Agility = 0;
	if (Agility > Cap)			Agility = Cap;
	if (Capacity < 0)			Capacity = 0;
	if (Capacity > Cap)			Capacity = Cap;
	if (Luck < 0)				Luck = 0;
	if (Luck > Cap)				Luck = Cap;
};

function void CheckStats()
{
	// VERY IMPORTANT CODE RIGHT HERE
	// If you're reading this and you'd like to modify stat curves, this is where you'd do it
	Damage = Strength * 0.01;
	DamageFactor = (1.0 - 0.25) * Defense / 100;
	HealthMax = Vitality * 10;
	EPMax = Energy * 10;
	Speed = (1 + 0.25) * (Agility / 100);
	JumpHeight = 8.0 + Agility * 0.04;
	WeaponSpeed = Agility;
	SetAmmoCapacity("Clip", Capacity * 20);
	SetAmmoCapacity("Shell", Capacity * 10);
	SetAmmoCapacity("RocketAmmo", Capacity * 5);
	SetAmmoCapacity("Cell", Capacity * 30);
	SurvivalBonus = Luck;

	// Prevent Underflow of DamageFactor
	if (DamageFactor < 0.01)
		DamageFactor = 0.01;
	
	// Prevent stats from going overboard
	CapStats(HardStatCap);
	
	/* CHECK: Prevent Shield Capacity from under/overflowing
	if (Shield <= 0)
		Shield = 0;
	if (Shield > ShieldCapacity)
		Shield = ShieldCapacity;
	*/
	
	// Cap Weapon Speed
	if (WeaponSpeed > 100)
		WeaponSpeed = 100;
	
	// Keep misc counts handy for the SBARINFO HUD and such
	Credits = CheckInventory("Credits");
	Continues = CheckInventory("Continue");
	StatTokens = CheckInventory("StatToken");
	SkillTokens = CheckInventory("SkillToken");
	
	/* CHECK: Give the Strength boosting item
	if (Accessories[0] == 0 && Accessories[8] == 0)
		if (Round(Damage * 100) > 0 && Round(Damage * 100) <= 8000)
			GiveInventory(StrParam(s:"Strength", d:Round(Damage * 100)), 1);
	*/
	// Speed capping CVAR
	if (Speed >= GetCVar("drpg_maxspeed") * 100)
		Speed = GetCVar("drpg_maxspeed") * 100;
	
	// Now apply the Stats
	SetActorProperty(0, APROP_SpawnHealth, HealthMax);
	SetActorProperty(0, APROP_DamageFactor, DamageFactor);
	// SetActorProperty(0, APROP_Speed, Speed);
	// SetActorProperty(0, APROP_JumpZ, JumpHeight);
	
	// Survival Bonus
	if (Random(1, 1000) <= SurvivalBonus)
		SetPlayerProperty(0, 1, PROP_BUDDHA)
	else
		SetPlayerProperty(0, 0, PROP_BUDDHA);
	
	/* CHECK: Only randomize your starting tokens
	if (GetCVar("drpg_randomstatgrowth") == 1 && !RandomizedStartTokens)
	{
		if (StatTokens > 0)
			IncreaseStat(Random(0, 7));
		if (StatTokens == 0)
			RandomizedStartTokens = true;
	};
	// If we're playing with ramdom leveling, tokens should automatically be used
	if (GetCVar("drpg_randomstatgrowth") == 2)
		if (StatTokens > 0)
			IncreaseStat(Random(0, 7));
	// Autospend your tokens on level-up
	if (GetCVar("drpg_autospend"))
		if (StatTokens > 0)
			IncreaseStat(Random(0, 7));
	*/
};

// Keep the Stat Cap (SoftStatCap + Stat Cap Tokens) updated
function void CheckStatCap()
{
	StatCap = SoftStatCap + CheckInventory("StatCapToken");
};

// Regeneration
function void DoRegen()
{
	// HP Regen
	if (HPRate >= 3500 && CheckInventory("Health") >= 0)
	{
		HealThing(1);
		HPRate = 0;
	};

	// EP Regen
	if (EPRate >= 3500 && EP <= EPMax)
	{
		EP++;
		if (EP > EPMax)
			EP = EPMax;
		
		EPRate = 0;
	};
	
	/* CHECK: If damaged, reset the Healing timer
	if (HealthLoss != 0)
		HPRate = 0;
	*/
	
	// Now increment the timers
	if (!CheckInventory("MenuFreezer"))
	{
		HPRate += Vitality * 1.25 + Regeneration * 1.25;
		EPRate += Energy * 1.25 + Regeneration * 1.25;
	};
};

// Setup XP & Rank Tables
function void SetupTables()
{
	// XP Table
	for (int i = 0; i < 1000; i++)
		XPTable[i] = 1000 + (1000 * i * i);
	
	// Rank Table
	for (int j = 0; j < 25; j++)
		RankTable[j] = 100000 + (100000 * j * j);
};

// TODO: Recalculate stats after something (accessory, aura) has modified them
function void RecalculateStats()
{
	int HPRatio = (GetActorProperty(0, APROP_Health) * 100) / GetActorProperty(0, APROP_SpawnHealth);
	int CurrentHP = (HPRatio * GetActorProperty(0, APROP_SpawnHealth)) / 100;
	int EPRatio = (EP * 100) / EPMax;
	int CurrentEP = (EPRatio * EPMax) / 100;
	
	// SetActorProperty(0, APROP_HEALTH, CurrentHP);
	// EP = CurrentEP;
};

// Luck Chances
function void CheckLuck()
{
	// Credits
	MoneyChance[0] = Luck * 0.5;
	MoneyChance[1] = Luck * 0.25;
	MoneyChance[2] = Luck * 0.2;
	MoneyChance[3] = Luck * 0.15;
	MoneyChance[4] = Luck * 0.1;
	MoneyChance[5] = Luck * 0.05;
	MoneyChance[6] = Luck * 0.01;
	
	// Health
	HealthChance[0] = Luck * 0.1;
	HealthChance[1] = Luck * 0.025;
	HealthChance[2] = Luck * 0.01;
	
	// Armor
	ArmorChance[0] = Luck * 0.1;
	ArmorChance[1] = Luck * 0.075;
	ArmorChance[2] = Luck * 0.05;
	ArmorChance[3] = Luck * 0.025;
	ArmorChance[4] = Luck * 0.01;
	
	// Powerups
	PowerupChance = Luck * 0.05;
	
	// Runes
	RuneChance = Luck * 0.025;

	// Tokens
	TokenChance = Luck * 0.01;
	
	// Accessories
	AccessoryChance = Luck * 0.01;
	
	// Shield Parts
	ShieldChance = Luck * 0.01;

	// EP Capsules
	EPChance = Luck * 0.1;
};

function void CheckBurnout()
{
	// Energy Burnout Effect
	if (EP < 0)
	{
		// Dynamic Intensity
		int Intensity = EP * EPMax; // CHECK: Abs(EP * EPMax);
		if (Intensity > 0.75) Intensity = 0.75;
		
		// Screen Effect
		FadeRange(0, 128, 255, Intensity, 0, 128, 255, 0, 0.25);
		
		// Penalties
		Damage /= 2;
		DamageFactor /= 2;
		HealthMax /= 2;
		EPMax /= 2;
		Speed /= 2;
		JumpHeight /= 2;
		SurvivalBonus /= 2;

		// Now apply the Stats
		SetActorProperty(0, APROP_SpawnHealth, HealthMax);
		SetActorProperty(0, APROP_DamageFactor, DamageFactor);
		SetActorProperty(0, APROP_Speed, Speed);
		SetActorProperty(0, APROP_JumpZ, JumpHeight);
	};
};
