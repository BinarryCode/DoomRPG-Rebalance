#include "RPG.dh"

#include "Arena.dh"
#include "Augs.dh"
#include "CharSave.dh"
#include "ItemData.dh"
#include "Shield.dh"
#include "Skills.dh"
#include "Stats.dh"
#include "Utils.dh"

/*  
    
    --- Character Save Format ---
    
    TODO: Rewriting
    
    GENERAL NOTES
    - Each section is seperated by a -, except the checksum which is seperated by a |
    - Items such as Tokens, Shield Parts and Stims will be stored in the Locker for retrieval instead of in the save data itself
    - Each byte will be stored with a leading 0 if necessary, so a level of 10 and a rank level of 5 will come out as 0A05
    
    1. Version / Compatibility Flag
        - Version is referenced from defs, stored in 2 bytes
        - Mirror of the CompatMode static, stored in 1 byte
    2. Level / Rank Level
        - Only Level and Rank Level are stored, the XP to give is determined from these
        - Both Level and Rank Level are stored in 1 byte each
    3. Stats
        - Each stat will be stored in 1 byte since they will never go above 200 by normal means
    4. Skills
        - Each skill level is stored in 1 byte
        - Each skill category will be wrapped in a set of []'s
        - Each skill within each category will be seperated by a -
    5. Skill Wheel
        - 16 bytes total
        - Each slot is 2 bytes
        - First byte is the category, second byte is the index
        - Both bytes being 255 (FFFF) means it is blank
    6. Augmentations
        - Each augmentation's level is stored in 1 byte
    7. Stims
        - Each stim vial type is stored in 4 bytes
    8. Misc
        - Credits
          - Stored in 4 bytes
        - Augmentation Battery
          - Stored in 1 byte
        - Toxicity
          - Stored in 1 byte
        - Pay Bonus
          - Stored in 2 bytes
        - Arena Wave
          - Stored in 2 bytes
    9. Locker
        - Each item's count will be stored in 4 bytes
        - Each item category will be wrapped in a set of []'s
        - Each item within each category will be seperated by a -
        
    ----- COMPATIBILITY EXTENSIONS -----
    
    1. DRLA Assemblies
        - Each assembly set can be stored in a 4-byte bitfield
    2. DRLA Known Exotic Effects Info
        - Each weapon can use a 1 byte bitfield to hold the known exoctic effects
    
    Checksum
        - Checksum is seperated out at the end via a |
        - Checksum is determined by adding the value of each entry into a total buffer and doing the following:
          ((Total * 8) / 2) << 8
    
    BASIC EXAMPLE
    - Each category is seperated onto a new line for readability
    - Version 1, DRLA Compatibility mode
    - Level 10, Rank 4
    - Stats are Defaults
    - First skill of each category learned at it's max level
    - Skill wheel contains Heal and Red Aura on slots 1 and 2
    - Augs are levels 1, 2, 3, 4, 1, 2, 3, 4, 1 respectively
    - Each stim is 0 for brevity
    - 1000 Credits, 100% Battery, 25% Toxicity, 10% Pay Bonus
    - Locker and DRLA stuff are 0 and omitted for brevity
    
    0102
    -0A04
    -00000A0A00000A00
    -[0400000000][020000000000000000][060000000000000000][0200000000][0700000000000000000000000000000000][0100000000000000]
    -00000200FFFFFFFFFFFFFFFFFFFFFFFF
    -010203040102030401-
    -...
    -03E864190A
    -...
    -...
    -...
    |42F0000
    
*/

str[DRLA_MAX_ASSEMBLIES] DRLAAssemblies =
{
    "RLChainswordAssemblyLearntToken";
    "RLPiercingBladeAssemblyLearntToken";
    "RLSilencedPistolAssemblyLearntToken";
    "RLShredderPistolAssemblyLearntToken";
    "RLSpeedloaderPistolAssemblyLearntToken";
    "RLHighPowerWeaponAssemblyLearntToken";
    "RLElephantGunAssemblyLearntToken";
    "RLHeavyShotgunAssemblyLearntToken";
    "RLPlasmaticShrapnelAssemblyLearntToken";
    "RLTacticalShotgunAssemblyLearntToken";
    "RLGatlingGunAssemblyLearntToken";
    "RLMicroLauncherAssemblyLearntToken";
    "RLDoubleChainsawAssemblyLearntToken";
    "RLStormPistolAssemblyLearntToken";
    "RLPlasmaPistolAssemblyLearntToken";
    "RLAutoshotgunAssemblyLearntToken";
    "RLNanoShrapnelAssemblyLearntToken";
    "RLFocusedDoubleShotgunAssemblyLearntToken";
    "RLBulletstormChaingunAssemblyLearntToken";
    "RLAssaultRifleAssemblyLearntToken";
    "RLBurstCannonAssemblyLearntToken";
    "RLTacticalRocketLauncherAssemblyLearntToken";
    "RLGrenadeLauncherAssemblyLearntToken";
    "RLHyperblasterAssemblyLearntToken";
    "RLPlasmaRifleMkIIAssemblyLearntToken";
    "RLVBFG9000AssemblyLearntToken";
    "RLMiniMissilePistolAssemblyLearntToken";
    "RLRipperAssemblyLearntToken";
    "RLDemolitionAmmoAssemblyLearntToken";
    "RLNanomanufactureAmmoAssemblyLearntToken";
    "RLMotherInLawAssemblyLearntToken";
    "RLPlasmaRefractorAssemblyLearntToken";
    "RLBiggestFuckingGunAssemblyLearntToken";
    "RLAutocannonAssemblyLearntToken";
};

acscript void SaveCharacter() net
{
    // You need to be in the Outpost to do this
    if (!InBase)
    {
        SetFont("BIGFONT");
        HudMessage("\cgERROR: \cjYou must be in the Outpost to deposit your equipment\n", HUDMSG_FADEOUT, 0, CR_WHITE, 1.5, 0.5, 3.0, 2.0);
        ActivatorSound("menu/error", 127);
        return;
    };
    
    SetFont("BIGFONT");
    HudMessage("===== Save In Progress =====\n", HUDMSG_PLAIN | HUDMSG_LOG, 70, CR_YELLOW, 0.5, 0.3, 0);
    SetFont("SMALLFONT");
    HudMessage("Do not quit the game or power off your console.\n", HUDMSG_PLAIN | HUDMSG_LOG, 71, CR_ORANGE, 0.5, 0.35, 0);
    
    // Bulk Deposit
    // TODO: Should be moved to a Locker function
    for (int i = 0; i < ItemCategories; i++)
    {
        for (int j = 0; j < ItemMax[i]; j++)
            if (CheckInventory(ItemData[i][j].Actor) > 0)
            {
                Player.Locker[i][j] = CheckInventory(ItemData[i][j].Actor);
                SetInventory(ItemData[i][j].Actor, 0);
            };
    };
    
    Delay(1);
    
    // Populate the data
    auto CharSaveInfo Info;
    PopulateCharData(&Info);
    
    auto char const *SaveString = MakeSaveString(&Info);
    auto char *EncodedSaveString = Z_Malloc(strlen(SaveString) + 1, PU_STATIC, NULL);
    auto bool EncodeLock = false;
    
    EncodeRLE (SaveString, EncodedSaveString, &EncodeLock);
    while (EncodeLock) Delay(1);
    
    EncodedSaveString = Z_Realloc(EncodedSaveString, strlen(EncodedSaveString) + 1, PU_STATIC, NULL);
    //Log("Save Data: %s\n", EncodedSaveString);
    int PartialStringsNeeded = strlen(EncodedSaveString) / CHARSAVE_MAXSIZE;
    if (strlen(EncodedSaveString) % CHARSAVE_MAXSIZE > 0)
        PartialStringsNeeded++;
    auto char *PartialSaveString = Z_Malloc(CHARSAVE_MAXSIZE + 1, PU_STATIC, NULL);
    PartialSaveString[CHARSAVE_MAXSIZE] = '\x00';
    
    for (int i = 0; i < CHARSAVE_MAXCVARS; i++)
        SetUserCVarString(PlayerNumber(), StrParam("drpg_char_data_%d\n", i), "");

    bool success = true;
    
    if (PartialStringsNeeded > CHARSAVE_MAXCVARS)
        success = false;
    if (success && !SetUserCVar(PlayerNumber(), "drpg_char_data_len", PartialStringsNeeded))
        success = false;
    for (int i = 0; success && i < PartialStringsNeeded; i++)
    {
        strncpy(PartialSaveString, EncodedSaveString + (CHARSAVE_MAXSIZE * i), CHARSAVE_MAXSIZE);
        if (!SetUserCVarString(PlayerNumber(), StrParam("drpg_char_data_%d\n", i), StrParam("%s\n", PartialSaveString)))
            success = false;
    };
    
    Z_Free ((void *)SaveString);
    Z_Free ((void *)EncodedSaveString);
    Z_Free ((void *)PartialSaveString);
    
    if (success)
    {
        // Saving Successful
        ActivatorSound("charsave/save", 127);
        SetFont("BIGFONT");
        HudMessage("===== Character Saved =====\n", HUDMSG_FADEOUT | HUDMSG_LOG, 70, CR_WHITE, 0.5, 0.3, 1.0, 2.0);
        HudMessage("\n", HUDMSG_FADEOUT, 71, CR_ORANGE, 0.5, 0.35, 1.0, 2.0);
    }
    else
    {
        // Saving Failed
        ActivatorSound("charsave/fail", 127);
        SetFont("BIGFONT");
        HudMessage("===== Character Save Failed =====\n", HUDMSG_FADEOUT | HUDMSG_LOG, 70, CR_RED, 0.5, 0.3, 1.0, 2.0);
        SetFont("SMALLFONT");
        HudMessage("A CVar could not be written to.\n", HUDMSG_FADEOUT | HUDMSG_LOG, 71, CR_ORANGE, 0.5, 0.35, 1.0, 2.0);
        HudMessage("Perhaps your save is too large?\n", HUDMSG_FADEOUT | HUDMSG_LOG, 72, CR_ORANGE, 0.5, 0.4, 1.0, 2.0);
        HudMessage("Post your ini if you see this.\n", HUDMSG_FADEOUT | HUDMSG_LOG, 73, CR_ORANGE, 0.5, 0.45, 1.0, 2.0);
    };
};

acscript void LoadCharacter() net
{
    // !!! TEMPORARY !!!
    // IN PROGRESS - WIP
    SetFont("BIGFONT");
    HudMessage("\cgERROR: \cjCurrently being rewritten\n", HUDMSG_FADEOUT, 0, CR_WHITE, 1.5, 0.5, 3.0, 2.0);
    ActivatorSound("menu/error", 127);
    return;
    
    ActivatorSound("charsave/accept", 127);
    SetFont("BIGFONT");
    HudMessage("===== Character Load Complete =====\n", HUDMSG_FADEOUT, 0, CR_GREEN, 0.5, 0.5, 1.0, 2.0);
};

acscript void DumpCharacter()
{
};

// Hexadecimal storage
function char ToHexChar(int i)
{
    return "0123456789ABCDEF"[i & 0xF];
};

function int FromHexChar(char c)
{
    switch (c)
    {
    case '0':           return 0;
    case '1':           return 1;
    case '2':           return 2;
    case '3':           return 3;
    case '4':           return 4;
    case '5':           return 5;
    case '6':           return 6;
    case '7':           return 7;
    case '8':           return 8;
    case '9':           return 9;
    case 'A': case 'a': return 10;
    case 'B': case 'b': return 11;
    case 'C': case 'c': return 12;
    case 'D': case 'd': return 13;
    case 'E': case 'e': return 14;
    case 'F': case 'f': return 15;
    };
    
    return 0; // Default
};

script void PopulateCharData(CharSaveInfo *Info)
{
    // 1. Version / Compatibility Flag
    Info->Version = CHARSAVE_VERSION;
    Info->CompatMode = CompatMode;
    
    // 2. Level / Rank Level
    Info->Level = Player.Level;
    Info->RankLevel = Player.RankLevel;
    
    // 3. Stats
    Info->Stats[0] = Player.Strength;
    Info->Stats[1] = Player.Defense;
    Info->Stats[2] = Player.Vitality;
    Info->Stats[3] = Player.Energy;
    Info->Stats[4] = Player.Regeneration;
    Info->Stats[5] = Player.Agility;
    Info->Stats[6] = Player.Capacity;
    Info->Stats[7] = Player.Luck;
    
    // 4. Skills
    for (int i = 0; i < MAX_CATEGORIES; i++)
        for (int j = 0; j < MAX_SKILLS; j++)
            Info->Skills[i][j] = Player.SkillLevel[i][j].Level;
    
    // 5. Skill Wheel
    for (int i = 0; i < MAX_SKILLKEYS; i++)
    {
        Info->SkillWheel[i][0] = Player.SkillCategory[i];
        Info->SkillWheel[i][1] = Player.SkillIndex[i];
        if (Info->SkillWheel[i][0] == -1)
            Info->SkillWheel[i][0] = 255;
        if (Info->SkillWheel[i][1] == -1)
            Info->SkillWheel[i][1] = 255;
    };
    
    // 6. Augmentations
    for (int i = 0; i < MAX_AUGS; i++)
        Info->Augs[i] = Player.Augs.Level[i];
    
    // 7. Stims
    for (int i = 0; i < MAX_COMPOUNDS; i++)
        Info->Stims[i] = Player.Stim.Vials[i];
    
    // 8. Misc
    Info->Credits = CheckInventory("DRPGCredits");
    Info->Battery = Player.Augs.Battery;
    Info->Toxicity = Player.Toxicity;
    Info->PayBonus = Player.PayBonus;
    Info->ArenaWave = ArenaMaxWave;
    
    // 9. Locker
    for (int i = 0; i < ITEM_CATEGORIES; i++)
        for (int j = 0; j < ITEM_MAX; j++)
            Info->Locker[i][j] = Player.Locker[i][j];
    
    // ----- COMPATIBILITY EXTENSIONS -----
    
    // 1. DRLA Assemblies
    for (int i = 0; i < DRLA_MAX_ASSEMBLIES; i++)
    {
        if (CheckInventory(DRLAAssemblies[i]) && i < 16)
            Info->DRLAAssemblies1 |= 1 << i
        else if (CheckInventory(DRLAAssemblies[i]) && i < 32)
            Info->DRLAAssemblies2 |= 1 << (i - 16)
        else if (CheckInventory(DRLAAssemblies[i]) && i < 48)
            Info->DRLAAssemblies3 |= 1 << (i - 32);
    };
};

script char const *MakeSaveString(CharSaveInfo *Info)
{
    char *SaveString = Z_Malloc(65536, PU_STATIC, NULL);
    unsigned int pos = 0;
    
    // Version
    SaveString[pos + 3] = ToHexChar(Info->Version);
    SaveString[pos + 2] = ToHexChar(Info->Version >> 4);
    SaveString[pos + 1] = ToHexChar(Info->Version >> 8);
    SaveString[pos + 0] = ToHexChar(Info->Version >> 12);
    pos += 4;
    
    // Compatibility
    SaveString[pos + 1] = ToHexChar(Info->CompatMode);
    SaveString[pos + 0] = ToHexChar(Info->CompatMode >> 4);
    pos += 2;
    
    // Level & Rank
    SaveString[pos + 3] = ToHexChar(Info->RankLevel);
    SaveString[pos + 2] = ToHexChar(Info->RankLevel >> 4);
    SaveString[pos + 1] = ToHexChar(Info->Level);
    SaveString[pos + 0] = ToHexChar(Info->Level >> 4);
    pos += 4;
    
    // Stats
    for (int i = 0; i < STAT_MAX; i++)
    {
        SaveString[pos + 1] = ToHexChar(Info->Stats[i]);
        SaveString[pos + 0] = ToHexChar(Info->Stats[i] >> 4);
        pos += 2;
    };
    
    // Skills
    for (int i = 0; i < MAX_CATEGORIES; i++)
        for (int j = 0; j < MAX_SKILLS; j++)
        {
            SaveString[pos + 1] = ToHexChar(Info->Skills[i][j]);
            SaveString[pos + 0] = ToHexChar(Info->Skills[i][j] >> 4);
            pos += 2;
        };
    
    // Skill Wheel
    for (int i = 0; i < MAX_SKILLKEYS; i++)
    {
        SaveString[pos + 3] = ToHexChar(Info->SkillWheel[i][1]);
        SaveString[pos + 2] = ToHexChar(Info->SkillWheel[i][1] >> 4);
        SaveString[pos + 1] = ToHexChar(Info->SkillWheel[i][0]);
        SaveString[pos + 0] = ToHexChar(Info->SkillWheel[i][0] >> 4);
        pos += 4;
    };
    
    // Augs
    for (int i = 0; i < MAX_AUGS; i++)
    {
        SaveString[pos + 1] = ToHexChar(Info->Augs[i]);
        SaveString[pos + 0] = ToHexChar(Info->Augs[i] >> 4);
        pos += 2;
    };
    
    // Stims
    for (int i = 0; i < MAX_COMPOUNDS; i++)
    {
        SaveString[pos + 7] = ToHexChar(Info->Stims[i]);
        SaveString[pos + 6] = ToHexChar(Info->Stims[i] >> 4);
        SaveString[pos + 5] = ToHexChar(Info->Stims[i] >> 8);
        SaveString[pos + 4] = ToHexChar(Info->Stims[i] >> 12);
        SaveString[pos + 3] = ToHexChar(Info->Stims[i] >> 16);
        SaveString[pos + 2] = ToHexChar(Info->Stims[i] >> 20);
        SaveString[pos + 1] = ToHexChar(Info->Stims[i] >> 24);
        SaveString[pos + 0] = ToHexChar(Info->Stims[i] >> 28);
        pos += 8;
    };
    
    // Misc
    
    // Credits
    SaveString[pos + 7] = ToHexChar(Info->Credits);
    SaveString[pos + 6] = ToHexChar(Info->Credits >> 4);
    SaveString[pos + 5] = ToHexChar(Info->Credits >> 8);
    SaveString[pos + 4] = ToHexChar(Info->Credits >> 12);
    SaveString[pos + 3] = ToHexChar(Info->Credits >> 16);
    SaveString[pos + 2] = ToHexChar(Info->Credits >> 20);
    SaveString[pos + 1] = ToHexChar(Info->Credits >> 24);
    SaveString[pos + 0] = ToHexChar(Info->Credits >> 28);
    pos += 8;
    
    // Aug Battery
    SaveString[pos + 1] = ToHexChar(Info->Battery);
    SaveString[pos + 0] = ToHexChar(Info->Battery >> 4);
    pos += 2;
    
    // Toxicity
    SaveString[pos + 1] = ToHexChar(Info->Toxicity);
    SaveString[pos + 0] = ToHexChar(Info->Toxicity >> 4);
    pos += 2;
    
    // Pay Bonus
    SaveString[pos + 3] = ToHexChar(Info->PayBonus);
    SaveString[pos + 2] = ToHexChar(Info->PayBonus >> 4);
    SaveString[pos + 1] = ToHexChar(Info->PayBonus >> 8);
    SaveString[pos + 0] = ToHexChar(Info->PayBonus >> 12);
    pos += 4;
    
    // Arena Wave
    SaveString[pos + 3] = ToHexChar(Info->ArenaWave);
    SaveString[pos + 2] = ToHexChar(Info->ArenaWave >> 4);
    SaveString[pos + 1] = ToHexChar(Info->ArenaWave >> 8);
    SaveString[pos + 0] = ToHexChar(Info->ArenaWave >> 12);
    pos += 4;

    // Locker
    for (int i = 0; i < ITEM_CATEGORIES; i++)
        for (int j = 0; j < ITEM_MAX; j++)
        {
            SaveString[pos + 3] = ToHexChar(Info->Locker[i][j]);
            SaveString[pos + 2] = ToHexChar(Info->Locker[i][j] >> 4);
            SaveString[pos + 1] = ToHexChar(Info->Locker[i][j] >> 8);
            SaveString[pos + 0] = ToHexChar(Info->Locker[i][j] >> 12);
            pos += 4;
        };
    
    // DRLA Assemblies
    SaveString[pos + 3] = ToHexChar(Info->DRLAAssemblies1);
    SaveString[pos + 2] = ToHexChar(Info->DRLAAssemblies1 >> 4);
    SaveString[pos + 1] = ToHexChar(Info->DRLAAssemblies1 >> 8);
    SaveString[pos + 0] = ToHexChar(Info->DRLAAssemblies1 >> 12);
    pos += 4;
    SaveString[pos + 3] = ToHexChar(Info->DRLAAssemblies2);
    SaveString[pos + 2] = ToHexChar(Info->DRLAAssemblies2 >> 4);
    SaveString[pos + 1] = ToHexChar(Info->DRLAAssemblies2 >> 8);
    SaveString[pos + 0] = ToHexChar(Info->DRLAAssemblies2 >> 12);
    pos += 4;
    SaveString[pos + 3] = ToHexChar(Info->DRLAAssemblies3);
    SaveString[pos + 2] = ToHexChar(Info->DRLAAssemblies3 >> 4);
    SaveString[pos + 1] = ToHexChar(Info->DRLAAssemblies3 >> 8);
    SaveString[pos + 0] = ToHexChar(Info->DRLAAssemblies3 >> 12);
    pos += 4;
    
    SaveString[pos] = '\x00';
    
    SaveString = Z_Realloc (SaveString, strlen(SaveString) + 1, PU_STATIC, NULL);
    return SaveString;
};

script void EncodeRLE(char const *InString, char *OutString, bool *StringLock)
{
    *StringLock = true;
    
    int OutPos = 0;
    int InLength = strlen(InString);
    
    char LastSeen = '\x00';
    int LastCount = 0;
    
    for (int InPos = 0; InPos < InLength; InPos++)
    {
        char Seen = InString[InPos];
        
        if (Seen == LastSeen)
            LastCount++
        else
        {
            if (LastCount > 3)
            {
                str LastSize = StrParam("[%d]\n", LastCount - 1);
                for (int i = 0; i < StrLen(LastSize); i++)
                    OutString[OutPos++] = (char)LastSize[i];
            }
            else
            {
                for (int i = LastCount - 1; i > 0; i--)
                    OutString[OutPos++] = LastSeen;
            };
            
            LastSeen = Seen;
            LastCount = 1;
            if (Seen)
                OutString[OutPos++] = Seen;
        };
        
        if (InPos % 1000 == 0) Delay(1);
    };
    
    if (LastCount > 1)
    {
        str LastSize = StrParam("[%d]\n", LastCount - 1);
        for (int i = 0; i < StrLen(LastSize); i++)
            OutString[OutPos++] = (char)LastSize[i];
    };
        
    OutString[OutPos] = '\x00';
    *StringLock = false;
};

function int CalculateChecksum(int Value)
{
    return ((Value * 8) / 2) << 8;
};
