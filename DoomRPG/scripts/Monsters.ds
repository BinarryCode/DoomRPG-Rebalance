#include "RPG.dh"

#include "Arena.dh"
#include "Mission.dh"
#include "Monsters.dh"
#include "Popoffs.dh"
#include "Shield.dh"
#include "Stats.dh"
#include "Utils.dh"

AddressSpace MapArray MonsterSpace;
AddressSpace MapArray MonsterStatsSpace;

int MonsterID = 1;
MonsterStatsSpace MonsterStats[MAX_MONSTERS] Monsters;

MonsterSpace MonsterInfo[MAX_DEF_MONSTERS] MonsterData =
{
    { "ZombieMan";                          "Former Human";             1;      0;  };
    { "ShotgunGuy";                         "Former Sergeant";          2;      0;  };
    { "ChaingunGuy";                        "Former Commando";          5;      0;  };
    { "DoomImp";                            "Imp";                      4;      0;  };
    { "Demon";                              "Demon";                    3;      0;  };
    { "Spectre";                            "Spectre";                  3;      0;  };
    { "LostSoul";                           "Lost Soul";                3;      0;  };
    { "Cacodemon";                          "Cacodemon";                10;     0;  };
    { "HellKnight";                         "Hell Knight";              20;     0;  };
    { "BaronOfHell";                        "Baron of Hell";            30;     0;  };
    { "PainElemental";                      "Pain Elemental";           40;     0;  };
    { "Revenant";                           "Revenant";                 50;     0;  };
    { "Fatso";                              "Mancubus";                 60;     0;  };
    { "Arachnotron";                        "Arachnotron";              60;     0;  };
    { "ArchVile";                           "Arch-Vile";                70;     0;  };
    { "Cyberdemon";                         "Cyberdemon";               85;     0;  };
    { "SpiderMastermind";                   "Spider Mastermind";        95;     0;  };
};

MonsterSpace MonsterInfo[MAX_DEF_MONSTERS] MonsterDataBrutal =
{
    { "Zombie_Man";                         "Former Human";             1;      0;  };
    { "ShotgunGuy1";                        "Former Sergeant";          2;      0;  };
    { "ChaingunGuy1";                       "Former Commando";          5;      0;  };
    { "Imp";                                "Imp";                      4;      0;  };
    { "BullDemon";                          "Demon";                    3;      0;  };
    { "Spectro";                            "Spectre";                  3;      0;  };
    { "TehLostSoul";                        "Lost Soul";                3;      0;  };
    { "Cacodemon_";                         "Cacodemon";                10;     0;  };
    { "HellKnight2";                        "Hell Knight";              20;     0;  };
    { "BaronOfHell2";                       "Baron of Hell";            30;     0;  };
    { "PainElemental1";                     "Pain Elemental";           40;     0;  };
    { "Revenant1";                          "Revenant";                 50;     0;  };
    { "Mancubus";                           "Mancubus";                 60;     0;  };
    { "Arachnotron1";                       "Arachnotron";              60;     0;  };
    { "TehArchVile";                        "Arch-Vile";                70;     0;  };
    { "TheCyberdemon";                      "Cyberdemon";               85;     0;  };
    { "TheSpiderMastermind";                "Spider Mastermind";        95;     0;  };
};

MonsterSpace MonsterInfo[MAX_DEF_MONSTERS_DRLA] MonsterDataDRLA =
{
    // Normal
    { "RLFormerHuman";                      "Former Human";             1;      0;  };
    { "RLFormerSergeant";                   "Former Sergeant";          2;      0;  };
    { "RLFormerCommando";                   "Former Commando";          5;      0;  };
    { "RLFormerCaptain";                    "Former Captain";           8;      0;  };
    { "RLImp";                              "Imp";                      4;      0;  };
    { "RLDemon";                            "Demon";                    3;      0;  };
    { "RLSpectre";                          "Spectre";                  3;      0;  };
    { "RLLostSoul";                         "Lost Soul";                3;      0;  };
    { "RLCacodemon";                        "Cacodemon";                10;     0;  };
    { "RLHellKnight";                       "Hell Knight";              20;     0;  };
    { "RLBaronOfHell";                      "Baron of Hell";            30;     0;  };
    { "RLPainElemental";                    "Pain Elemental";           40;     0;  };
    { "RLRevenant";                         "Revenant";                 50;     0;  };
    { "RLMancubus";                         "Mancubus";                 60;     0;  };
    { "RLArachnotron";                      "Arachnotron";              60;     0;  };
    { "RLArchvile";                         "Arch-Vile";                70;     0;  };
    { "RLCyberdemon";                       "Cyberdemon";               87;     0;  };
    { "RLSpiderMastermind";                 "Spider Mastermind";        95;     0;  };
    { "RLAgonyElemental";                   "Agony Elemental";          100;    0;  };
    
    // Nightmare
    { "RLEliteHuman";                       "Elite Human";              5;      1;  };
    { "RLEliteSergeant";                    "Elite Sergeant";           8;      1;  };
    { "RLEliteCommando";                    "Elite Commando";           12;     1;  };
    { "RLEliteCaptain";                     "Elite Captain";            15;     1;  };
    { "RLNightmareImp";                     "Nightmare Imp";            8;      1;  };
    { "RLNightmareDemon";                   "Nightmare Demon";          6;      1;  };
    { "RLNightmareSpectre";                 "Nightmare Spectre";        6;      1;  };
    { "RLNightmareLostSoul";                "Nightmare Soul";           6;      1;  };
    { "RLNightmareCacodemon";               "Nightmare Cacodemon";      14;     1;  };
    { "RLNightmareHellKnight";              "Nightmare Knight";         25;     1;  };
    { "RLNightmareBaronOfHell";             "Baron of Nightmares";      36;     1;  };
    { "RLNightmareArachnotron";             "Nightmare Arachnotron";    67;     1;  };
    { "RLNightmarePainElemental";           "Nightmare Elemental";      43;     1;  };
    { "RLNightmareRevenant";                "Nightmare Revenant";       52;     1;  };
    { "RLNightmareMancubus";                "Nightmare Mancubus";       64;     1;  };
    { "RLNightmareArchvile";                "Nightmare Vile";           85;     1;  };
    { "RLNightmareCyberdemon";              "Nightmare Cyberdemon";     100;    1;  };
    
    // Cybernetic
    { "RLCyberneticImp";                    "Cyber-Imp";                6;      1;  };
    { "RLCyberneticDemon";                  "Mech-Demon";               5;      1;  };
    { "RLCyberneticSpectre";                "Mechtre";                  5;      1;  };
    { "RLCyberneticLostSoul";               "Hellmine";                 1;      1;  };
    { "RLCyberneticHellKnight";             "Cybruiser";                35;     1;  };
    { "RLCyberneticBaronOfHell";            "Techno-Lord";              40;     1;  };
    { "RLCyberneticArachnotron";            "Arachnosentinel";          64;     1;  };
    { "RLCyberneticRevenant";               "Heavy Revenant";           57;     1;  };
    { "RLCyberneticMancubus";               "Volacubus";                68;     1;  };
    { "RLCyberneticSpiderMastermind";       "Spider Overmind";          100;    1;  };
    
    // Armageddon
    // ...
};

MonsterSpace str[MAX_HUMANS][2] MonsterHumanData =
{
    // Former
    { "RLFormerHumanPistol";            "RLFormerHuman";    };
    { "RLFormerHumanBattleRifle";       "RLFormerHuman";    };
    { "RLFormerHumanBattleRifle2";      "RLFormerHuman";    };
    { "RLFormerHumanBattleRifle3";      "RLFormerHuman";    };
    { "RLFormerSergeantShotgun";        "RLFormerSergeant"; };
    { "RLFormerSergeantCombatShotgun";  "RLFormerSergeant"; };
    { "RLFormerCommandoChaingun";       "RLFormerCommando"; };
    { "RLFormerCommandoBattleRifle";    "RLFormerCommando"; };
    { "RLFormerCaptainPlasmaRifle";     "RLFormerCaptain";  };
    
    // Elite
    { "RLEliteHumanCombatPistol";       "RLEliteHuman";     };
    { "RLEliteHumanHandcannon";         "RLEliteHuman";     };
    { "RLEliteHumanBattleRifle";        "RLEliteHuman";     };
    { "RLEliteHumanBattleRifle2";       "RLEliteHuman";     };
    { "RLEliteHumanUzi";                "RLEliteHuman";     };
    { "RLEliteSergeantDoubleShotgun";   "RLEliteSergeant";  };
    { "RLEliteSergeantAssaultShotgun";  "RLEliteSergeant";  };
    { "RLEliteSergeantPlasmaShotgun";   "RLEliteSergeant";  };
    { "RLEliteCommandoMinigun";         "RLEliteCommando";  };
    { "RLEliteCaptainTristarBlaster";   "RLEliteCaptain";   };
};

// Monster Init Script
acscript void MonsterInit(int Flags)
{
    // Get a new ID for the monster
    if (GetMonsterID(0) == 0)
        SetMonsterID(0, MonsterID++);
    
    // Monster Stats Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    // If initialization has already occurred on this monster, terminate
    if (Stats->Init) return;
    
    // Set as initialized
    Stats->Init = true;
    SetInventory("DRPGMonsterInit", 1);
    
    // Store Actor Name
    Stats->Actor = GetActorClass(0);
    
    // Store Monster Flags
    Stats->Flags = Flags;
    
    // Set the Height and Radius
    Stats->Height = GetActorPropertyFixed(0, APROP_Height);
    Stats->Radius = GetActorPropertyFixed(0, APROP_Radius);
    
    // Apply base Spawn Health to HealthMax property
    Stats->SpawnHealth = GetActorProperty(0, APROP_SpawnHealth);
    Stats->HealthMax = Stats->SpawnHealth;
    
    // Start Damage Numbers Script
    DamageNumbers();
    
    // Give it a Health Bar
    if (!(Flags & MF_NOHEALTHBAR))
        Stats->HealthBar = true;
    
    // Apply Stats
    if (!(Flags & MF_NOSTATS))
        MonsterInitStats();
    
    // Save the Render Type
    Stats->RenderStyle = GetActorProperty(0, APROP_RenderStyle);
    
    // Stat-Change Handling
    MonsterStatsHandler();
    
    // Aura Spawner
    MonsterAuraDisplayHandler();
    
    // Regeneration Stat Handling
    if (!(Flags & MF_NOSTATS))
        MonsterRegenerationHandler();
    
    // Death Handler
    MonsterDeathCheck();
};

// Modify the targeted monster (mainly for debugging)
acscript void MonsterSet(int Level, int Aura, int Flags)
{
    // Move script to the targeted monster
    SetActivatorToTarget(Player.TID);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    // Set Stats/Flags
    if (Level > 0)
        Stats->Level = Level;
    if (Aura > 0)
        Stats->Aura = Aura;
    if (Flags > 0)
        Stats->Flags = Flags;
    
    // Re-run the Stats Script
    MonsterInitStats(SF_RECREATE);
};

// Dump the targeted monster's stats to the console
acscript void MonsterDump()
{
    int PlayerNum = PlayerNumber();
    
    // Move script to the targeted monster
    SetActivatorToTarget(Player.TID);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    // If you have no target, terminate
    if (ActivatorTID() == Players(PlayerNum).TID)
    {
        ActivatorSound("menu/error", 127);
        return;
    };
    
    Log("\ca===== MONSTER INFORMATION =====\n");
    Log(" Actor: %s\n", GetActorClass(0));
    Log(" Tag: %s\n", GetActorPropertyString(0, APROP_Nametag));
    Log(" Height: %k\n", GetActorPropertyFixed(0, APROP_Height));
    Log(" Radius: %k\n", GetActorPropertyFixed(0, APROP_Radius));
    Log(" Speed: %k\n", GetActorPropertyFixed(0, APROP_Speed));
    Log(" TID: %d\n", ActivatorTID());
    Log(" ID: %d\n", GetMonsterID(0));
    
    Log("\cf===== MONSTER FLAGS =====\n");
    Log(" Init: %d\n", Stats->Init);
    Log(" Named: %d\n", Stats->Named);
    Log(" HealthBar: %d\n", Stats->HealthBar);
    Log(" RenderStyle: %d\n", Stats->RenderStyle);
    Log(" DRPG Flags: %d\n", Stats->Flags);
    Log(" Reinforcement: %d\n", Stats->Reinforcement);
    Log(" Assassination Target: %d\n", Stats->Target);
    
    Log("\cd===== MONSTER STATS =====\n");
    Log(" Level: %d\n", Stats->Level);
    Log(" Aura: %d\n", Stats->Aura);
    Log(" Threat: %d\n", Stats->Threat);
    Log(" Spawn Health: %d\n", Stats->SpawnHealth);
    Log(" Health Max: %d\n", Stats->HealthMax);
    Log(" Base Speed: %d\n", Stats->Speed);
    Log(" \cgStrength: %d\n", Stats->Strength);
    Log(" \cdDefense: %d\n", Stats->Defense);
    Log(" \caVitality: %d\n", Stats->Vitality);
    Log(" \cnEnergy: %d\n", Stats->Energy);
    Log(" \ctRegeneration: %d\n", Stats->Regeneration);
    Log(" \ciAgility: %d\n", Stats->Agility);
    Log(" \chCapacity: %d\n", Stats->Capacity);
    Log(" \ckLuck: %d\n", Stats->Luck);
};

// Damage the target
acscript void MonsterDamage(int Amount, int Type)
{
    SetActivatorToTarget(Player.TID);
    
    if (ActivatorTID() == Player.TID)
        return;
    
    DamageThing(Amount, Type);
};

// Apply stats to monsters
script void MonsterInitStats(int StatFlags)
{
    // Move Activator to whoever the player is targeting
    if (StatFlags & SF_PLAYERTARGET)
        SetActivatorToTarget(Player.TID);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    int MonsterLevel = Stats->Level;
    int MonsterAura = Stats->Aura;
    int MonsterThreat = Stats->Threat;
    fixed MonsterSpeed = Stats->Speed;
    int MonsterStrength = Stats->Strength;
    int MonsterDefense = Stats->Defense;
    int MonsterVitality = Stats->Vitality;
    int MonsterEnergy = Stats->Energy;
    int MonsterRegeneration = Stats->Regeneration;
    int MonsterAgility = Stats->Agility;
    int MonsterCapacity = Stats->Capacity;
    int MonsterLuck = Stats->Luck;
    int NumPlayers;
    int PlayerAvgLevel;
    int AuraRandomizer;
    int[8] StatEffect;
    
    // Add up the levels of all the players in the game
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        if (!PlayerInGame(i)) continue;
        NumPlayers++;
        PlayerAvgLevel += Players(i).Level;
    };
    
    // Now calculate the average level between them
    PlayerAvgLevel /= NumPlayers;
    
    // Monster Stats System
    if (GetCVar("drpg_monster_levels") > 0)
    {
        // level
        if (!StatFlags)
        {
            int LevelType = GetCVar("drpg_monster_levels");
            fixed LevelWeight = GetCVarFixed("drpg_monster_level_weight");
            fixed MapWeight = GetCVarFixed("drpg_monster_map_weight");
            fixed RandomMinWeight = GetCVarFixed("drpg_monster_random_min_mult");
            fixed RandomMaxWeight = GetCVarFixed("drpg_monster_random_max_mult");
            int LevelNum = GetLevelInfo(LEVELINFO_LEVELNUM);
            
            // Cap Level Number to 100
            if (LevelNum > 100)
                LevelNum = 100;
            
            // If the Arena is active, base the Monster Levels Map Number portion on the current wave
            if (InBase && ArenaActive)
                LevelNum = ArenaWave;
            
            // Calculate Monster Level
            if (LevelType == 1 || LevelType == 3) // Player Level
                MonsterLevel += (int)((fixed)PlayerAvgLevel * LevelWeight);
            if (LevelType == 2 || LevelType == 3) // Map Number
                MonsterLevel += (int)((fixed)LevelNum * MapWeight);
            
            // Randomization Weight
            if (RandomMinWeight > RandomMaxWeight)
                Log("\cgERROR: \c-Monster Random Min Multiplier cannot be above Monster Random Max Multiplier!\n")
            else
                MonsterLevel = (int)(MonsterLevel * RandomFixed(RandomMinWeight, RandomMaxWeight));
            
            // If the monster is friendly, it has the average level of all players in the game
            if (GetActorProperty(0, APROP_Friendly))
                MonsterLevel = PlayerAvgLevel;
            
            // Special case for Powersuit Mk. II
            if (GetActorClass(0) == "DRPGSuperPowerSuit")
                MonsterLevel = 1000;
        };
        
        // Calculate the monster's cut and special stats
        if (GetCVar("drpg_monster_specialize"))
        {
            // Zero out the StatEffect array
            for (int i = 0; i < 8; i++)
                StatEffect[i] = 0;
            
            int DelayCounter = 0;
            int CutCount = 0;
            int SpecializedCount = 0;
            while (CutCount < 4 || SpecializedCount < 2)
            {
                for (int i = 0; i < 8; i++)
                {
                    if (StatEffect[i] == 0)
                    {
                        if (CutCount < 4 && Random(1, 2) == 1) // Cut Stat
                        {
                            StatEffect[i] = 1;
                            CutCount++;
                        }
                        else if (SpecializedCount < 2) // Specialized Stat
                        {
                            StatEffect[i] = 2;
                            SpecializedCount++;
                        };
                    };
                };
                
                DelayCounter++;
                if ((DelayCounter % 10) == 0)
                    Delay(1);
                
                // Give up if it takes too long
                if (DelayCounter > 100)
                {
                    if (GetUserCVar(Arbitrator, "drpg_debug"))
                        Log("\cgERROR: \c-Gave up on specializing monster!\n");
                    break;
                };
            };
        };
        
        // Calculate Monster Stats
        MonsterStrength = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
        MonsterDefense = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
        MonsterVitality = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
        MonsterEnergy = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
        MonsterRegeneration = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
        MonsterAgility = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
        MonsterCapacity = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
        MonsterLuck = Random(MonsterLevel, MonsterLevel + Random(GameSkill(), GameSkill() * 2));
        
        if (GetCVar("drpg_monster_specialize"))
        {
            // Cut Stats
            if (StatEffect[0] == 1) MonsterStrength /= 2;
            if (StatEffect[1] == 1) MonsterDefense /= 2;
            if (StatEffect[2] == 1) MonsterVitality /= 2;
            if (StatEffect[3] == 1) MonsterEnergy /= 2;
            if (StatEffect[4] == 1) MonsterRegeneration /= 2;
            if (StatEffect[5] == 1) MonsterAgility /= 2;
            if (StatEffect[6] == 1) MonsterCapacity /= 2;
            if (StatEffect[7] == 1) MonsterLuck /= 2;
            
            // Specialized Stats
            if (StatEffect[0] == 2) MonsterStrength *= Random(2, 4);
            if (StatEffect[1] == 2) MonsterDefense *= Random(2, 4);
            if (StatEffect[2] == 2) MonsterVitality *= Random(2, 4);
            if (StatEffect[3] == 2) MonsterEnergy *= Random(2, 4);
            if (StatEffect[4] == 2) MonsterRegeneration *= Random(2, 4);
            if (StatEffect[5] == 2) MonsterAgility *= Random(2, 4);
            if (StatEffect[6] == 2) MonsterCapacity *= Random(2, 4);
            if (StatEffect[7] == 2) MonsterLuck *= Random(2, 4);
        };
    };
    
    // Apply Aura
    if (!GetActorProperty(0, APROP_Friendly) && !(Stats->Flags & MF_NOAURA) && !StatFlags)
    {
        int AuraCurve = GetCVar("drpg_aura_curve");
        int AuraMin = -1000 + MonsterEnergy + AuraCurve;
        if (AuraMin > 0) AuraMin = 0;
        AuraRandomizer = Random(AuraMin, 10);
        if (AuraRandomizer > 0)
            MonsterAura = AuraRandomizer;
        if (GetCVar("drpg_monster_shadows"))
            MonsterAura = 10;
    };
    
    // Apply the aura effects
    switch (MonsterAura)
    {
    case 1: // Red Aura - Strength
        MonsterStrength *= 2;
        GiveInventory("DRPGRedAuraGiver", 1);
        break;
    case 2: // Green Aura - Defense
        MonsterDefense *= 2;
        GiveInventory("DRPGGreenAuraGiver", 1);
        break;
    case 3: // White Aura - XP
        MonsterLevel *= 2;
        GiveInventory("DRPGWhiteAuraGiver", 1);
        MonsterLevelupHandler();
        break;
    case 4: // Pink Aura - Vitality
        MonsterVitality *= 2;
        GiveInventory("DRPGPinkAuraGiver", 1);
        break;
    case 5: // Blue Aura - Energy
        MonsterEnergy *= 2;
        GiveInventory("DRPGBlueAuraGiver", 1);
        MonsterEPDrainHandler();
        break;
    case 6: // Purple Aura - Regeneration
        MonsterRegeneration *= 2;
        break;
    case 7: // Orange Aura - Agility
        MonsterAgility *= 2;
        GiveInventory("DRPGOrangeAuraGiver", 1);
        break;
    case 8: // Dark Blue Aura - Capacity
        MonsterCapacity *= 2;
        GiveInventory("DRPGDarkBlueAuraGiver", 1);
        break;
    case 9: // Yellow Aura - Luck
        MonsterLuck *= 2;
        MonsterMoneyDrainHandler();
        break;
    case 10: // Black Aura - Miniboss
        MonsterLevel *= 2;
        MonsterStrength *= 2;
        MonsterDefense *= 2;
        MonsterVitality *= 2;
        MonsterEnergy *= 2;
        MonsterRegeneration *= 2;
        MonsterAgility *= 2;
        MonsterCapacity *= 2;
        MonsterLuck *= 2;
        GiveInventory("DRPGRedAuraGiver", 1);
        GiveInventory("DRPGGreenAuraGiver", 1);
        GiveInventory("DRPGWhiteAuraGiver", 1);
        GiveInventory("DRPGPinkAuraGiver", 1);
        GiveInventory("DRPGBlueAuraGiver", 1);
        GiveInventory("DRPGOrangeAuraGiver", 1);
        GiveInventory("DRPGDarkBlueAuraGiver", 1);
        MonsterLevelupHandler();
        MonsterEPDrainHandler();
        MonsterMoneyDrainHandler();
        break;
    };
    
    // Cap Level and Stats
    CapMonsterStats(Stats);
    
    // We need to make sure we only pass the speed to the monster if it's being initially created
    if (!StatFlags)
        MonsterSpeed = GetActorPropertyFixed(0, APROP_Speed);
    
    // Apply the stats to the monster
    Stats->Level = MonsterLevel;
    Stats->Aura = MonsterAura;
    Stats->Speed = MonsterSpeed;
    Stats->Strength = MonsterStrength;
    Stats->Defense = MonsterDefense;
    Stats->Vitality = MonsterVitality;
    Stats->Energy = MonsterEnergy;
    Stats->Regeneration = MonsterRegeneration;
    Stats->Agility = MonsterAgility;
    Stats->Capacity = MonsterCapacity;
    Stats->Luck = MonsterLuck;
    
    // Calculate Threat Level
    MonsterThreat = CalculateMonsterThreatLevel(Stats);
    Stats->Threat = MonsterThreat;
    
    // Calculate Health
    Stats->HealthMax = CalculateMonsterMaxHealth(Stats);
    SetActorProperty(0, APROP_Health, Stats->HealthMax);
    
    // Calculate Speed
    SetActorPropertyFixed(0, APROP_Speed, CalculateMonsterSpeed(Stats));
    
    // Give Credits
    SetInventory("DRPGCredits", Stats->Capacity);
};

script void MonsterStatsHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    int OldStrength;
    int OldDefense;
    int OldCapacity;
    int OldVitality;
    int OldAgility;
    int OldRegeneration;
    int OldEnergy;
    int OldLuck;
    bool StatsChanged;
    
    Start:
    
    if (ClassifyActor(0) & ACTOR_DEAD)
        return;
    
    if (Stats->NeedReinit)
    {
        MonsterInitStats(SF_RECREATE);
        Stats->NeedReinit = false;
        return;
    };
    
    // Levelup handling via White Aura radius
    if (CheckInventory("DRPGMonsterLevelup"))
        MonsterLevelup(Stats);
    
    // Cap Level and Stats
    CapMonsterStats(Stats);
    
    // Strength
    if (Stats->Strength != OldStrength)
    {
        StatsChanged = true;
        
        if (OldStrength)
            TakeInventory(StrParam("DRPGStrength%d\n", OldStrength * GameSkill()), 1);
        SetInventory(StrParam("DRPGStrength%d\n", Stats->Strength * GameSkill()), 1);
        OldStrength = Stats->Strength;
    };
    
    // Defense
    if (Stats->Defense != OldDefense)
    {
        StatsChanged = true;
        
        SetActorPropertyFixed(0, APROP_DamageFactor, 1.0 - (0.09 * (Stats->Defense / 100)));
        OldDefense = Stats->Defense;
    };
    
    // Capacity
    if (Stats->Capacity != OldCapacity)
    {
        StatsChanged = true;
        
        SetInventory("DRPGCredits", Stats->Capacity);
        OldCapacity = Stats->Capacity;
    };
    
    // Agility
    if (Stats->Agility != OldAgility)
    {
        StatsChanged = true;
        
        SetActorPropertyFixed(0, APROP_Speed, CalculateMonsterSpeed(Stats));
        OldAgility = Stats->Agility;
    };
    
    // Vitality
    if (Stats->Vitality != OldVitality)
    {
        StatsChanged = true;
        
        // Different effect depending on up or down
        Stats->HealthMax = CalculateMonsterMaxHealth(Stats);
        
        if (Stats->Vitality > OldVitality)
        {
            int healthcurr = GetActorProperty (0, APROP_Health);
            int healthdiff = Stats->HealthMax - healthcurr;
            SetActorProperty (0, APROP_Health, healthcurr + healthdiff / 2); // Heal half of the difference
        }
        else
             // Cap to new only if it's lower than current, so Weaken doesn't accidentally heal enemies
            if (GetActorProperty (0, APROP_Health) > Stats->HealthMax)
                SetActorProperty (0, APROP_Health, Stats->HealthMax);
        
        OldVitality = Stats->Vitality;
    };
    
    // Nothing much to do for these
    
    // Regeneration
    if (Stats->Regeneration != OldRegeneration)
    {
        StatsChanged = true;
        OldRegeneration = Stats->Regeneration;
    };
    
    // Energy
    if (Stats->Energy != OldEnergy)
    {
        StatsChanged = true;
        OldEnergy = Stats->Energy;
    };
    
    // Luck
    if (Stats->Luck != OldLuck)
    {
        StatsChanged = true;
        OldLuck = Stats->Luck;
    };
    
    if (StatsChanged)
    {
        // Re-calculate the monster's threat level
        Stats->Threat = CalculateMonsterThreatLevel(Stats);
        
        StatsChanged = false;
    };
    
    Delay(4);
    
    goto Start;
};

script void MonsterAuraDisplayHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    bool VisibleToPlayers;
    
    Start:
    
    if (ClassifyActor(0) & ACTOR_DEAD)
        return;
    
    VisibleToPlayers = false;
    
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        if (!PlayerInGame(i))
            continue;
        
        if (CheckSight(Players(i).TID, 0, CSF_NOBLOCKALL))
        {
            VisibleToPlayers = true;
            break;
        };
    };
    
    if (!VisibleToPlayers)
    {
        Delay(4);
        goto Start;
    };
    
    // Friendly Monster Aura
    if (GetActorProperty(0, APROP_Friendly) && GetActorProperty(0, APROP_MasterTID) > 0)
        SpawnAura(0, 0, false);
    
    // Black Aura Effects
    if (Stats->Aura == 10)
        if (GetActorLightLevel(0) < 192)
            SetActorProperty(0, APROP_RenderStyle, STYLE_Fuzzy)
        else
            SetActorProperty(0, APROP_RenderStyle, Stats->RenderStyle);
    
    // Spawn Aura
    if (Stats->Aura)
        SpawnAura(0, Stats->Aura, false);
    
    if (ClassifyActor(0) & ACTOR_DEAD)
        return;
    
    Delay(1);
    goto Start;
};

script void MonsterLevelupHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    int Energy;
    int DelayTime;
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    Start:
    
    // Calculate the Delay Time
    Energy = Stats->Energy;
    DelayTime = 35 * (int)((60.0 - ((fixed)Energy / 16.75)));
    if (DelayTime < 35)
        DelayTime = 35;
    Delay(DelayTime);
    
    if (ClassifyActor(0) & (ACTOR_DEAD | ACTOR_WORLD))
        return;
    
    // White and Shadow Aura monsters levelup monsters near them
    if (Stats->Aura == 3 || Stats->Aura == 10)
        GiveInventory("DRPGMonsterLevelupGiver", 1);
    
    // Loop back to the top if the monster is max level
    if (Stats->Level >= 1000)
        goto Start;
    
    // Levelup
    MonsterLevelup(Stats);
    
    goto Start;
};

script void MonsterEPDrainHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    Start:
    if (ClassifyActor(0) & ACTOR_DEAD)
        return;
    
    if (Stats->Aura != 3 && Stats->Aura != 10)
        return;
    
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        if (!PlayerInGame(i)) continue;
        
        if (Distance(0, Players(i).TID) < Stats->Radius * GameSkill() * 4 && CheckSight(0, Players(i).TID, 0) && Players(i).EP > 0)
        {
            int Previous = Players(i).EP;
            
            Players(i).EP -= Stats->Energy;
            
            if (Players(i).EP < 0)
                Players(i).EP = 0;
            
            if (Players(i).EP < Previous)
                Popoff(0, Previous - Players(i).EP, DNUM_EPGAIN);
        };
    };
    
    Delay(35);
    
    goto Start;
};

script void MonsterRegenerationHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    Start:
    if (ClassifyActor(0) & ACTOR_DEAD)
        return;
    
    SetActorProperty(0, APROP_Health, GetActorProperty(0, APROP_Health) + (int)((fixed)Stats->HealthMax * ((fixed)Stats->Regeneration / 1000.0)));
    
    // Prevent going over 100%
    if (GetActorProperty(0, APROP_Health) > Stats->HealthMax)
        SetActorProperty(0, APROP_Health, Stats->HealthMax);
    
    Delay(35 * (30 - (Stats->Aura == 6 ? 20 : 0)));
    goto Start;
};

script void MonsterMoneyDrainHandler()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    Start:
    if (ClassifyActor(0) & ACTOR_DEAD)
        return;
    
    if (Stats->Aura != 9 && Stats->Aura != 10)
        return;
    
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        if (!PlayerInGame(i)) continue;
        
        if (Distance(0, Players(i).TID) < Stats->Radius * GameSkill() * 4 && CheckSight(0, Players(i).TID, 0))
        {
            int Previous = CheckActorInventory(Players(i).TID, "DRPGCredits");
            
            TakeActorInventory(Players(i).TID, "DRPGCredits", Stats->Luck);
            GiveInventory("DRPGCredits", Stats->Luck);
            
            if (CheckActorInventory(Players(i).TID, "DRPGCredits") < Previous)
                Popoff(0, Previous - CheckActorInventory(Players(i).TID, "DRPGCredits"), DNUM_CREDGAIN);
        };
    };
    
    Delay(35);
    
    goto Start;
};

script void MonsterDeathCheck()
{
    // Delay Stagger
    Delay(GetMonsterID(0) % 4);
    
    Start:
    
    // Death
    if (ClassifyActor(0) & ACTOR_ALIVE)
    {
        Delay(4);
        goto Start;
    };
    
    MonsterDeath();
    return;
};

script void MonsterDeath()
{
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    int Killer = WhoKilledMe();
    fixed XPAmount = Random(GetActorProperty(0, APROP_SpawnHealth) / 2.0, GetActorProperty(0, APROP_SpawnHealth)) * (1.0 + (fixed)Stats->Threat * 0.3);
    int RankAmount = GetActorProperty(0, APROP_SpawnHealth) * (1 + (Stats->Threat - (Stats->Threat > 0 ? 1 : 0)));
    int DropMod = Stats->Luck * 0.256;
    int DropAmount = (int)(1.0 + ((fixed)Stats->Luck / 500.0));
    int DropTID = (Players(Killer).Stim.PowerupTimer[STIM_MAGNETIC] > 0 ? Players(Killer).TID : 0);
    
    // Always drop at least one item
    if (DropAmount < 1)
        DropAmount = 1;
    
    // Prevent Drop Mod from overflowing
    if (DropMod > 256)
        DropMod = 256;
    
    // Aura-Based XP/Rank Modifiers
    if (Stats->Aura > 0 && Stats->Aura < 10) // All Auras except Black
        RankAmount *= 2;
    if (Stats->Aura == 3) // White
        XPAmount *= 2;
    if (Stats->Aura == 10) // Black
    {
        XPAmount *= 2;
        RankAmount *= 4;
    };
    
    // Drops
    if (!(Stats->Flags & MF_NODROPS) && !GetActorProperty(0, APROP_Friendly) && !GetCVar("drpg_monster_shadows"))
    {
        for (int i = 1; i <= DropAmount; i++)
        {
            // Aura Drops
            switch (Stats->Aura)
            {
            case 1: // Red Aura - Strength
                DropMonsterItem(Killer, DropTID, "DRPGWeaponDropper", 128 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialStrength", 255);
                break;
            case 2: // Green Aura - Defense
                DropMonsterItem(Killer, DropTID, "DRPGArmorDropper", 128 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialDefense", 255);
                break;
            case 3: // White Aura - XP
                DropMonsterItem(Killer, DropTID, "DRPGSmallTokenDropper", 96 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialPotency", 255);
                break;
            case 4: // Pink Aura - Vitality
                DropMonsterItem(Killer, DropTID, "DRPGHealthDropper", 128 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialVitality", 255);
                break;
            case 5: // Blue Aura - Energy
                DropMonsterItem(Killer, DropTID, "DRPGEPCapsule", 128 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGBigEPCapsule", 64 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialEnergy", 255);
                break;
            case 6: // Purple Aura - Regeneration
                DropMonsterItem(Killer, DropTID, "DRPGRegenSphere", 128 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialRegeneration", 255);
                break;
            case 7: // Orange Aura - Agility
                DropMonsterItem(Killer, DropTID, "DRPGTimeSphere", 64 + (DropMod / 2));
                DropMonsterItem(Killer, DropTID, "DRPGVialAgility", 255);
                break;
            case 8: // Dark Blue Aura - Capacity
                DropMonsterItem(Killer, DropTID, "DRPGAmmoDropper", 128 + DropMod);
                if (GetCVar("drpg_ext_doomrl"))
                    DropMonsterItem(Killer, DropTID, "RLModpackSpawner", 128 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialCapacity", 255);
                break;
            case 9: // Yellow Aura - Luck
                DropMonsterItem(Killer, DropTID, "DRPGVialLuck", 255);
                break;
            case 10: // Black Aura - Miniboss
                DropMonsterItem(Killer, DropTID, "DRPGWeaponDropper", 128 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGArmorDropper", 128 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGSmallTokenDropper", 96 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGHealthDropper", 128 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGEPCapsule", 128 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGBigEPCapsule", 64 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGRegenSphere", 128 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGTimeSphere", 64 + (DropMod / 2));
                DropMonsterItem(Killer, DropTID, "DRPGAmmoDropper", 128 + DropMod);
                if (GetCVar("drpg_ext_doomrl"))
                    DropMonsterItem(Killer, DropTID, "RLModpackSpawner", 128 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialStrength", 192 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialDefense", 192 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialAgility", 192 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialVitality", 192 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialEnergy", 192 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialRegeneration", 192 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialCapacity", 192 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialLuck", 192 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialPurifier", 255);
                DropMonsterItem(Killer, DropTID, "DRPGVialPotency", 192 + DropMod);
                DropMonsterItem(Killer, DropTID, "DRPGVialDropperRare", 256);
                break;
            };
            
            // Rare Vials
            DropMonsterItem(Killer, DropTID, "DRPGVialDropperRare", 8);
            
            // Luck-based Drops
            if (Killer > -1)
            {
                    if (RandomFixed(0.0, 100.0) < Players(Killer).HealthChance) DropMonsterItem(Killer, DropTID, "DRPGHealthDropper", 256);
                    if (RandomFixed(0.0, 100.0) < Players(Killer).EPChance)     DropMonsterItem(Killer, DropTID, "DRPGEPCapsule", 256);
                    if (RandomFixed(0.0, 100.0) < Players(Killer).ArmorChance)  DropMonsterItem(Killer, DropTID, "DRPGArmorDropper", 256);
                    if (RandomFixed(0.0, 100.0) < Players(Killer).PowerupChance)DropMonsterItem(Killer, DropTID, "DRPGPowerupDropper", 256);
                    if (RandomFixed(0.0, 100.0) < Players(Killer).WeaponChance) DropMonsterItem(Killer, DropTID, "DRPGWeaponDropper", 256);
                    if (RandomFixed(0.0, 100.0) < Players(Killer).WeaponChance) DropMonsterItem(Killer, DropTID, "RLModpackSpawner", 256);
                    if (RandomFixed(0.0, 100.0) < Players(Killer).TokenChance)  DropMonsterItem(Killer, DropTID, "DRPGSmallTokenDropper", 256);
                    if (RandomFixed(0.0, 100.0) < Players(Killer).AugChance)    DropMonsterItem(Killer, DropTID, "DRPGAugDropper", 256);
                    if (RandomFixed(0.0, 100.0) < Players(Killer).ShieldChance) DropMonsterItem(Killer, DropTID, "DRPGShieldDropper", 256);
                    if (RandomFixed(0.0, 100.0) < Players(Killer).StimChance)   DropMonsterItem(Killer, DropTID, "DRPGStimDropper", 256);
                    if (RandomFixed(0.0, 100.0) < Players(Killer).StimChance)   DropMonsterItem(Killer, DropTID, "DRPGVialDropper", 256);
                    if (RandomFixed(0.0, 100.0) < Players(Killer).StimChance)   DropMonsterItem(Killer, DropTID, "DRPGVialDropperRare", 256);
            };
            
            Delay(1);
        };
        
        // Boss Drops
        if (Stats->Flags & MF_BOSS)
        {
            DropMonsterItem(Killer, DropTID, "DRPGCredits1000", 256);
            DropMonsterItem(Killer, DropTID, "DRPGSoulsphereRandomizer", 256);
            DropMonsterItem(Killer, DropTID, "DRPGContinue", 128 + DropMod);
            DropMonsterItem(Killer, DropTID, "DRPGTokenDropper", 255 + DropMod);
            DropMonsterItem(Killer, DropTID, "DRPGAugDropper", 128 + DropMod);
            DropMonsterItem(Killer, DropTID, "DRPGShieldDropper", 128 + DropMod);
            DropMonsterItem(Killer, DropTID, "DRPGUACCard", (128 + DropMod) / (Players(Killer).ShopCard + 1));
            if (GetCVar("drpg_ext_doomrl"))
                DropMonsterItem(Killer, DropTID, "DRPGImmunityCrystal", DropMod / 2);
        };
    };
    
    // Drop Credits
    if (!(Stats->Flags & MF_NODROPS) && CheckInventory("DRPGCredits") > 0)
        DropMoney(Killer, 0, Random(CheckInventory("DRPGCredits") / 2, CheckInventory("DRPGCredits")));
    
    // Credit Rain
    if (Killer > -1 && Players(Killer).Luck >= 100 && Random(1, 256) == 1)
    {
        fixed Z = GetActorCeilingZ(Players(Killer).TID) - GetActorPropertyFixed(Players(Killer).TID, APROP_Height);
        fixed Radius = GetActorPropertyFixed(Players(Killer).TID, APROP_Radius);
        
        ThingSound(Players(Killer).TID, "credits/payout", 127);
        Log("\cdLUDICROUS CREDITS!\n");
        
        for (int i = 0; i < 100; i++)
        {
            int CreditType = Random(1, 6);
            str CreditName;
            
            switch (CreditType)
            {
            case 1: CreditName = "DRPGCredits1";    break;
            case 2: CreditName = "DRPGCredits5";    break;
            case 3: CreditName = "DRPGCredits10";   break;
            case 4: CreditName = "DRPGCredits20";   break;
            case 5: CreditName = "DRPGCredits50";   break;
            case 6: CreditName = "DRPGCredits100";  break;
            };
            
            DropMonsterItem(Killer, Players(Killer).TID, CreditName, 256, RandomFixed(-Radius, Radius), RandomFixed(-Radius, Radius), Z);
            Delay(1);
        };
    };
    
    // Add XP/Rank
    if (!(Stats->Flags & MF_NOXP) && !GetActorProperty(0, APROP_Friendly))
    {
        // XP modifications based on level and skill
        if (GetCVar("drpg_xp_monsterlevel")) XPAmount *= 1.0 + ((fixed)Stats->Level / 100.0);
        if (GetCVar("drpg_xp_skilllevel")) XPAmount *= 1.0 - (0.15 * (fixed)GameSkill());
        
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (Stats->Flags & MF_NEGATIVEXP)
                AddXP(i, (int)XPAmount, -RankAmount, false)
            else
            {
                if (Killer == i)
                    AddXP(i, (int)XPAmount, RankAmount, false)
                else
                    AddXP(i, (int)XPAmount, RankAmount, true);
            };
        };
    };
    
    // Add a kill to the pay kills
    if (!(Stats->Flags & MF_NOPAYKILL) && Killer > -1)
    {
        if (Players(Killer).Shield.Accessory == SHIELD_ACC_REKT50 && Players(Killer).Shield.Active)
            Players(Killer).PayKills += 3
        else
            Players(Killer).PayKills++;
    };
    
    // Mission Handling
    MissionDeathCheck(Killer, Stats);
    
    // SHOTGUNS!
    if (GetCVar("drpg_shotguns"))
        DropMonsterItem(Killer, 0, "DRPGShotSpawn", 1, 255);
};

acscript void MonsterTransport(int Difficulty, int Time, int Radius)
{
    while (true)
    {
        Delay((Time > 0 ? (35 * Time) : -Time));

        bool Complete = true;
        bool DRLA = GetCVar("drpg_ext_doomrl");
        fixed X = GetActorX(0);
        fixed Y = GetActorY(0);
        fixed Z = GetActorZ(0);
        int Min = Difficulty;
        int Max = Difficulty + ((DRLA ? MAX_DEF_MONSTERS_DRLA : MAX_DEF_MONSTERS) - MAX_DIFFICULTIES);
        fixed SpawnX;
        fixed SpawnY;
        int TID;
        bool Success;
        int SpawnTries;
        int CurrentRadius;
        MonsterInfo Monster;
        
        // Check to see if the mission is complete
        for (int i = 0; i < MAX_PLAYERS; i++)
            if (Players(i).Mission.Active && Players(i).Mission.Type == MT_REINFORCEMENTS)
                Complete = false;
        
        // If the mission is complete, terminate
        if (Complete) return;
        
        // Cap the maximum
        // TODO: DRLA
        if (Max > MAX_MONSTERS - 3)
            Max = MAX_MONSTERS - 3;
        
        for (int i = Min; i < Max; i++)
        {
            if (GetCVar("drpg_ext_doomrl"))
                Monster = MonsterDataDRLA[i]
            else
                Monster = MonsterData[i];
            
            if (!Random(0, 9 - Difficulty))
            {
                TID = UniqueTID();
                Success = false;
                SpawnTries = 0;
                CurrentRadius = Radius;
                
                while (!Success && SpawnTries < 3)
                {
                    SpawnX = RandomFixed(-(fixed)CurrentRadius, (fixed)CurrentRadius);
                    SpawnY = RandomFixed(-(fixed)CurrentRadius, (fixed)CurrentRadius);
                    
                    // Get the floor Z position at this spot
                    SpawnForced("MapSpot", X + SpawnX, Y + SpawnY, Z, TID, 0);
                    Z = GetActorFloorZ(TID);
                    Thing_Remove(TID);
                    
                    Success = Spawn(Monster.Actor, X + SpawnX, Y + SpawnY, Z, TID, 0);
                    if (Success)
                        Success = CheckSight(0, TID, 0);
                    
                    if (!Success)
                    {
                        // Try again, closer to the player each time, up to 3 times, before giving up.
                        Thing_Remove(TID);
                        CurrentRadius /= 2;
                    };
                    
                    SpawnTries++;
                };
                if (Success)
                {
                    // Delay here to make sure the init script has time to run
                    Delay(4);
                    
                    // Pointer
                    MonsterStatsPtr Stats = &Monsters[GetMonsterID(TID)];
                    
                    Thing_Hate(TID, Player.TID);
                    Stats->Reinforcement = true;
                    Thing_ChangeTID(TID, 0); // Get rid of the ID

                    Spawn("TeleportFog", X + SpawnX, Y + SpawnY, Z, 0, 0);
                    
                    if (GetCVar("drpg_debug"))
                        Log("\cdDEBUG: \c-Reinforcements Spawning Index %d (\ca%s\c-)\n", i, Monster.Name);
                    
                    break;
                };
            };
        };
    };
};

script int WhoKilledMe()
{
    SetActivatorToTarget(0);
    return PlayerNumber();
};

function void MonsterLevelup(MonsterStatsPtr Stats)
{
    // If the monster is max level, return
    if (Stats->Level >= 1000) return;
    
    // Apply the stats to the monster
    Stats->Level++;
    Stats->Strength += Random(1, GameSkill());
    Stats->Defense += Random(1, GameSkill());
    Stats->Vitality += Random(1, GameSkill());
    Stats->Energy += Random(1, GameSkill());
    Stats->Regeneration += Random(1, GameSkill());
    Stats->Agility += Random(1, GameSkill());
    Stats->Capacity += Random(1, GameSkill());
    Stats->Luck += Random(1, GameSkill());
    
    // Spawn Level-up Arrow
    SpawnForced("DRPGLevelUpArrow", GetActorX(0), GetActorY(0), GetActorZ(0) + GetActorPropertyFixed(0, APROP_Height), 0, 0);
    
    if (CheckInventory("DRPGMonsterLevelup"))
        TakeInventory("DRPGMonsterLevelup", 1);
};

function void CapMonsterStats(MonsterStatsPtr Stats)
{
    if (Stats->Level <= 0)
        Stats->Level = 1;
    if (Stats->Level > 1000)
        Stats->Level = 1000;
    if (Stats->Level > 1000)
        Stats->Level = 1000;
    if (Stats->Strength > 1000)
        Stats->Strength = 1000;
    if (Stats->Defense > 1000)
        Stats->Defense = 1000;
    if (Stats->Vitality > 1000)
        Stats->Vitality = 1000;
    if (Stats->Energy > 1000)
        Stats->Energy = 1000;
    if (Stats->Regeneration > 1000)
        Stats->Regeneration = 1000;
    if (Stats->Agility > 1000)
        Stats->Agility = 1000;
    if (Stats->Capacity > 1000)
        Stats->Capacity = 1000;
    if (Stats->Luck > 1000)
        Stats->Luck = 1000;
};

function int CalculateMonsterThreatLevel(MonsterStatsPtr Stats)
{
    int Threat;
    
    // Stats
    Threat += Stats->Strength;
    Threat += Stats->Defense;
    Threat += Stats->Vitality;
    Threat += Stats->Energy;
    Threat += Stats->Regeneration;
    Threat += Stats->Agility;
    Threat += Stats->Capacity;
    Threat += Stats->Luck;
    Threat /= 800;
    
    // Auras
    if (Stats->Aura > 0 && Stats->Aura < 9) // Normal Auras
        Threat++
    else if (Stats->Aura == 10) // Black Aura
        Threat += 2;
    
    // Bosses
    if (CheckFlag(0, "BOSS"))
        Threat++;
    
    // DRLA
    if (GetCVar("drpg_ext_doomrl"))
    {
        str Actor = GetActorClass(0);
        
        for (int i = 0; i < MAX_DEF_MONSTERS_DRLA; i++)
        {
            MonsterInfoPtr MonsterIterPtr = &MonsterDataDRLA[i];
            
            if (StartsWith(Actor, MonsterIterPtr->Actor))
            {
                Threat += MonsterIterPtr->ThreatLevel;
                break;
            };
        };
    };
    
    // Cap
    if (Threat > 10)
        Threat = 10;
    
    return Threat;
};

function int CalculateMonsterMaxHealth(MonsterStatsPtr Stats)
{
    long int Health = Stats->SpawnHealth;
    long int HealthAddition = Stats->SpawnHealth * 9;
    
    HealthAddition *= Stats->Vitality;
    HealthAddition /= 1000;
    
    Health += HealthAddition;
    
    return Health;
};

function fixed CalculateMonsterSpeed(MonsterStatsPtr Stats)
{
    fixed Speed = (fixed)Stats->Speed;
    
    Speed *= 1.0 + ((fixed)Stats->Agility / 1000.0);
    
    return Speed;
};

// For Debugging
acscript void OutputMonsters()
{
    for (int i = 1; i < MonsterID; i++)
    {
        Log("\cdMonster %d:\n", i);
        Output Monsters[i];
    };
};
