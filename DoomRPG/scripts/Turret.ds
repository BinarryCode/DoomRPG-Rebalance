#include "RPG.dh"

#include "Crate.dh"
#include "Stims.dh"
#include "Turret.dh"
#include "Utils.dh"

AddressSpace MapArray TurretSpace;

TurretSpace TurretUpgrade[MAX_UPGRADES] TurretUpgradeData =
{
    // Build
    {
        "Build Turret"; 1; 0;
        "Build the portable turret";
        "";
        "Issuing this command will enable or disable the turret";
    };
    
    // --------------------------------------------------
    // Weapons
    // 
    
    // Bullet
    {
        "Weapon Module - Bullet"; 1; 0;
        "The turret is able to fire rapid-fire low-damage bullets";
        "";
        "Issuing this command will load the bullet weapon module, issuing this command while the weapon is already loaded will insert bullets";
    };
    {
        "Weapon Module - Bullet - Damage"; 10; 0;
        "Increases the damage of the turret's bullets";
    };
    {
        "Weapon Module - Bullet - Capacity"; 10; 0;
        "Increases the storage capacity of bullets the turret can hold";
    };
    {
        "Weapon Module - Bullet - Rate of Fire"; 5; 0;
        "Increases the fire rate of the turret's bullets";
    };
    
    // Pellet
    {
        "Weapon Module - Pellet"; 1; 0;
        "The turret is able to fire shotgun-like pellet spread shots";
        "";
        "Issuing this command will load the pellet weapon module, issuing this command while the weapon is already loaded will insert pellets";
    };
    {
        "Weapon Module - Pellet - Damage"; 10; 0;
        "Increases the damage of the turret's pellets";
    };
    {
        "Weapon Module - Pellet - Capacity"; 10; 0;
        "Increases the storage capacity of shells the turret can hold";
    };
    {
        "Weapon Module - Pellet - Rate of Fire"; 5; 0;
        "Increases the fire rate of the turret's pellets";
    };
    {
        "Weapon Module - Pellet - Spread"; 5; 0;
        "Decreases the spread of the pellets fired";
    };
    {
        "Weapon Module - Pellet - Amount"; 10; 0;
        "Increases the number of pellets fired per shot";
    };
    
    // Rocket
    {
        "Weapon Module - Rocket"; 1; 0;
        "The turret is able to fire explosive rockets";
        "";
        "Issuing this command will load the rocket weapon module, issuing this command while the weapon is already loaded will insert rockets";
    };
    {
        "Weapon Module - Rocket - Damage"; 10; 0;
        "Increases the damage of the turret's rockets";
    };
    {
        "Weapon Module - Rocket - Capacity"; 10; 0;
        "Increases the storage capacity of rockets the turret can hold";
    };
    {
        "Weapon Module - Rocket - Rate of Fire"; 5; 0;
        "Increases the fire rate of the turret's rockets";
    };
    {
        "Weapon Module - Rocket - Seeking"; 5; 0;
        "Allows fired rockets to seek targets";
    };
    
    // Plasma
    {
        "Weapon Module - Plasma"; 1; 0;
        "The turret is able to fire superheated balls of plasma";
        "";
        "Issuing this command will load the plasma weapon module, issuing this command while the weapon is already loaded will insert cells";
    };
    {
        "Weapon Module - Plasma - Damage"; 10; 0;
        "Increases the damage of the turret's plasma shots";
    };
    {
        "Weapon Module - Plasma - Capacity"; 10; 0;
        "Increases the storage capacity of cells used for plasma the turret can hold";
    };
    {
        "Weapon Module - Plasma - Rate of Fire"; 5; 0;
        "Increases the fire rate of the turret's plasma shots";
    };
    
    // Railgun
    {
        "Weapon Module - Railgun"; 1; 0;
        "The turret is able to fire piercing railgun shots";
        "";
        "Issuing this command will load the railgun weapon module, issuing this command while the weapon is already loaded will insert cells";
    };
    {
        "Weapon Module - Railgun - Damage"; 10; 0;
        "Increases the damage of the turret's railgun shots";
    };
    {
        "Weapon Module - Railgun - Capacity"; 10; 0;
        "Increases the storage capacity of cells used for the railgun the turret can hold";
    };
    {
        "Weapon Module - Railgun - Rate of Fire"; 5; 0;
        "Increases the fire rate of the turret's railgun shots";
    };
    {
        "Weapon Module - Railgun - Piercing"; 1; 0;
        "Allows the railgun to pierce through targets";
    };
    
    // Ammo
    {
        "Ammo Module - Autoloader"; 1; 0;
        "Autoloads ammo if it runs out from your own ammo pool";
        "";
        "issuing this command will toggle autoloading on and off";
    };
    {
        "Ammo Module - Nano-Generators"; 10; 0;
        "Allows the turret to slowly generate it's own ammo supplies";
        "Upgrades increase generation speed";
    };
    {
        "Ammo Module - Nano-Generators - Bullets"; 1; 0;
        "Allows the turret to slowly generate bullets";
    };
    {
        "Ammo Module - Nano-Generators - Shells"; 1; 0;
        "Allows the turret to slowly generate shells";
    };
    {
        "Ammo Module - Nano-Generators - Rockets"; 1; 0;
        "Allows the turret to slowly generate rockets";
    };
    {
        "Ammo Module - Nano-Generators - Cells"; 1; 0;
        "Allows the turret to slowly generate cells";
    };
    
    // Special/Unique Weapons
    {
        "Special Weapon Module - Self-Destruct"; 10; 0;
        "Destroys the turret, but creates a devastating explosion";
        "Upgrades increase explosion radius and damage";
        "Issuing this command will trigger the self-destruct sequence";
    };
    
    // --------------------------------------------------
    // Armor
    // 
    
    // Plating
    {
        "Armor Plating - Reinforcement"; 10; 0;
        "Reinforce the plating of the turret, allowing it to take more damage";
        "Upgrades Increase the maximum health of the turret";
    };
    {
        "Armor Plating - Melee"; 10; 0;
        "Plating which protects against melee damage";
        "Upgrades increase protection amount";
    };
    {
        "Armor Plating - Bullet"; 10; 0;
        "Plating which protects against bullet damage";
        "Upgrades increase protection amount";
    };
    {
        "Armor Plating - Fire"; 10; 0;
        "Plating which protects against fire damage";
        "Upgrades increase protection amount";
    };
    {
        "Armor Plating - Plasma"; 10; 0;
        "Plating which protects against plasma damage";
        "Upgrades increase protection amount";
    };
    {
        "Armor Plating - Blast"; 1; 0;
        "Plating which protects against blast damage";
    };
    
    // Modules
    {
        "Armor Module - Projectile Reflection"; 3; 0;
        "Reflects projectiles fired at the turret";
        "Upgrades improve the abilities of the reflection";
    };
    {
        "Armor Module - Repair Nanites"; 10; 0;
        "Slowly Repairs the health of the turret";
        "Upgrades increase repair speed";
    };
    {
        "Armor Module - Phase Inverter"; 10; 0;
        "Randomly shifts the turret in and out of visibility";
        "Upgrades increase the time that the turret can stay invisible";
    };
    
    // --------------------------------------------------
    // Assist
    // 
    
    {
        "Assist Module - Health Injector"; 10; 0;
        "Injects you with some health if you are near death";
        "Upgrades increase injection cutoff percentage";
    };
    {
        "Assist Module - Armor Repair Nanites"; 10; 0;
        "Slowly repairs your armor";
        "Upgrades increase repair speed";
    };
    {
        "Assist Module - Augmentation Charge Transfer Bus"; 10; 0;
        "Slowly recharges your augmentation battery";
        "Upgrades increase charge speed";
    };
    {
        "Assist Module - Shield Charge Transfer Bus"; 10; 0;
        "Slowly recharges your shield";
        "Upgrades increase charge speed";
    };
    {
        "Assist Module - Stim Injector"; 1; 0;
        "Turret can inject you with a random cocktail of combat-enhancing drugs";
        "";
        ""; // Generated in BuildTurretData()
    };
    {
        "Assist Module - Stim Injector - Type"; 2; 0;
        "Determines the type of drugs you will be injected with";
        "Upgrade allows powerups to be injected";
    };
    {
        "Assist Module - Stim Injector - Amount"; 10; 0;
        "Determines the amount of drugs you will be injected with";
    };
    {
        "Assist Module - Stim Injector - Potency"; 10; 0;
        "Determines the potency of the drugs you will be injected with";
    };
    {
        "Assist Module - Emergency Teleportation System"; 1; 0;
        "The turret will automatically teleport you out of danger when under 10% health";
        "";
        "Issuing this command will toggle Emergency Teleportation on/off";
    };
    {
        "Assist Module - Team Unit"; 10; 0;
        "Allows other assist modules to be used on teammates around you";
        "Upgrades increase assistance range";
    };
    
    // --------------------------------------------------
    // Sensors
    // 
    
    {
        "Sensors - Calibration Speed"; 10; 0;
        "Increases the speed and reliability of the turret's sensors";
        "Upgrades increase the speed of all sensor-based activities";
    };
    
    // Module Finder
    {
        "Sensors Module - Module Finder"; 1; 0;
        "Calibrates the sensors to allow the turret to find upgrade modules";
        "";
        "Issuing this command will start the item finder, searching for upgrade modules";
    };
    
    // Item Finder
    {
        "Sensors Module - Item Finder"; 1; 0;
        "Calibrates the sensors to allow the turret to find different types of items";
        "";
        "Issuing this command will have the turret scout the map and allow you to locate items";
    };
    
    // Crate Finder
    {
        "Sensors Module - Supply Drop Crate Finder"; 1; 0;
        "Calibrates the sensors to allow the turret to find UAC Supply Crates";
        "";
        "Issuing this command will have the turret scout the map and allow you to locate supply crates";
    };
    
    // --------------------------------------------------
    // Commands
    // 
    
    {
        "Command Module - Idle"; 1; 0;
        "Allows you to command the turret to wait at it's current location";
        "";
        "Issuing this command will tell the turret to wait";
    };
    {
        "Command Module - Wander"; 1; 0;
        "Allows you to command the turret to wander around it's current location";
        "";
        "Issuing this command will tell the turret to wander";
    };
    {
        "Command Module - Orbit"; 1; 0;
        "Allows you to command the turret to orbit around your location";
        "";
        "Issuing this command will tell the turret to orbit";
    };
    {
        "Command Module - Target"; 1; 0;
        "Allows you to command the turret to attack your current target";
        "";
        "Issuing this command will tell the turret to attack your current target";
    };
    {
        "Command Module - Control"; 1; 0;
        "Allows you to remotely control the turret";
        "";
        "Issuing this command will switch your control over to the turret";
    };

    // --------------------------------------------------
    // Battery
    // 
    
    {
        "Battery - Capacity"; 10; 0;
        "Increases the capacity of the turret's battery";
        "Upgrades increase maximum battery capacity";
    };
    
    // Generators
    {
        "Generator - Kinetic"; 10; 0;
        "Charges the turret's battery based on movement";
        "Upgrades decrease interval between charges";
    };
    {
        "Generator - Illumination"; 10; 0;
        "Charges the turret's battery based on light level";
        "Upgrades decrease interval between charges";
    };
    {
        "Generator - Force"; 10; 0;
        "Charges the turret's battery from bullet and melee based damage";
        "Upgrades increase charge amount when recieving this kind of damage";
    };
    {
        "Generator - Thermal"; 10; 0;
        "Charges the turret's battery from fire based damage";
        "Upgrades increase charge amount when recieving this kind of damage";
    };
    {
        "Generator - Plasma"; 10; 0;
        "Charges the turret's battery from plasma based damage";
        "Upgrades increase charge amount when recieving this kind of damage";
    };
    {
        "Generator - Nuclear"; 10; 0;
        "Charges the turret's battery from toxicity and radiation based damage";
        "Upgrades increase charge amount when recieving this kind of damage";
    };
    
    // --------------------------------------------------
    // Hardware
    // 
    
    {
        "Hardware - Battery Charge Bus"; 10; 0;
        "Decreases the time it takes for the turret's battery to be recharged when sent back to the Outpost";
        "Upgrades decrease charging time when in maintenance";
    };
    {
        "Hardware - Build Quality"; 10; 0;
        "Decreases the parts it takes to repair the turret";
        "Upgrades decrease the turret parts necessary for repair when in maintenance";
    };
    {
        "Hardware - Parts Optimization"; 10; 0;
        "Decreases the time it takes to repair the turret";
        "Upgrades decrease repair time when in maintenance";
    };
    {
        "Hardware - Specification Optimization"; 10; 0;
        "Decreases the time it takes to upgrade and refit the turret";
        "Upgrades decrease refit time when in maintenance";
    };
    {
        "Hardware - Expert Fabrication"; 10; 0;
        "Decreases the cost of maintenance";
        "Upgrades decrease cash flow required when in maintenance";
    };
};

script void TurretLoop() enter
{
    // Level Entry - Spawn Turret if it's active
    if (Player.Turret.Init && Player.Turret.Active)
    {
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: \c-Turret was active, Respawning...\n");
        TurretSpawn();
    };
    
    Start:
    
    int PlayerNum = PlayerNumber();
    int Health;
    int PrevHealth;
    
    if (Player.Turret.Upgrade[TU_BUILD] && !Player.Turret.Init)
    {
        // Initial Battery Charge
        Player.Turret.Battery = TURRET_BATTERY_CHARGE;
        
        // Nametag
        SetActorPropertyString(Player.Turret.TID, APROP_Nametag, StrParam("%N\c-'s Turret\n", PlayerNumber() + 1));
        
        // Initial levels
        Player.Turret.Upgrade[TU_WEAPON_BULLET_CAPACITY] = 1;
        Player.Turret.Upgrade[TU_WEAPON_PELLET_CAPACITY] = 1;
        Player.Turret.Upgrade[TU_WEAPON_ROCKET_CAPACITY] = 1;
        Player.Turret.Upgrade[TU_WEAPON_PLASMA_CAPACITY] = 1;
        Player.Turret.Upgrade[TU_WEAPON_RAILGUN_CAPACITY] = 1;
        Player.Turret.Upgrade[TU_ARMOR_PLATING] = 1;
        Player.Turret.Upgrade[TU_BATTERY_CAPACITY] = 1;
        
        // Reset the current weapon
        Player.Turret.Weapon = TW_NONE;
        
        // Set Active and TID
        Player.Turret.Init = true;
        Player.Turret.Active = true;
        
        // Spawn the Turret
        TurretSpawn();
    };
    
    while (Player.Turret.Active)
    {
        // Pre-health check
        Health = GetActorProperty(Player.Turret.TID, APROP_Health);
        
        // Despawn the turret if itself or the owning player dies
        if (GetActorProperty(Player.TID, APROP_Health) <= 0 || GetActorProperty(Player.Turret.TID, APROP_Health) <= 0)
            TurretDespawn();
        
        // Temporary Ceiling checking rotationy thing
        if (GetActorCeilingZ(Player.TID) - GetActorZ(Player.TID) <= 80)
        {
            Player.Turret.AngleOffset += 0.01;
            Player.Turret.DistanceOffset = 24;
            Player.Turret.HeightOffset = -48;
        }
        else
        {
            Player.Turret.AngleOffset = 0;
            Player.Turret.DistanceOffset = 0;
            Player.Turret.HeightOffset = 0;
        };
        
        // Offset
        fixed Angle = GetActorAngle(0) + Player.Turret.AngleOffset;
        fixed X = GetActorX(0) + Cos(Angle) * Player.Turret.DistanceOffset;
        fixed Y = GetActorY(0) + Sin(Angle) * Player.Turret.DistanceOffset;
        fixed Z = GetActorZ(0) + GetActorPropertyFixed(Player.TID, APROP_Height) + Player.Turret.HeightOffset;
        
        // Set Position
        if (!Player.Turret.SelfDestruct && !Player.Turret.SensorsActive)
            SetActorPosition(Player.Turret.TID, X, Y, Z, false);
        
        // Battery is drained
        if (Player.Turret.Battery <= 0)
            TurretDespawn();
        
        // Totals which need to be kept updated
        Player.Turret.HealthMax = 100 * Player.Turret.Upgrade[TU_ARMOR_PLATING];
        Player.Turret.BulletAmmoMax = 200 * Player.Turret.Upgrade[TU_WEAPON_BULLET_CAPACITY];
        Player.Turret.ShellAmmoMax = 50 * Player.Turret.Upgrade[TU_WEAPON_PELLET_CAPACITY];
        Player.Turret.RocketAmmoMax = 50 * Player.Turret.Upgrade[TU_WEAPON_ROCKET_CAPACITY];
        Player.Turret.PlasmaAmmoMax = 300 * Player.Turret.Upgrade[TU_WEAPON_PLASMA_CAPACITY];
        Player.Turret.RailAmmoMax = 10 * Player.Turret.Upgrade[TU_WEAPON_RAILGUN_CAPACITY];
        Player.Turret.BatteryMax = TURRET_BATTERY_CHARGE * Player.Turret.Upgrade[TU_BATTERY_CAPACITY];
        
        // Autoloader
        if (Player.Turret.Upgrade[TU_AMMO_AUTOLOADER] && Player.Turret.Autoload)
        {
            if (Player.Turret.BulletAmmo <= 0)
                TurretLoadAmmo(TU_WEAPON_BULLET);
            if (Player.Turret.ShellAmmo <= 0)
                TurretLoadAmmo(TU_WEAPON_PELLET);
            if (Player.Turret.RocketAmmo <= 0)
                TurretLoadAmmo(TU_WEAPON_ROCKET);
            if (Player.Turret.PlasmaAmmo <= 0)
                TurretLoadAmmo(TU_WEAPON_PLASMA);
            if (Player.Turret.RailAmmo <= 0)
                TurretLoadAmmo(TU_WEAPON_RAILGUN);
        };
        
        // Nano Ammo Generators
        if (Player.Turret.Upgrade[TU_AMMO_NANOGEN] > 0 && (Timer() % (35 * (15 - Player.Turret.Upgrade[TU_AMMO_NANOGEN]))) == 0)
        {
            if (Player.Turret.Upgrade[TU_AMMO_NANOGEN_BULLET] && Player.Turret.BulletAmmo < Player.Turret.BulletAmmoMax)
                Player.Turret.BulletAmmo += 10;
            if (Player.Turret.Upgrade[TU_AMMO_NANOGEN_SHELL] && Player.Turret.ShellAmmo < Player.Turret.ShellAmmoMax)
                Player.Turret.ShellAmmo += 4;
            if (Player.Turret.Upgrade[TU_AMMO_NANOGEN_ROCKET] && Player.Turret.RocketAmmo < Player.Turret.RocketAmmoMax)
                Player.Turret.RocketAmmo++;
            if (Player.Turret.Upgrade[TU_AMMO_NANOGEN_CELL] && Player.Turret.PlasmaAmmo < Player.Turret.PlasmaAmmoMax)
                Player.Turret.PlasmaAmmo += 20;
            if (Player.Turret.Upgrade[TU_AMMO_NANOGEN_CELL] && Player.Turret.RailAmmo < Player.Turret.RailAmmoMax)
                Player.Turret.RailAmmo++;
        };
        
        // Armor/Protection
        if (Player.Turret.Upgrade[TU_ARMOR_PLATING_MELEE] > 0)
            GiveActorInventory(Player.Turret.TID, StrParam("DRPGTurretProtectionMelee%d\n", Player.Turret.Upgrade[TU_ARMOR_PLATING_MELEE]), 1);
        if (Player.Turret.Upgrade[TU_ARMOR_PLATING_BULLET] > 0)
            GiveActorInventory(Player.Turret.TID, StrParam("DRPGTurretProtectionBullet%d\n", Player.Turret.Upgrade[TU_ARMOR_PLATING_BULLET]), 1);
        if (Player.Turret.Upgrade[TU_ARMOR_PLATING_FIRE] > 0)
            GiveActorInventory(Player.Turret.TID, StrParam("DRPGTurretProtectionFire%d\n", Player.Turret.Upgrade[TU_ARMOR_PLATING_FIRE]), 1);
        if (Player.Turret.Upgrade[TU_ARMOR_PLATING_PLASMA] > 0)
            GiveActorInventory(Player.Turret.TID, StrParam("DRPGTurretProtectionPlasma%d\n", Player.Turret.Upgrade[TU_ARMOR_PLATING_PLASMA]), 1);
        if (Player.Turret.Upgrade[TU_ARMOR_PLATING_BLAST] > 0)
            GiveActorInventory(Player.Turret.TID, "DRPGTurretProtectionBlast", 1);
        if (Player.Turret.Upgrade[TU_ARMOR_MODULE_REFLECT] > 0)
            GiveActorInventory(Player.Turret.TID, StrParam("DRPGTurretReflection%d\n", Player.Turret.Upgrade[TU_ARMOR_MODULE_REFLECT]), 1);
        if (Player.Turret.Upgrade[TU_ARMOR_MODULE_REPAIR] > 0)
            if (Health < Player.Turret.HealthMax && (Timer() % (35 * (30 - (Player.Turret.Upgrade[TU_ARMOR_MODULE_REPAIR] * 2.5)))) == 0)
                SetActorProperty(Player.Turret.TID, APROP_Health, Health + 1);
        if (Player.Turret.Upgrade[TU_ARMOR_MODULE_PHASE] > 0 && Health < PrevHealth)
            GiveActorInventory(Player.Turret.TID, StrParam("DRPGTurretPhase%d\n", Player.Turret.Upgrade[TU_ARMOR_MODULE_PHASE]), 1);
        if (GetActorPowerupTics(Player.Turret.TID, "PowerGhost") > 0)
        {
            SetActorProperty(Player.Turret.TID, APROP_RenderStyle, STYLE_Translucent);
            SetActorPropertyFixed(Player.Turret.TID, APROP_Alpha, 0.5 + (Sin(Timer() / 32.0) * 0.5));
        }
        else
        {
            SetActorProperty(Player.Turret.TID, APROP_RenderStyle, STYLE_Normal);
            SetActorPropertyFixed(Player.Turret.TID, APROP_Alpha, 1.0);
        };
        
        // Assist Modules
        if (Player.Turret.HitTimer <= 0)
            for (int i = 0; i < MAX_PLAYERS; i++)
            {
                // If this player isn't in game, continue
                if (!PlayerInGame(i)) continue;
                
                // If you don't have the Team Unit upgrade yet, skip all other players
                if (!Player.Turret.Upgrade[TU_ASSIST_TEAM] && i != PlayerNumber()) continue;
                
                // Apply to teammates around you if you have the Team Unit upgrade
                if (i != PlayerNumber() && Player.Turret.Upgrade[TU_ASSIST_TEAM] > 0 && Distance(Player.Turret.TID, Players(i).TID) >= Player.Turret.Upgrade[TU_ASSIST_TEAM] * 256) continue;
                
                // Health
                if (Player.Turret.Upgrade[TU_ASSIST_HEALTH] > 0 && CalcPercent(Players(i).ActualHealth, Players(i).HealthMax) < Player.Turret.Upgrade[TU_ASSIST_HEALTH] * 2 && ((Timer() + 8) % 35) == 0)
                {
                    for (fixed j = 0.0; j <= 1.0; j += 0.01)
                    {
                        fixed X = Lerp(GetActorX(Players(PlayerNum).Turret.TID), GetActorX(Players(i).TID), j);
                        fixed Y = Lerp(GetActorY(Players(PlayerNum).Turret.TID), GetActorY(Players(i).TID), j);
                        fixed Z = Lerp(GetActorZ(Players(PlayerNum).Turret.TID), GetActorZ(Players(i).TID) + 32.0, j);
                        SpawnForced("DRPGTurretParticleAssistHealth", X, Y, Z, 0, 0);
                    };
                    
                    Players(i).ActualHealth++;
                };
                
                // Armor
                SetActivator(Players(i).TID); // Yay maxhax because GetArmorInfo() has no playernum param D:
                if (Players(PlayerNum).Turret.Upgrade[TU_ASSIST_ARMOR] > 0 && CheckInventory("Armor") > 0 && CheckInventory("Armor") < GetArmorInfo(ARMORINFO_ACTUALSAVEAMOUNT) && ((Timer() + 35) % (35 * (30 - (Players(PlayerNum).Turret.Upgrade[TU_ASSIST_ARMOR] * 2.5)))) == 0)
                {
                    for (fixed j = 0.0; j <= 1.0; j += 0.01)
                    {
                        fixed X = Lerp(GetActorX(Players(PlayerNum).Turret.TID), GetActorX(Players(i).TID), j);
                        fixed Y = Lerp(GetActorY(Players(PlayerNum).Turret.TID), GetActorY(Players(i).TID), j);
                        fixed Z = Lerp(GetActorZ(Players(PlayerNum).Turret.TID), GetActorZ(Players(i).TID) + 32.0, j);
                        SpawnForced("DRPGTurretParticleAssistArmor", X, Y, Z, 0, 0);
                    };
                    
                    GiveInventory("ArmorBonus", 1);
                };
                SetActivator(Players(PlayerNum).TID);
                
                // Aug Battery
                if (Player.Turret.Upgrade[TU_ASSIST_AUG] > 0 && Players(i).Augs.Battery < Players(i).Augs.BatteryMax && ((Timer() + 26) % (35 * (30 - (Player.Turret.Upgrade[TU_ASSIST_AUG] * 2.5)))) == 0)
                {
                    for (fixed j = 0.0; j <= 1.0; j += 0.01)
                    {
                        fixed X = Lerp(GetActorX(Players(PlayerNum).Turret.TID), GetActorX(Players(i).TID), j);
                        fixed Y = Lerp(GetActorY(Players(PlayerNum).Turret.TID), GetActorY(Players(i).TID), j);
                        fixed Z = Lerp(GetActorZ(Players(PlayerNum).Turret.TID), GetActorZ(Players(i).TID) + 32.0, j);
                        SpawnForced("DRPGTurretParticleAssistAug", X, Y, Z, 0, 0);
                    };
                    
                    Players(i).Augs.Battery++;
                };
                
                // Shield
                if (Player.Turret.Upgrade[TU_ASSIST_SHIELD] > 0 && Players(i).Shield.Active && Players(i).Shield.Charge < Players(i).Shield.Capacity && ((Timer() + 17) % (35 * (30 - (Player.Turret.Upgrade[TU_ASSIST_SHIELD] * 2.5)))) == 0)
                {
                    for (fixed j = 0.0; j <= 1.0; j += 0.01)
                    {
                        fixed X = Lerp(GetActorX(Players(PlayerNum).Turret.TID), GetActorX(Players(i).TID), j);
                        fixed Y = Lerp(GetActorY(Players(PlayerNum).Turret.TID), GetActorY(Players(i).TID), j);
                        fixed Z = Lerp(GetActorZ(Players(PlayerNum).Turret.TID), GetActorZ(Players(i).TID) + 32.0, j);
                        SpawnForced("DRPGTurretParticleAssistShield", X, Y, Z, 0, 0);
                    };
                    
                    Players(i).Shield.Charge += Players(i).Shield.ChargeRate;
                };
            };
        
        // Emergency Teleport
        if (Player.Turret.TeleportEnabled && CalcPercent(Player.ActualHealth, Player.HealthMax) <= 10 && Player.Turret.TeleportTimer <= 0)
        {
            SetInventory("ArtiTeleport", 1);
            UseInventory("ArtiTeleport");
            
            Player.Turret.TeleportTimer = 35 * 30;
        };
        
        // Generators
        if (Player.Turret.HitTimer <= 0)
        {
            if (Player.Turret.Upgrade[TU_BATTERY_GENERATOR_KINETIC] > 0 && IsPlayerMoving() && (Timer() % (35 * (11 - Player.Turret.Upgrade[TU_BATTERY_GENERATOR_KINETIC]))) == 0)
                Player.Turret.Battery++;
            if (Player.Turret.Upgrade[TU_BATTERY_GENERATOR_ILLUMINATION] > 0 && GetActorLightLevel(Player.Turret.TID) >= 192 && (Timer() % (35 * (11 - Player.Turret.Upgrade[TU_BATTERY_GENERATOR_ILLUMINATION]))) == 0)
                Player.Turret.Battery++;
            
            // Damage-based Generators
            if (Health < PrevHealth)
            {
                if (Player.Turret.Upgrade[TU_BATTERY_GENERATOR_FORCE] > 0 && GetUserVariable(Player.Turret.TID, "user_damage_type") == DT_NORMAL)
                    Player.Turret.Battery += Player.Turret.Upgrade[TU_BATTERY_GENERATOR_FORCE];
                if (Player.Turret.Upgrade[TU_BATTERY_GENERATOR_FORCE] > 0 && GetUserVariable(Player.Turret.TID, "user_damage_type") == DT_MELEE)
                    Player.Turret.Battery += Player.Turret.Upgrade[TU_BATTERY_GENERATOR_FORCE];
                if (Player.Turret.Upgrade[TU_BATTERY_GENERATOR_THERMAL] > 0 && GetUserVariable(Player.Turret.TID, "user_damage_type") == DT_FIRE)
                    Player.Turret.Battery += Player.Turret.Upgrade[TU_BATTERY_GENERATOR_THERMAL];
                if (Player.Turret.Upgrade[TU_BATTERY_GENERATOR_PLASMA] > 0 && GetUserVariable(Player.Turret.TID, "user_damage_type") == DT_PLASMA)
                    Player.Turret.Battery += Player.Turret.Upgrade[TU_BATTERY_GENERATOR_PLASMA];
                if (Player.Turret.Upgrade[TU_BATTERY_GENERATOR_PLASMA] > 0 && GetUserVariable(Player.Turret.TID, "user_damage_type") == DT_LIGHTNING)
                    Player.Turret.Battery += Player.Turret.Upgrade[TU_BATTERY_GENERATOR_PLASMA];
                if (Player.Turret.Upgrade[TU_BATTERY_GENERATOR_NUCLEAR] > 0 && GetUserVariable(Player.Turret.TID, "user_damage_type") == DT_TOXIC)
                    Player.Turret.Battery += Player.Turret.Upgrade[TU_BATTERY_GENERATOR_NUCLEAR];
                if (Player.Turret.Upgrade[TU_BATTERY_GENERATOR_NUCLEAR] > 0 && GetUserVariable(Player.Turret.TID, "user_damage_type") == DT_RADIATION)  
                    Player.Turret.Battery += Player.Turret.Upgrade[TU_BATTERY_GENERATOR_NUCLEAR];
            };
        };
        
        // Timers
        if (Health < PrevHealth && GetUserVariable(Player.Turret.TID, "user_damage_type") != DT_TOXIC && GetUserVariable(Player.Turret.TID, "user_damage_type") != DT_RADIATION)
            Player.Turret.HitTimer = 35 * 5;
        if (Player.Turret.HitTimer > 0)
            Player.Turret.HitTimer--;
        if (Player.Turret.TeleportTimer > 0)
            Player.Turret.TeleportTimer--;
        
        // Drain Battery
        if (Player.Turret.Battery > 0 && (Timer() % 35) == 0)
            Player.Turret.Battery--;
        
        // Prevent battery overflow
        if (Player.Turret.Battery > Player.Turret.BatteryMax)
            Player.Turret.Battery = Player.Turret.BatteryMax;
        
        // Pass info to uservars
        TurretPassVars();
        
        // Draw Sensors progress bar
        if (Player.Turret.SensorsActive)
        {
            if (Player.Turret.SensorMode == TSM_MODULES)
                DrawProgressBar("\cdFinding Modules", Player.Turret.SensorPercent);
            if (Player.Turret.SensorMode == TSM_ITEMS)
                DrawProgressBar("\cjFinding Items", Player.Turret.SensorPercent);
            if (Player.Turret.SensorMode == TSM_CRATE)
                DrawProgressBar("\ccFinding Supply Drops", Player.Turret.SensorPercent);
        };
        
        // Sensor item tracing beam
        TurretItemSensorThink();
        
        // Sensor crate tracing beam
        TurretCrateSensorThink();
        
        // Reset damage type
        SetUserVariable(Player.Turret.TID, "user_damage_type", DT_NONE);
        
        // Turret was destroyed
        if (Health - PrevHealth < 0 && GetUserVariable(Player.Turret.TID, "user_damage_type") != DT_NONE)
            Player.Turret.Destroyed = true;
        
        Delay(1);
        
        // Post-health check
        PrevHealth = Health;
        Player.Turret.Health = Health;
    };
    
    Delay(1);
    goto Start;
};

script void TurretLoopMaintenance() enter
{
    bool CanRepair = true;
    int RepairMod = 0;
    
    Start:
    
    // Calculate Timers
    Player.Turret.ChargeTimer = Player.Turret.BatteryMax - Player.Turret.Battery;
    Player.Turret.RepairTimer = Player.Turret.HealthMax - Player.Turret.Health;
    
    // No Credits for payment
    if (Player.Turret.Maintenance && !CheckInventory("DRPGCredits"))
    {
        Player.Turret.Maintenance = false;
        ActivatorSound("menu/error", 127);
    };
    
    // Maintenance
    if (Player.Turret.Maintenance)
    {
        // Charging
        if ((Timer() % (35 - (Player.Turret.Upgrade[TU_HARDWARE_BATTERY] * 3))) == 0)
            if (Player.Turret.ChargeTimer > 0)
            {
                Player.Turret.Battery++;
                
                // Done
                if (Player.Turret.Battery >= Player.Turret.BatteryMax)
                    ActivatorSound("turret/chargedone", 127);
            };
        
        // Repairing
        if ((Timer() % (35 - (Player.Turret.Upgrade[TU_HARDWARE_PART] * 3))) == 0)
        {
            RepairMod = 10 - Player.Turret.Upgrade[TU_HARDWARE_BUILD];
            if (RepairMod > 0 && !CheckInventory("DRPGTurretPart"))
                CanRepair = false
            else
                CanRepair = true;
            if (CanRepair)
            {
                if (Player.Turret.RepairTimer > 0)
                {
                    if (RepairMod > 0 && (Player.Turret.RepairTimer % 10) == 0)
                        TakeInventory("DRPGTurretPart", 1);
                    
                    Player.Turret.Health++;
                    
                    // Done
                    if (Player.Turret.Health >= Player.Turret.HealthMax)
                        ActivatorSound("turret/repairdone", 127);
                };
            };
        };
        
        // Refitting
        if ((Timer() % (35 - (Player.Turret.Upgrade[TU_HARDWARE_SPECS] * 3))) == 0)
            if (Player.Turret.RefitTimer > 0)
            {
                Player.Turret.RefitTimer--;
                
                // Done
                if (Player.Turret.RefitTimer <= 0)
                    ActivatorSound("turret/refitdone", 127);
            };
        
        // Steady credit loss while maintenance is happening
        if ((Player.Turret.ChargeTimer > 0 || (CanRepair && Player.Turret.RepairTimer > 0) || Player.Turret.RefitTimer > 0) && (Timer() % (1 + Player.Turret.Upgrade[TU_HARDWARE_FABRICATION])) == 0)
            TakeInventory("DRPGCredits", 1);
    };
    
    // Maintenance is done
    if (Player.Turret.Maintenance && Player.Turret.ChargeTimer <= 0 && Player.Turret.RepairTimer <= 0 && Player.Turret.RefitTimer <= 0)
    {
        Player.Turret.Maintenance = false;
        ActivatorSound("turret/maintenancedone", 127);
        
        if (Player.Turret.Destroyed)
            Player.Turret.Destroyed = false;
    };
    
    Delay(1);
    goto Start;
};

script void TurretSensors()
{
    bool Complete = false;
    int Current = 0;
    int Total = 0;
    
    Player.Turret.SensorsActive = true;
    
    Start:
    
    SetActorState(Player.Turret.TID, "Searching");
    
    if (Player.Turret.SensorMode == TSM_MODULES)
    {
        // Determine the total amount of existing module pickup
        for (int i = 0; ItemTIDs[i] != -1; i++)
            if (!StrCmp(GetActorClass(ItemTIDs[i]), "DRPGModulePickup"))
                Total++;
        
        while (Current < Total)
        {
            for (int i = 0; ItemTIDs[i] != -1; i++)
            {
                if (!StrCmp(GetActorClass(ItemTIDs[i]), "DRPGModulePickup"))
                {
                    SetActorPosition(Player.Turret.TID, GetActorX(ItemTIDs[i]), GetActorY(ItemTIDs[i]), GetActorZ(ItemTIDs[i]), true);
                    Player.Turret.ModulesCollected += GetUserVariable(ItemTIDs[i], "user_amount");
                    Thing_Remove(ItemTIDs[i]);
                    Current++;
                    break;
                };
            };
            
            Player.Turret.SensorPercent = (int)(((fixed)Current / (fixed)Total) * 100.0);
            Delay(33 - (Player.Turret.Upgrade[TU_SENSORS] * 3));
        };
        
        if (Total > 0)
        {
            ActivatorSound("items/module", 127);
            GiveInventory("DRPGModule", Player.Turret.ModulesCollected);
            Player.Turret.ModulesCollected = 0;
        };
        
        Complete = true;
    };
    
    if (Player.Turret.SensorMode == TSM_ITEMS)
    {
        // Create the sensor items array
        if (Player.Turret.SensorItemData.Array.Position > 0)
            ArrayDestroy(&Player.Turret.SensorItemData.Array);
        ArrayCreate(&Player.Turret.SensorItemData.Array, "SITM\x00", 64, sizeof(int));
        
        // Determine the total amount of items
        for (int i = 0; ItemTIDs[i] != -1; i++)
            if (ClassifyActor(ItemTIDs[i]) != ACTOR_NONE)
                Total++;
        
        for (int i = 0; ItemTIDs[i] != -1; i++)
        {
            // This item doesn't exist, skip it
            if (ClassifyActor(ItemTIDs[i]) == ACTOR_NONE) continue;
            
            // This item is credits, skip it
            if (Contains(GetActorClass(ItemTIDs[i]), "Credits")) continue;
            
            // Array has grown too big, resize it
            if (Player.Turret.SensorItemData.Array.Position == Player.Turret.SensorItemData.Array.Size)
                ArrayResize(&Player.Turret.SensorItemData.Array);
            
            // Add the item to the sensor items array
            ((int *)Player.Turret.SensorItemData.Array.Data)[Player.Turret.SensorItemData.Array.Position++] = ItemTIDs[i];
            
            SetActorPosition(Player.Turret.TID, GetActorX(ItemTIDs[i]), GetActorY(ItemTIDs[i]), GetActorZ(ItemTIDs[i]), true);
            Current++;
            
            Player.Turret.SensorPercent = (int)(((fixed)Current / (fixed)Total) * 100.0);
            Delay(33 - (Player.Turret.Upgrade[TU_SENSORS] * 3));
        };
        
        Player.Turret.SensorItemData.Enabled = true;
        Complete = true;
    };
    
    if (Player.Turret.SensorMode == TSM_CRATE)
    {
        // Create the sensor crates array
        if (Player.Turret.SensorCrateData.Array.Position > 0)
            ArrayDestroy(&Player.Turret.SensorCrateData.Array);
        ArrayCreate(&Player.Turret.SensorCrateData.Array, "SCRT\x00", 64, sizeof(int));
        
        Total = CrateID;
        
        for (int i = 0; i < CrateID; i++)
        {
            // Crate is empty, skip it
            if (Crates[i].Empty) continue;
            
            // Array has grown too big, resize it
            if (Player.Turret.SensorCrateData.Array.Position == Player.Turret.SensorCrateData.Array.Size)
                ArrayResize(&Player.Turret.SensorCrateData.Array);
            
            ((int *)Player.Turret.SensorCrateData.Array.Data)[Player.Turret.SensorCrateData.Array.Position++] = i;
            
            SetActorPosition(Player.Turret.TID, GetActorX(Crates[i].TID), GetActorY(Crates[i].TID), GetActorZ(Crates[i].TID), true);
            Current++;
            
            Player.Turret.SensorPercent = (int)(((fixed)Current / (fixed)Total) * 100.0);
            Delay(33 - (Player.Turret.Upgrade[TU_SENSORS] * 3));
        };
        
        Player.Turret.SensorCrateData.Enabled = true;
        Complete = true;
    };
    
    // Sensor operation complete
    if (Complete)
    {
        SetActorState(Player.Turret.TID, "See");
        Player.Turret.SensorMode = TSM_NONE;
        Player.Turret.SensorPercent = 0;
        Player.Turret.SensorsActive = false;
        return;
    };
    
    Delay(1);
    goto Start;
};

acscript void TurretInit()
{
    int TempTID = UniqueTID();
    int MasterTID = GetActorProperty(0, APROP_MasterTID);
    
    Thing_ChangeTID(0, TempTID);
    SetActivator(MasterTID);
    Thing_ChangeTID(TempTID, Player.Turret.TID);
    
    if (Player.Turret.Health > 0)
        SetActorProperty(Player.Turret.TID, APROP_Health, Player.Turret.Health);
    
    Player.Turret.Active = true;
};

acscript void TurretMenu()
{
    if (!GetCVar("drpg_debug")) return;
    
    if (Player.InMenu)
    {
        Player.InMenu = false;
        ActivatorSound("menu/leave", 127);
        SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
    }
    else
    {
        if (GetPlayerInput(PlayerNumber(), INPUT_BUTTONS) & BT_SPEED)
        {
            if (!Player.Turret.Init) return;
            
            if (Player.Turret.Active)
                TurretDespawn()
            else
                TurretSpawn();
        }
        else
        {
            Player.InMenu = true;
            Player.InShop = false;
            Player.OutpostMenu = 0;
            Player.Menu = MENUPAGE_TURRET;
            Player.TurretPage = TURRETPAGE_COMMAND;
            ActivatorSound("menu/enter", 127);
        };
    };
};

acscript void TurretSetOffset(int AngleOffset, int DistanceOffset, int HeightOffset)
{
    Player.Turret.AngleOffset += (fixed)AngleOffset / 100.0;
    Player.Turret.DistanceOffset += (fixed)DistanceOffset;
    Player.Turret.HeightOffset += (fixed)HeightOffset;
};

acscript void TurretUseAmmo(int Type)
{
    SetActivator(GetActorProperty(0, APROP_MasterTID)); // Transfer from Turret to Player
    
    if (Type == TW_BULLET)
        Player.Turret.BulletAmmo--
    else if (Type == TW_PELLET)
        Player.Turret.ShellAmmo--
    else if (Type == TW_ROCKET)
        Player.Turret.RocketAmmo--
    else if (Type == TW_PLASMA)
        Player.Turret.PlasmaAmmo--
    else if (Type == TW_RAILGUN)
        Player.Turret.RailAmmo--;
};

acscript int TurretGetProjectileDamage(int Type)
{
    SetActivator(GetActorProperty(0, APROP_TargetTID)); // Transfer from missile to Turret
    SetActivator(GetActorProperty(0, APROP_MasterTID)); // Transfer from Turret to Player
    
    if (Type == TP_ROCKET)
        return (100 * (Player.Turret.Upgrade[TU_WEAPON_ROCKET_DAMAGE] + 1))
    else if (Type == TP_PLASMA)
        return (10 * (Player.Turret.Upgrade[TU_WEAPON_PLASMA_DAMAGE] + 1));
    
    return 0;
};

acscript int TurretGetProjectileProperty(int Type)
{
    SetActivator(GetActorProperty(0, APROP_TargetTID)); // Transfer from missile to Turret
    SetActivator(GetActorProperty(0, APROP_MasterTID)); // Transfer from Turret to Player
    
    if (Type == TP_ROCKET)
        return Player.Turret.Upgrade[TU_WEAPON_ROCKET_SEEKING];
    
    return 0;
};

acscript void TurretPostSelfDestruct()
{
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        // Player is not in-game
        if (!PlayerInGame(i)) continue;
        
        SetActivator(Players(i).TID);
        FadeRange(255, 255, 255, 0.75, 255, 255, 255, 0.0, 5.0);
    };
    
    SetActivator(GetActorProperty(0, APROP_MasterTID)); // Transfer from Turret to Player
    
    Player.Turret.Active = false;
    Player.Turret.Destroyed = true;
    Player.Turret.SelfDestruct = false;
    Player.Turret.Health = 0;
};

function void BuildTurretData()
{
    // Command description for Stim Injector
    TurretUpgradeData[TU_ASSIST_INJECTOR].CommandInfo = StrParam("Use \cd%K\c- + \cd%K\ck to issue this command\n", "+speed", "drpg_usestim");
};

function void TurretMaintenance()
{
    // Don't do anything if the turret isn't built yet
    if (!Player.Turret.Upgrade[TU_BUILD]) return;
    
    // Don't send for maintenance if there is no maintenance to be done
    if (!Player.Turret.Maintenance && Player.Turret.ChargeTimer <= 0 && Player.Turret.RepairTimer <= 0 && Player.Turret.RefitTimer <= 0) return;
    
    // You don't have any money to begin maintenance
    if (!CheckInventory("DRPGCredits"))
    {
        ActivatorSound("menu/error", 127);
        PrintError("Cannot perform maintenance because you have no money");
        return;
    };
    
    if (!Player.Turret.Maintenance)
    {
        ActivatorSound("menu/move", 127);
        Player.Turret.Maintenance = true;
        TurretDespawn();
    }
    else
    {
        ActivatorSound("menu/move", 127);
        Player.Turret.Maintenance = false;
    };
};

function bool TurretLoadAmmo(int Type)
{
    str[5] AmmoActor =
    {
        "Clip";
        "Shell";
        "RocketAmmo";
        "Cell";
        "Cell";
    };
    str[5] ReloadSound =
    {
        "turret/reloadbullet";
        "turret/reloadpellet";
        "turret/reloadrocket";
        "turret/reloadplasma";
        "turret/reloadrail";
    };
    int[5] MinAmount = { 50; 20; 5; 100; 50; };
    int *[5] Ammo =
    {
        &Player.Turret.BulletAmmo;
        &Player.Turret.ShellAmmo;
        &Player.Turret.RocketAmmo;
        &Player.Turret.PlasmaAmmo;
        &Player.Turret.RailAmmo;
    };
    int *[5] AmmoMax =
    {
        &Player.Turret.BulletAmmoMax;
        &Player.Turret.ShellAmmoMax;
        &Player.Turret.RocketAmmoMax;
        &Player.Turret.PlasmaAmmoMax;
        &Player.Turret.RailAmmoMax;
    };
    int AmmoType;
    
    // Determine proper ammo type from param
    switch (Type)
    {
    case TU_WEAPON_BULLET:  AmmoType = 0; break;
    case TU_WEAPON_PELLET:  AmmoType = 1; break;
    case TU_WEAPON_ROCKET:  AmmoType = 2; break;
    case TU_WEAPON_PLASMA:  AmmoType = 3; break;
    case TU_WEAPON_RAILGUN: AmmoType = 4; break;
    };
    
    if (CheckInventory(AmmoActor[AmmoType]) >= MinAmount[AmmoType] && AmmoType == 4) // Railgun special case
    {
        (*Ammo[AmmoType])++;
        TakeInventory(AmmoActor[AmmoType], MinAmount[AmmoType]);
        ThingSound(Player.Turret.TID, ReloadSound[AmmoType], 127);
        return true;
    }
    else if (CheckInventory(AmmoActor[AmmoType]) >= MinAmount[AmmoType] && *Ammo[AmmoType] + MinAmount[AmmoType] > *AmmoMax[AmmoType])
    {
        int Amount = *AmmoMax[AmmoType] - *Ammo[AmmoType];
        *Ammo[AmmoType] += Amount;
        TakeInventory(AmmoActor[AmmoType], Amount);
        ThingSound(Player.Turret.TID, ReloadSound[AmmoType], 127);
        return true;
    }
    else if (CheckInventory(AmmoActor[AmmoType]) >= MinAmount[AmmoType])
    {
        *Ammo[AmmoType] += MinAmount[AmmoType];
        TakeInventory(AmmoActor[AmmoType], MinAmount[AmmoType]);
        ThingSound(Player.Turret.TID, ReloadSound[AmmoType], 127);
        return true;
    }
    else
        return false;
};

function void TurretCommand(int Index)
{
    // Don't issue the command if you don't have the base upgrade yet or your turret is destroyed or in maintenance
    if (!Player.Turret.Upgrade[Index] || Player.Turret.Destroyed || Player.Turret.Maintenance) return;
    
    if (Index == TU_BUILD)
    {
        ActivatorSound("menu/move", 127);
        
        if (Player.Turret.Active)
            TurretDespawn()
        else
            TurretSpawn();
    };
    
    if (Index == TU_WEAPON_BULLET && Player.Turret.Active)
    {
        if (Player.Turret.Weapon != TW_BULLET)
        {
            Player.Turret.Weapon = TW_BULLET;
            ThingSound(Player.Turret.TID, "turret/loadbullet", 127);
        }
        else if (Player.Turret.BulletAmmo < Player.Turret.BulletAmmoMax)
        {
            if (!TurretLoadAmmo(TU_WEAPON_BULLET))
            {
                ActivatorSound("menu/error", 127);
                PrintError("You need at least \ca50 Bullets\c- to load into the turret");
            };
        };
    };

    if (Index == TU_WEAPON_PELLET && Player.Turret.Active)
    {
        if (Player.Turret.Weapon != TW_PELLET)
        {
            Player.Turret.Weapon = TW_PELLET;
            ThingSound(Player.Turret.TID, "turret/loadpellet", 127);
        }
        else if (Player.Turret.ShellAmmo < Player.Turret.ShellAmmoMax)
        {
            if (!TurretLoadAmmo(TU_WEAPON_PELLET))
            {
                ActivatorSound("menu/error", 127);
                PrintError("You need at least \ci20 Shells\c- to load into the turret");
            };
        };
    };

    if (Index == TU_WEAPON_ROCKET && Player.Turret.Active)
    {
        if (Player.Turret.Weapon != TW_ROCKET)
        {
            Player.Turret.Weapon = TW_ROCKET;
            ThingSound(Player.Turret.TID, "turret/loadrocket", 127);
        }
        else if (Player.Turret.RocketAmmo < Player.Turret.RocketAmmoMax)
        {
            if (!TurretLoadAmmo(TU_WEAPON_ROCKET))
            {
                ActivatorSound("menu/error", 127);
                PrintError("You need at least \cc5 Rockets\c- to load into the turret");
            };
        };
    };

    if (Index == TU_WEAPON_PLASMA && Player.Turret.Active)
    {
        if (Player.Turret.Weapon != TW_PLASMA)
        {
            Player.Turret.Weapon = TW_PLASMA;
            ThingSound(Player.Turret.TID, "turret/loadplasma", 127);
        }
        else if (Player.Turret.PlasmaAmmo < Player.Turret.PlasmaAmmoMax)
        {
            if (!TurretLoadAmmo(TU_WEAPON_PLASMA))
            {
                ActivatorSound("menu/error", 127);
                PrintError("You need at least \cd100 Cells\c- to load into the turret");
            };
        };
    };
    
    if (Index == TU_WEAPON_RAILGUN && Player.Turret.Active)
    {
        if (Player.Turret.Weapon != TW_RAILGUN)
        {
            Player.Turret.Weapon = TW_RAILGUN;
            ThingSound(Player.Turret.TID, "turret/loadrail", 127);
        }
        else if (Player.Turret.RailAmmo < Player.Turret.RailAmmoMax)
        {
            if (!TurretLoadAmmo(TU_WEAPON_RAILGUN))
            {
                ActivatorSound("menu/error", 127);
                PrintError("You need at least \cd50 Cells\c- to load into the turret");
            };
        };
    };
    
    if (Index == TU_AMMO_AUTOLOADER)
    {
        ActivatorSound("menu/move", 127);
        Player.Turret.Autoload = !Player.Turret.Autoload;
    };
    
    if (Index == TU_WEAPON_SELFDESTRUCT && !Player.Turret.SelfDestruct && Player.Turret.Active)
    {
        SetActorState(Player.Turret.TID, "SelfDestruct");
        Player.Turret.SelfDestruct = true;
    };
    
    if (Index == TU_ASSIST_INJECTOR && Player.Turret.Active)
        TurretStim();
    
    if (Index == TU_ASSIST_TELEPORT)
    {
        ActivatorSound("menu/move", 127);
        Player.Turret.TeleportEnabled = !Player.Turret.TeleportEnabled;
    };
    
    if (Index == TU_SENSORS_MODULEFINDER && !Player.Turret.SensorsActive && Player.Turret.Active)
    {
        ActivatorSound("menu/move", 127);
        Player.Turret.SensorMode = TSM_MODULES;
        TurretSensors();
    };
    
    if (Index == TU_SENSORS_ITEMFINDER && !Player.Turret.SensorsActive && Player.Turret.Active)
    {
        ActivatorSound("menu/move", 127);
        Player.Turret.SensorMode = TSM_ITEMS;
        TurretSensors();
    };
    
    if (Index == TU_SENSORS_SUPPLYFINDER && !Player.Turret.SensorsActive && Player.Turret.Active)
    {
        ActivatorSound("menu/move", 127);
        Player.Turret.SensorMode = TSM_CRATE;
        TurretSensors();
    };
};

function bool TurretStim()
{
    if (!Player.Turret.Upgrade[TU_BUILD])
    {
        PrintError("You haven't built a turret");
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    if (!Player.Turret.Active)
    {
        PrintError("Your turret is not active");
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    if (!Player.Turret.Upgrade[TU_ASSIST_INJECTOR] || !Player.Turret.Upgrade[TU_ASSIST_INJECTOR_TYPE] || !Player.Turret.Upgrade[TU_ASSIST_INJECTOR_AMOUNT] || !Player.Turret.Upgrade[TU_ASSIST_INJECTOR_POTENCY])
    {
        PrintError("Your turret does not have the appropriate upgrades");
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    bool Powerups = (Player.Turret.Upgrade[TU_ASSIST_INJECTOR_TYPE] > 1);
    int MaxAmount = Player.Turret.Upgrade[TU_ASSIST_INJECTOR_AMOUNT];
    int Potency = Player.Turret.Upgrade[TU_ASSIST_INJECTOR_POTENCY];
    int Amount = 0;
    
    // Generate the stim
    while (Amount++ < MaxAmount)
    {
        int TypeMax = (Powerups ? StimPowerupEnd : StimStatsEnd);
        int Type = Random(0, TypeMax);
        
        Log("\cd%d. Type: %d (%d)\n", Amount, Type, Potency);
        
        Player.Stim.Current[Type] += Potency;
    };
    
    return true;
};

function int TurretUpgradeCost(int Index)
{
    return (TurretUpgradeData[Index].Cost * (Player.Turret.Upgrade[Index] + 1));
};

function void TurretPassVars()
{
    // Master TID
    SetUserVariable(Player.Turret.TID, "user_master", Player.TID);
    
    // Upgrade info
    for (int i = 0; i < MAX_UPGRADES; i++)
        SetUserArray(Player.Turret.TID, "user_upgrade", i, Player.Turret.Upgrade[i]);
    
    // Weapon Type
    SetUserVariable(Player.Turret.TID, "user_weapon", Player.Turret.Weapon);
    
    // Bullet
    SetUserVariable(Player.Turret.TID, "user_bullet_damage", Player.Turret.Upgrade[TU_WEAPON_BULLET_DAMAGE]);
    SetUserVariable(Player.Turret.TID, "user_bullet_rof", Player.Turret.Upgrade[TU_WEAPON_BULLET_ROF]);
    
    // Pellet
    SetUserVariable(Player.Turret.TID, "user_pellet_damage", Player.Turret.Upgrade[TU_WEAPON_PELLET_DAMAGE]);
    SetUserVariable(Player.Turret.TID, "user_pellet_rof", Player.Turret.Upgrade[TU_WEAPON_PELLET_ROF]);
    SetUserVariable(Player.Turret.TID, "user_pellet_spread", Player.Turret.Upgrade[TU_WEAPON_PELLET_SPREAD]);
    SetUserVariable(Player.Turret.TID, "user_pellet_amount", Player.Turret.Upgrade[TU_WEAPON_PELLET_AMOUNT]);
    
    // Rocket
    SetUserVariable(Player.Turret.TID, "user_rocket_rof", Player.Turret.Upgrade[TU_WEAPON_ROCKET_ROF]);
    
    // Plasma
    SetUserVariable(Player.Turret.TID, "user_plasma_rof", Player.Turret.Upgrade[TU_WEAPON_PLASMA_ROF]);
    
    // Railgun
    SetUserVariable(Player.Turret.TID, "user_railgun_damage", Player.Turret.Upgrade[TU_WEAPON_RAILGUN_DAMAGE]);
    SetUserVariable(Player.Turret.TID, "user_railgun_rof", Player.Turret.Upgrade[TU_WEAPON_RAILGUN_ROF]);
    SetUserVariable(Player.Turret.TID, "user_railgun_ripping", Player.Turret.Upgrade[TU_WEAPON_RAILGUN_RIPPING] * 2);
    
    // Ammo
    SetUserVariable(Player.Turret.TID, "user_ammo_bullet", Player.Turret.BulletAmmo);
    SetUserVariable(Player.Turret.TID, "user_ammo_shell", Player.Turret.ShellAmmo);
    SetUserVariable(Player.Turret.TID, "user_ammo_rocket", Player.Turret.RocketAmmo);
    SetUserVariable(Player.Turret.TID, "user_ammo_plasma", Player.Turret.PlasmaAmmo);
    SetUserVariable(Player.Turret.TID, "user_ammo_rail", Player.Turret.RailAmmo);
    
    // Self Destruct
    SetUserVariable(Player.Turret.TID, "user_destruct_range", Player.Turret.Upgrade[TU_WEAPON_SELFDESTRUCT] * 1024);
    SetUserVariable(Player.Turret.TID, "user_destruct_damage", Player.Turret.Upgrade[TU_WEAPON_SELFDESTRUCT] * 1000);
};

function void TurretSpawn()
{
    int TID = UniqueTID();
    
    if (Player.Turret.Battery <= 0)
    {
        ActivatorSound("menu/error", 127);
        PrintError("Your turret's battery is depleted");
        return;
    };
    
    if (Player.Turret.Destroyed)
    {
        ActivatorSound("menu/error", 127);
        PrintError("Your turret is destroyed and must be repaired");
        return;
    };
    
    if (Player.Turret.Maintenance)
    {
        ActivatorSound("menu/error", 127);
        PrintError("Your turret is currently in the Outpost for maintenance");
        return;
    };
    
    if (Player.Turret.RefitTimer > 0)
    {
        ActivatorSound("menu/error", 127);
        PrintError("Your turret is currently being refitted with upgrades");
        return;
    };
    
    GiveInventory("DRPGPortableTurretSpawner", 1);
    SpawnForced("TeleportFog", GetActorX(0), GetActorY(0), GetActorZ(0), 0, 0);
    
    Player.Turret.TID = TID;
};

function void TurretDespawn()
{
    if (!Player.Turret.Active) return;
    
    Player.Turret.Active = false;
    
    SpawnForced("TeleportFog", GetActorX(Player.Turret.TID), GetActorY(Player.Turret.TID), GetActorZ(Player.Turret.TID), 0, 0);
    Thing_Remove(Player.Turret.TID);
};

script void TurretItemSensorThink()
{
    if (!Player.Turret.SensorItemData.Enabled)
        return;
    
    if (Player.Turret.SensorItemData.Array.Position < 1)
        return;
    
    int TID;
    
    if (Player.Turret.SensorItemData.PulseDelay == 0)
    {
        if (Player.Turret.SensorItemData.CurrentPosition >= Player.Turret.SensorItemData.Array.Position)
        {
            Player.Turret.SensorItemData.CurrentPosition = 0;
            Player.Turret.SensorItemData.PulseDelay = 35;
        }
        else
        {
            if (Player.Turret.SensorItemData.CheckDelay)
                Player.Turret.SensorItemData.CheckDelay--
            else
            {
                if (Player.Turret.SensorItemData.CurrentPosition == 0)
                    qsort(Player.Turret.SensorItemData.Array.Data, Player.Turret.SensorItemData.Array.Position, sizeof(int), TurretSensorDistanceComparison);
                
                TID = *(&((int *)Player.Turret.SensorItemData.Array.Data)[Player.Turret.SensorItemData.CurrentPosition]);
                
                while (ClassifyActor(TID) == ACTOR_NONE && Player.Turret.SensorItemData.CurrentPosition < Player.Turret.SensorItemData.Array.Position)
                {
                    Player.Turret.SensorItemData.CurrentPosition++;
                    if (Player.Turret.SensorItemData.CurrentPosition < Player.Turret.SensorItemData.Array.Position)
                        TID = *(&((int *)Player.Turret.SensorItemData.Array.Data)[Player.Turret.SensorItemData.CurrentPosition]);
                };
                
                if (Player.Turret.SensorItemData.CurrentPosition < Player.Turret.SensorItemData.Array.Position)
                {
                    for (fixed j = 0.0; j <= 1.0; j += 0.01)
                    {
                        fixed X = Lerp(GetActorX(Player.Turret.TID), GetActorX(TID), j);
                        fixed Y = Lerp(GetActorY(Player.Turret.TID), GetActorY(TID), j);
                        fixed Z = Lerp(GetActorZ(Player.Turret.TID), GetActorZ(TID), j);
                        SpawnForced("DRPGTurretParticleItemTrail", X, Y, Z, 0, 0);
                    };
                    
                    Player.Turret.SensorItemData.CurrentPosition++;
                    Player.Turret.SensorItemData.CheckDelay = 3;
                };
            };
        };
    }
    else
        Player.Turret.SensorItemData.PulseDelay--;
};

script void TurretCrateSensorThink()
{
    if (!Player.Turret.SensorCrateData.Enabled)
        return;
    
    if (Player.Turret.SensorCrateData.Array.Position < 1)
        return;
    
    int TID;
    
    if (Player.Turret.SensorCrateData.PulseDelay == 0)
    {
        if (Player.Turret.SensorCrateData.CurrentPosition >= Player.Turret.SensorCrateData.Array.Position)
        {
            Player.Turret.SensorCrateData.CurrentPosition = 0;
            Player.Turret.SensorCrateData.PulseDelay = 35;
        }
        else
        {
            if (Player.Turret.SensorCrateData.CheckDelay)
                Player.Turret.SensorCrateData.CheckDelay--
            else
            {
                if (Player.Turret.SensorCrateData.CurrentPosition == 0)
                    qsort(Player.Turret.SensorCrateData.Array.Data, Player.Turret.SensorCrateData.Array.Position, sizeof(int), TurretSensorDistanceComparison);
                
                TID = *(&((int *)Player.Turret.SensorCrateData.Array.Data)[Player.Turret.SensorCrateData.CurrentPosition]);
                
                while (ClassifyActor(TID) == ACTOR_NONE && Player.Turret.SensorCrateData.CurrentPosition < Player.Turret.SensorCrateData.Array.Position)
                {
                    Player.Turret.SensorCrateData.CurrentPosition++;
                    if (Player.Turret.SensorCrateData.CurrentPosition < Player.Turret.SensorCrateData.Array.Position)
                        TID = *(&((int *)Player.Turret.SensorCrateData.Array.Data)[Player.Turret.SensorCrateData.CurrentPosition]);
                };
                
                if (Player.Turret.SensorCrateData.CurrentPosition < Player.Turret.SensorCrateData.Array.Position)
                {
                    for (fixed j = 0.0; j <= 1.0; j += 0.01)
                    {
                        fixed X = Lerp(GetActorX(Player.Turret.TID), GetActorX(TID), j);
                        fixed Y = Lerp(GetActorY(Player.Turret.TID), GetActorY(TID), j);
                        fixed Z = Lerp(GetActorZ(Player.Turret.TID), GetActorZ(TID), j);
                        SpawnForced("DRPGTurretParticleCrateTrail", X, Y, Z, 0, 0);
                    };
                    
                    Player.Turret.SensorCrateData.CurrentPosition++;
                    Player.Turret.SensorCrateData.CheckDelay = 3;
                };
            };
        };
    }
    else
        Player.Turret.SensorCrateData.PulseDelay--;
};

function int TurretSensorDistanceComparison(void const *TIDPtr1, void const *TIDPtr2)
{
    int TID1 = *(int *)TIDPtr1;
    int TID2 = *(int *)TIDPtr2;
    
    if (ClassifyActor(TID1) == ACTOR_NONE && ClassifyActor(TID2) == ACTOR_NONE)
        return 0;
    if (ClassifyActor(TID1) == ACTOR_NONE)
        return -1;
    if (ClassifyActor(TID2) == ACTOR_NONE)
        return 1;
    
    fixed Distance1 = Distance(Player.Turret.TID, TID1);
    fixed Distance2 = Distance(Player.Turret.TID, TID2);
    
    if (Distance2 == Distance1)
        return 0
    else if (Distance2 > Distance1)
        return -1;
    return 1;
};

acscript void GiveTurret()
{
    Player.Turret.Upgrade[TU_BUILD] = true;
};

acscript void FullTurret()
{
    Player.Turret.Upgrade[TU_BUILD] = true;
    
    Delay(1);
    
    for (int i = 1; i < TU_MAX; i++)
        Player.Turret.Upgrade[i] = TurretUpgradeData[i].MaxLevel;
};
