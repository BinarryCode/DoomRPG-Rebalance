#include "RPG.dh"

#include "Augs.dh"
#include "Defs.dh"
#include "ItemData.dh"
#include "Map.dh"
#include "Outpost.dh"
#include "Shield.dh"
#include "Shop.dh"
#include "Skills.dh"
#include "Stats.dh"
#include "Utils.dh"

// --------------------------------------------------
// Variables
// 

int AuraTID = 20000;

// Skill Level Names
str[6] SkillLevels =
{
    "Easy";
    "Normal";
    "Hard";
    "Nightmare";
    "Hell";
    "Armageddon";
};

str[AURA_MAX] AuraIcons =
{
    "AuraRed";
    "AuraGree";
    "AuraWhit";
    "AuraPink";
    "AuraCyan";
    "AuraPurp";
    "AuraOran";
    "AuraBlue";
    "AuraYell";
    "AuraBlac";
};

// --------------------------------------------------
// DECORATE
// 

acscript int InOutpost()
{
    return (int)InBase;
};

acscript int GetUniqueTID()
{
    return UniqueTID();
};

acscript int GetAmmoMax(int Type)
{
    switch (Type)
    {
    case AMMO_CLIP:     return GetAmmoCapacity("Clip");
    case AMMO_SHELL:    return GetAmmoCapacity("Shell");
    case AMMO_ROCKET:   return GetAmmoCapacity("RocketAmmo");
    case AMMO_CELL:     return GetAmmoCapacity("Cell");
    };
};

acscript void SoulEffect(int Type)
{
    Player.Aura.Type[Type].Active = true;
    Player.Aura.Type[Type].Level = Skills[2][Type].MaxLevel;
    Player.Aura.Time += 30 * 35;
    Player.SoulActive[Type] = true;
};

// Used by DECORATE and the Immunity Crystals plus Anti-Demon Field
acscript void DestroyImmunity()
{
    TakeInventory("DRPGPowerImmunityBullet", 1);
    TakeInventory("DRPGPowerImmunityMelee", 1);
    TakeInventory("DRPGPowerImmunityFire", 1);
    TakeInventory("DRPGPowerImmunityPlasma", 1);
    TakeInventory("PowerProtection", 1);
};

// Return the Skill Level (for DECORATE)
acscript int GetSkillLevel()
{
    return GameSkill();
};

// Return the Global shop card rank between all players (for DECORATE)
acscript int GetShopCard()
{
    return GlobalShopCard;
};

// Set the damage type recieved by the Player this tic (for DECORATE)
acscript void SetDamageType(int Type)
{
    Player.DamageType = Type;
};

// Return whether your Aug Battery is full or not1
acscript int CheckAugBatteryMax()
{
    return (Player.Augs.Battery >= Player.Augs.BatteryMax);
};

// Get the max inventory size
acscript int CheckInventoryMax()
{
    return Player.Capacity * 5;
};

// Used for handling inventory items using the Capacity stat
acscript int CheckCapacity()
{
    int Items = 0;
    int MaxItems = CheckInventoryMax();
    
    // Don't do checks if you have the system disabled
    if (!GetCVar("drpg_inv_capacity")) return true;
    
    auto str[] ItemList =
    {
        // Health
        "DRPGStimpack";
        "DRPGMedikit";
        "DRPGLargeMedikit";
        "DRPGXLMedikit";
        "DRPGMedPack";
        "DRPGSurgeryKit";
        
        // Armor
        "DRPGGreenArmor";
        "DRPGUsedGreenArmor";
        "DRPGBlueArmor";
        "DRPGUsedBlueArmor";
        "DRPGYellowArmor";
        "DRPGUsedYellowArmor";
        "DRPGRedArmor";
        "DRPGUsedRedArmor";
        "DRPGWhiteArmor";
        "DRPGUsedWhiteArmor";
        
        // Powerups
        "DRPGInvulnerabilitySphere";
        "DRPGInvulnerabilityCharge";
        "DRPGBlurSphere";
        "DRPGInvisibilityCharge";
        "DRPGTimeSphere";
        "DRPGRegenSphere";
        "DRPGRadSuit";
        "DRPGInfrared";
        "DRPGAllMap";
        "DRPGBerserk";
        "DRPGWings";
        
        // Stims
        "DRPGStimDetox";
        
        // Batteries
        "DRPGBatterySmall";
        "DRPGBatteryLarge";
        
        // DoomRL - Powerups
        "InvulnerabilitySphere2";
        "InvulnerabilityCharge2";
        "RadSuit2";
        "InvisibilityCharge2";
        "RadSuit2";
        "Infrared2";
        "Berserk2";
        
        // End of List
        nullptr;
    };
    
    for (int i = 0; ItemList[i] != nullptr; i++)
        if (CheckInventory(ItemList[i]) > 0)
            Items += CheckInventory(ItemList[i]);
    
    Player.InvItems = Items;
    
    if (Items >= MaxItems)
        return false
    else
        return true;
};

// Return Timer() for DECORATE
acscript int GetTimer()
{
    return Timer();
};

// Returns the Agility for A_SetTics calls in DECORATE
acscript int GetSpeed(int Tics)
{
    return Tics - ((Tics - 1) / 100) * Player.Agility;
};

// Used by DECORATE to check if both your Health and EP are at max
acscript int HPEPMax()
{
    return (int)(Player.ActualHealth >= Player.HealthMax && Player.EP >= Player.EPMax);
};

// Really only used to bypass startup error spam due to looking for DRLA actors
acscript int PowersuitCheck()
{
    bool ValidPlayer = false;
    
    SetActivatorToTarget(0);
    
    for (int i = 0; i < MAX_PLAYERS; i++)
        if (ActivatorTID() == Players(i).TID)
        {
            ValidPlayer = true;
            break;
        };
    
    if (ValidPlayer)
    {
        if (CheckInventory("PowerRLReactiveShieldSystemBullet"))
            return 1; // Bullet
        if (CheckInventory("RLPlasmaShieldArmorToken") || CheckInventory("PowerRLReactiveShieldSystemPlasma"))
            return 2; // Plasma
        if (CheckInventory("PowerRLReactiveShieldSystemFire") || CheckInventory("RLInquisitorsSetBonusActive"))
            return 3; // Fire
        if (CheckInventory("PowerInvulnerable") ||
            CheckInventory("PowerTimeFreezer") ||
            CheckInventory("DRPGPowerStimIndestructible") ||
            CheckInventory("DRPGPowerImmunityBullet") ||
            CheckInventory("DRPGPowerImmunityBullet") ||
            CheckInventory("DRPGPowerImmunityMelee") ||
            CheckInventory("DRPGPowerImmunityPlasma") ||
            CheckInventory("RLPlasmaShieldArmorToken"))
            return 4; // Powerups/Immunities for Anti Demon Field
    }
    else
        return -1;
};

acscript int ShieldRemoveArmor()
{
    
    return (int)(GetCVar("drpg_shield_armorremove") && Player.Shield.Active);
};

// --------------------------------------------------
// Monsters
// 

// For calling from DECORATE
acscript void HealMonster(int HealPercent)
{
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    int Health = GetActorProperty(0, APROP_Health);
    int HealAmount = Stats->HealthMax * HealPercent / 100;  
    
    SetActorProperty(0, APROP_Health, Health + HealAmount);
    
    if (GetActorProperty(0, APROP_Health) >= Stats->HealthMax)
        SetActorProperty(0, APROP_Health, Stats->HealthMax);
};

acscript void TeleportMonster()
{
    str Type = GetActorClass(0);
    int TID = UniqueTID();
    bool Success = false;
    Position *ChosenPosition = nullptr;
    
    // Check the position
    while (!Success)
    {
        ChosenPosition = &((Position *)CurrentLevel->MonsterPositions.Data)[Random(0, CurrentLevel->MonsterPositions.Position)];
        Success = Spawn(Type, ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z, TID, ChosenPosition->Angle);
        Thing_Remove(TID);
        Delay(1);
    };
    
    // Teleport to this position
    SetActorPosition(0, ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z, true);
    SetActorAngle(0, ChosenPosition->Angle);
    SetActorPitch(0, ChosenPosition->Pitch);
};

function void DropMoney(int Killer, int TID, int Amount)
{
    int Total = Amount;
    int Drops;
    
    Drops = Total / 1000;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits1000", 256);
    Total %= 1000;

    Drops = Total / 100;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits100", 256);
    Total %= 100;

    Drops = Total / 50;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits50", 256);
    Total %= 50;

    Drops = Total / 20;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits20", 256);
    Total %= 20;

    Drops = Total / 10;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits10", 256);
    Total %= 10;

    Drops = Total / 5;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits5", 256);
    Total %= 5;
    
    Drops = Total;
    while (Drops--) DropMonsterItem(Killer, TID, "DRPGCredits1", 256);
};

function int DropMonsterItem(int Killer, int TID, str Item, int Chance, fixed XAdd, fixed YAdd, fixed ZAdd, fixed XVelAdd, fixed YVelAdd, fixed ZVelAdd)
{
    // if this is an invalid killer, return
    if (!(Killer > -1)) return 0;
    
    // Chance
    if (!(Random(1, 256) <= Chance)) return 0;
    
    fixed Angle = GetActorAngle(TID);
    fixed X = GetActorX(TID) + XAdd;
    fixed Y = GetActorY(TID) + YAdd;
    fixed Z = GetActorZ(TID) + (GetActorPropertyFixed(0, APROP_Height) / 2.0) + ZAdd;
    fixed XSpeed = GetCVarFixed("drpg_monster_dropdist") + XVelAdd;
    fixed YSpeed = GetCVarFixed("drpg_monster_dropdist") + YVelAdd;
    fixed ZSpeed = 8.0 + ZVelAdd;
    int ItemTID = UniqueTID();
    bool Success = false;
    
    // Spawn the Item
    Success = SpawnForced(Item, X, Y, Z, ItemTID, Angle);
    
    // Spawn successful
    if (Success)
    {
        // Set Velocity
        SetActorVelocity(ItemTID, RandomFixed(-XSpeed, XSpeed), RandomFixed(-YSpeed, YSpeed), ZSpeed, false, false);
        
        // Array has grown too big, resize it
        if (Players(Killer).DropTID.Position == Players(Killer).DropTID.Size)
            ArrayResize(&Players(Killer).DropTID);
        
        // Add item's TID to drop array
        ((int *)Players(Killer).DropTID.Data)[Players(Killer).DropTID.Position++] = ItemTID;
    };
    
    return ItemTID;
};

// --------------------------------------------------
// Players
// 

// Used by the RegenSphere to temporarily increase regen rates
acscript void RegenBoost()
{
    Player.RegenBoostTimer += (35 * 5) + ((Player.Regeneration / 13.33) * 35);
};

// Set Skill Level during the game
acscript void SetSkill(int NewSkill)
{
    if (NewSkill < 0 || NewSkill > (CompatMode == COMPAT_DRLA ? 5 : 4))
    {
        HudMessage("Invalid Skill Level\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
        return;
    };
    
    FadeRange(255, 255, 255, 0.5, 255, 255, 255, 0.0, 0.5);
    ChangeSkill(NewSkill);
    ActivatorSound("misc/secret", 127);
    SetFont("BIGFONT");
    HudMessageBold("\cjSkill Level has been changed to\n\cg%d - %s\n", NewSkill + 1, SkillLevels[NewSkill],
                   HUDMSG_FADEOUT, 0, CR_WHITE, 1.5, 0.5, 2.0, 1.0);
};

// Respec - Respecialize your Player
acscript void Respec(bool DoStats, bool DoSkills) net
{
    int StatPoints;
    int SkillPoints;
    int OldCredits;
    
    // Respec Stats
    if (DoStats)
    {
        // Add stats into a pool of tokens to give back to the player
        StatPoints += Player.Strength;
        StatPoints += Player.Defense;
        StatPoints += Player.Vitality - 10;
        StatPoints += Player.Energy - 10;
        StatPoints += Player.Regeneration;
        StatPoints += Player.Agility;
        StatPoints += Player.Capacity - 10;
        StatPoints += Player.Luck;
        
        // Reset Stats
        Player.Strength = 0;
        Player.Defense = 0;
        Player.Vitality = 10;
        Player.Energy = 10;
        Player.Regeneration = 0;
        Player.Agility = 0;
        Player.Capacity = 10;
        Player.Luck = 0;

        // Give Respecced Stat Tokens back
        GiveInventory("DRPGStatToken", StatPoints);

        // Reset Shield
        Player.Shield.Charge = 0;
        Player.Shield.Timer = 375;
    };
    
    // Respec Skills
    if (DoSkills)
    {
        // Reset skills, add skill levels together into a pool of tokens to give back to the player
        for (int i = 0; i < MAX_CATEGORIES; i++)
            for (int j = 0; j < SkillCategoryMax[i]; j++)
                if (!(i == 5 && j == 7)) // Skip Transport
                    while (Player.SkillLevel[i][j].Level > 0)
                    {
                        SkillPoints += Player.SkillLevel[i][j].Level;
                        Player.SkillLevel[i][j].CurrentLevel--;
                        Player.SkillLevel[i][j].Level--;
                    };
        
        // Give Respecced Skill Tokens back
        GiveInventory("DRPGSkillToken", SkillPoints);

        // Remove Auras
        RemoveAura();
    };
    
    // Take 1/2 Credits
    GiveInventory("DRPGCredits", OldCredits);
    TakeInventory("DRPGCredits", CheckInventory("DRPGCredits") / 2);
    
    // FX
    FadeRange(255, 255, 255, 0.75, 0, 0, 0, 0.0, 2.5);
    SetFont("BIGFONT");
    HudMessage("Respec Complete\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.5, 2.5, 2.5);
    ActivatorSound("misc/secret", 127);
};

acscript int GetToxicity()
{
    return Player.Toxicity;
};

// Add Toxicity to the Player
acscript void AddToxicity(int Amount)
{
    int PrevToxicity = Player.Toxicity;
    
    Player.Toxicity += Amount;
    Player.ToxicTimer = 0;
    Player.ToxicOffset = 0;
    Player.ToxicStage = 0;
    
    if ((PrevToxicity < 25 && Player.Toxicity >= 25) ||
        (PrevToxicity < 50 && Player.Toxicity >= 50) ||
        (PrevToxicity < 75 && Player.Toxicity >= 75))
        ActivatorSound("misc/toxic", 127);
};

acscript void PurgeDrops() net
{
    int *TID = (int *)Player.DropTID.Data;
    for (int i = 0; i < Player.DropTID.Position; i++)
    {
        if (ClassifyActor(TID[i]) == ACTOR_NONE)
            continue;
        
        SpawnSpot("TeleportFog", TID[i], 0, 0);
        Thing_Remove(TID[i]);
    };
    
    CleanDropTIDArray();
    Print("\cdRemoved \cgall\cd monster-dropped items\n");
};

acscript void CheckArmorStats()
{
    Log("\c[Orange]-- ARMOR STATS --\n");
    Log("\c[Green]Class name: \c[White]%s\n", GetArmorInfoString(ARMORINFO_CLASSNAME));
    Log("\c[Green]Durability: \c[LightBlue]%i%%\n", GetArmorInfo(ARMORINFO_SAVEAMOUNT));
    Log("\c[Green]Protection: \c[Yellow]%k%%\n", GetArmorInfoFixed(ARMORINFO_SAVEPERCENT) * 100.0);
    Log("\c[Green]Max Absorb: \c[Grey]%i%%\n", GetArmorInfo(ARMORINFO_MAXABSORB));
    Log("\c[Green]Max Full Absorb: \c[Brick]%i%%\n", GetArmorInfo(ARMORINFO_MAXFULLABSORB));
};

// Returns whether your stats are all currently capped or not1
function bool StatsCapped()
{
    return (Player.Strength >= SoftStatCap &&
            Player.Defense >= SoftStatCap &&
            Player.Vitality >= SoftStatCap &&
            Player.Energy >= SoftStatCap &&
            Player.Regeneration >= SoftStatCap &&
            Player.Agility >= SoftStatCap &&
            Player.Capacity >= SoftStatCap &&
            Player.Luck >= SoftStatCap);
};

// Calculates pay for the Rank Payout
function int CalculatePay(int PlayerNum)
{
    if (PlayerNum == 0) PlayerNum = PlayerNumber();
    return (int)(((((fixed)Players(PlayerNum).RankLevel + 1.0) * 10.0) + ((fixed)Players(PlayerNum).PayKills * ((fixed)Players(PlayerNum).RankLevel + 1.0))) * (1.0 + (fixed)Players(PlayerNum).PayBonus / 100.0));
};

function int AveragePlayerLevel()
{
    int NumPlayers;
    int TotalLevel;
    
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        // Skip player if they're not ingame
        if (!PlayerInGame(i)) continue;
        
        TotalLevel += Players(i).Level;
        NumPlayers++;
    };
    
    return TotalLevel / NumPlayers;
};

function bool HaveStatusEffect()
{
    for (int i = 0; i < SE_MAX; i++)
        if (Player.StatusType[i])
            return true;
    
    return false;
};

function bool DropPlayerItem(str Item)
{
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0) + Cos(Angle);
    fixed Y = GetActorY(0) + Sin(Angle);
    fixed Z = GetActorZ(0) + 16.0;
    fixed XSpeed = Cos(Angle) * 4.0;
    fixed YSpeed = Sin(Angle) * 4.0;
    int TID = UniqueTID();
    bool SpawnOK = Spawn(Item, X, Y, Z, TID, Angle);
    bool SightOK = CheckSight(TID, 0, 0);
    
    // Remove the item if it fails the sight check
    if (!SightOK)
        Thing_Remove(TID);
    
    // Apply Velocity
    if (SpawnOK && SightOK)
        SetActorVelocity(TID, XSpeed, YSpeed, 0, false, false);
    
    return (SpawnOK && SightOK);
};

function bool IsPlayerMoving()
{
    return (GetPlayerInput(PlayerNumber(), MODINPUT_FORWARDMOVE) ||
            GetPlayerInput(PlayerNumber(), MODINPUT_SIDEMOVE) ||
            GetPlayerInput(PlayerNumber(), MODINPUT_UPMOVE));
};

function int FindPlayerID(int TID)
{
    for (int i = 0; i < MAX_PLAYERS; i++)
        if (Players(i).TID == TID)
            return i;
    
    return -1;
};

function bool IsTimeFrozen()
{
    for (int i = 0; i < MAX_PLAYERS; i++)
        if (CheckActorInventory(Players(i).TID, "PowerTimeFreezer") ||
            CheckActorInventory(Players(i).TID, "PowerShieldTimeFreezer") ||
            CheckActorInventory(Players(i).TID, "PowerRLChronotrooperFreeze") || // DoomRL
            CheckActorInventory(Players(i).TID, "DRPGMenuFreezer"))
            return true;
    
    return false;
};

// --------------------------------------------------
// Inventory
// 

function int CheckInventoryTID(int TID, str Item)
{
    return (TID == 0 ? CheckInventory(Item) : CheckActorInventory(TID, Item));
};

function int SetInventory(str Item, int Count)
{
    int n = Count - CheckInventory(Item);
    
    if (n > 0)
        GiveInventory(Item, n)
    else if (n < 0)
        TakeInventory(Item, -n);
    
    return n;
};

function int SetActorInventory(int tid, str item, int count)
{
    int n = count - CheckActorInventory (tid, item);
    
    if (n > 0)
        GiveActorInventory(tid, item, n)
    else if (n < 0)
        TakeActorInventory(tid, item, -1 * n);
    
    return n;
};

// Drop your entire inventory on the ground
function void DropInventory()
{
    auto DroppedItem[] ItemList =
    {
        // Health
        { "Stimpack"; };
        { "Medikit"; };
        { "LargeMedikit"; };
        { "XLMedikit"; };
        { "MedPack"; };
        { "SurgeryKit"; };
        { "Continue"; };
        
        // Armor
        { "GreenArmor"; };
        { "UsedGreenArmor"; };
        { "BlueArmor"; };
        { "UsedBlueArmor"; };
        { "YellowArmor"; };
        { "UsedYellowArmor"; };
        { "RedArmor"; };
        { "UsedRedArmor"; };
        { "WhiteArmor"; };
        { "UsedWhiteArmor"; };
        
        // Powerups
        { "InvulnerabilitySphere"; };
        { "InvulnerabilityCharge"; };
        { "BlurSphere"; };
        { "InvisibilityCharge"; };
        { "RegenSphere"; };
        { "RadSuit"; };
        { "Infrared"; };
        { "AllMap"; };
        { "Berserk"; };
        { "Wings"; };
        { "StimSmall"; };
        { "StimMedium"; };
        { "StimLarge"; };
        
        // DoomRL - Powerups
        { "InvulnerabilitySphere2"; };
        { "RadSuit2"; };
        { "Infrared2"; };
        { "Berserk2"; };

        // DoomRL - Modpacks
        { "RLPowerModItem"; };
        { "RLBulkModItem"; };
        { "RLAgilityModItem"; };
        { "RLTechnicalModItem"; };
        { "RLSniperModItem"; };
        { "RLFirestormModItem"; };
        { "RLNanoModItem"; };
        { "RLOnyxModItem"; };
        { "RLArmorModItem"; };
        { "RLModLimit"; true; true; 4; };
        { "RLScavengerModLimit"; true; true; 8; };
        { "RLArmorModItemInInventory"; true; };
        
        // End of list
        { nullptr; };
    };
    
    for (int i = 0; ItemList[i].Actor != nullptr; i++)
        for (int j = 0; j < CheckInventory(ItemList[i].Actor); j++)
        {
            // Limit the drops if you have more than 25 to prevent massive amounts of lag
            if (j >= 25) break;
            
            if (ItemList[i].TakeAll)
                TakeInventory(ItemList[i].Actor, ItemList[i].Max)
            else
                TakeInventory(ItemList[i].Actor, 1);
            
            if (!ItemList[i].NoDrop)
                DropItem(0, ItemList[i].Actor, 1, 255);
        };
};

// --------------------------------------------------
// Items
// 

acscript int GetItemDropLuck()
{
    int NumPlayers;
    int TotalLuck;
    
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        // Skip player if they're not ingame
        if (!PlayerInGame(i)) continue;
        
        TotalLuck += Players(i).Luck;
        NumPlayers++;
    };
    
    // Average the Luck
    TotalLuck /= NumPlayers;
    TotalLuck = (int)((fixed)TotalLuck / 1.5625);
    
    // Prevent overflow from Luck total being too high
    if (TotalLuck > 128)
        TotalLuck = 128;
    
    return TotalLuck;
};

// Return the amount of ammo corresponding to an ammo pickup
function int GetAmmoAmount(str Item)
{
    int Amount = 1;
    
    if (Item == "Clip")         Amount = 10;
    if (Item == "ClipBox")      Amount = 50;
    if (Item == "Shell")        Amount = 4;
    if (Item == "ShellBox")     Amount = 20;
    if (Item == "RocketAmmo")   Amount = 1;
    if (Item == "RocketBox")    Amount = 5;
    if (Item == "Cell")         Amount = 20;
    if (Item == "CellPack")     Amount = 100;
    
    return Amount;
};

// --------------------------------------------------
// Health
// 

// Returns true if the player's health is below the specified percentage of max health
acscript int HealthBelowPercent(int Percent)
{
    return (int)(Player.ActualHealth <= Player.HealthMax * Percent / 100);
};

// Returns your max Health (for DECORATE)
acscript int GetHealthMax()
{
    return Player.HealthMax;
};

// Used by DECORATE in UseShield state to cap healing items to only heal to maximum Health
acscript void CapHealthItem()
{
    if (Player.ActualHealth > Player.HealthMax)
        Player.ActualHealth = Player.HealthMax;
};

// --------------------------------------------------
// Shield
// 

// Returns the capacity of your current Shield (for DECORATE)
acscript int GetShieldMax()
{
    return Player.Shield.Capacity;
};

// Used by DECORATE to check if your Shield's stored Health is at max
acscript bool ShieldHealthMax()
{
    return (Player.ActualHealth >= Player.HealthMax);
};

// --------------------------------------------------
// EP
// 

acscript void AddEP(int Amount, bool NoFlash)
{
    if (Player.EP + Amount > Player.EPMax)
        Amount = Player.EPMax - Player.EP;
    
    if (Amount <= 0)
        return;
    
    fixed FlashStrength = 0.01 * (Amount * 100 / Player.EPMax);
    fixed FlashDuration = 0.03 * (Amount * 100 / Player.EPMax);
    
    if (FlashStrength > 0.5)
        FlashStrength = 0.5;
    
    if (FlashDuration > 3.0)
        FlashDuration = 3.0;
    
    if (!NoFlash)
        FadeRange(0, 255, 255, FlashStrength, 0, 255, 255, 0, FlashDuration);
    
    Player.EP += Amount;
};

acscript void RemoveEP(int Amount, int InUnits)
{
    if (InUnits)
        Player.EP -= Amount
    else
        Player.EP -= ((Player.EP * Amount) / 100);
};

// Returns your current EP (for DECORATE)
acscript int GetEP()
{
    return Player.EP;
};

// Gets your current max EP (for DECORATE)
acscript int GetEPMax()
{
    return Player.EPMax;
};

// --------------------------------------------------
// Skills
// 

acscript void PlayerTeleport(int PlayerNum) net
{
    bool NearPlayers = true;
    
    if (PlayerNum == PlayerNumber() || !PlayerInGame(PlayerNum))
    {
        ActivatorSound("menu/error", 127);
        return;
    };
    
    // Teleport
    GiveInventory("DRPGPlayerTeleportGhost", 1);
    SetActorPosition(Player.TID, GetActorX(Players(PlayerNum).TID), GetActorY(Players(PlayerNum).TID), GetActorZ(Players(PlayerNum).TID), true);
    SetActorAngle(Player.TID, GetActorAngle(Players(PlayerNum).TID));
    SetActorProperty(Player.TID, APROP_RenderStyle, STYLE_Translucent);
    
    while (NearPlayers)
    {
        // Reset the flag
        NearPlayers = false;
        
        // Make sure you're not inside or near any other players before we solidify
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (i == PlayerNumber() || !PlayerInGame(i)) continue;
            if (Distance(Player.TID, Players(i).TID) <= GetActorPropertyFixed(Players(i).TID, APROP_Radius) * 4.0)
            {
                NearPlayers = true;
                break;
            };
        };
        
        // Player Flashyness
        SetActorPropertyFixed(Player.TID, APROP_Alpha, 0.75 + (Sin(Timer() / 32.0) * 0.25));
        
        // Solidify
        if (!NearPlayers)
        {
            GiveInventory("DRPGPlayerTeleportNormal", 1);
            SetActorProperty(Player.TID, APROP_RenderStyle, STYLE_Normal);
            SetActorPropertyFixed(Player.TID, APROP_Alpha, 1.0);
        };
        
        Delay(1);
    };
};

// Fires a projectile from the Player
function bool FireProjectile(str Type)
{
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0);
    fixed Pitch = GetActorPitch(0);
    fixed Angle = GetActorAngle(0);
    fixed XSpeed = Cos(Angle) * 16.0;
    fixed YSpeed = Sin(Angle) * 16.0;
    fixed ZSpeed = -Sin(Pitch) * 16.0;
    fixed FireHeight = GetActorViewHeight(0) * 0.8;
    int TID = UniqueTID();
    
    SpawnProjectile(0, Type, 0, 0, 0, 0, TID);
    SetActorVelocity(TID, XSpeed, YSpeed, ZSpeed, 0, 0);
    SetActorAngle(TID, Angle);
    SetActorPosition(TID, X, Y, Z + FireHeight, 0);
    Thing_ChangeTID(TID, 0);
    
    return true;
};

// Emits a Nova from the Player
function bool Nova(str Type, int Projectiles)
{
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0);
    fixed Pitch = GetActorPitch(0);
    fixed Angle = GetActorAngle(0);
    fixed XSpeed = Cos(Angle) * 16.0;
    fixed YSpeed = Sin(Angle) * 16.0;
    fixed ZSpeed = -Sin(Pitch) * 16.0;
    fixed FireHeight = GetActorViewHeight(0) * 0.8;
    int TID = UniqueTID();
    fixed AngleAdd;
    
    AngleAdd = 1.0 / Projectiles;
    
    for (int i = 0; i < Projectiles; i++)
    {
        XSpeed = Cos(Angle) * 16.0;
        YSpeed = Sin(Angle) * 16.0;
        ZSpeed = -Sin(Pitch) * 16.0;
        
        SpawnProjectile(0, Type, 0, 0, 0, 0, TID);
        SetActorVelocity(TID, XSpeed, YSpeed, ZSpeed, 0, 0);
        SetActorAngle(TID, Angle);
        SetActorPosition(TID, X, Y, Z + FireHeight, 0);
        Thing_ChangeTID(TID, 0);
        
        Angle += AngleAdd;
    };
    
    return true;
};

// --------------------------------------------------
// Auras
// 

// Spawn the respective Aura effects on the given Player/Monster's TID
function void SpawnAuras(int TID, bool ForceFancy)
{
    static str[AURA_MAX] AuraActors =
    {
        "DRPGRedAura";
        "DRPGGreenAura";
        "DRPGWhiteAura";
        "DRPGPinkAura";
        "DRPGCyanAura";
        "DRPGPurpleAura";
        "DRPGOrangeAura";
        "DRPGBlueAura";
        "DRPGYellowAura";
    };
    
    fixed X = GetActorX(TID);
    fixed Y = GetActorY(TID);
    fixed Z = GetActorZ(TID);
    fixed Radius = GetActorPropertyFixed(TID, APROP_Radius);
    fixed Height = GetActorPropertyFixed(TID, APROP_Height);
    int Angle = GetActorAngle(TID) * 256;
    bool SpawnOK = false;
    bool IsPlayer = (ClassifyActor(TID) & ACTOR_PLAYER);
    int SimpleType = GetCVar("drpg_simple_auras");
    bool Simple = (IsPlayer ? (SimpleType == 1 || SimpleType == 3) : (SimpleType == 2 || SimpleType == 3));
    AuraInfo *PlayerAura = &Players(FindPlayerID(TID)).Aura;
    AuraInfo MonsterStatsSpace *MonsterAura = &Monsters[GetMonsterID(TID)].Aura;
    int AuraCount = 0;
    int AuraAdd = 0;
    
    // WHYYYYYYYYYYYYYYYYYYYYYYY.YPEG
    if (IsPlayer)
    {
        // Calculate number of active Auras
        for (int i = 0; i < AURA_MAX; i++)
            if (PlayerAura->Type[i].Active)
                AuraCount++;
        
        // Spawn the Aura
        if (AuraCount >= AURA_MAX) // Shadow
        {
            if (!Simple)
                SpawnForced("DRPGBlackAura", X, Y, Z + Height / 2.0, AuraTID, Angle)
            else
                SpawnForced("DRPGBlackAuraIndicator", X, Y, Z + Height + 12.0 + Sin(Timer() / 64.0) * 4.0, 0, Angle);
        }
        else // Normal
        {
            for (int i = 0; i < AURA_MAX; i++)
            {
                if (PlayerAura->Type[i].Active)
                {
                    // Create rotation for simple Aura icons
                    if (Simple && AuraCount > 1)
                    {
                        fixed AngleOffset = (1.0 / (fixed)AuraCount) * ((fixed)AuraAdd++ * 128.0);
                        X = GetActorX(TID) + Sin(((fixed)Timer() + AngleOffset) / 128.0) * (Radius * 2.0);
                        Y = GetActorY(TID) + Cos(((fixed)Timer() + AngleOffset) / 128.0) * (Radius * 2.0);
                        Z = GetActorZ(TID) + 4.0 + Sin(Timer() / 64.0) * 4.0;
                    };
                
                    // Spawn
                    if (!Simple)
                        SpawnForced(AuraActors[i], X, Y, Z + Height / 2.0, AuraTID, Angle)
                    else
                        SpawnForced(StrParam("%sIndicator\n", AuraActors[i]), X, Y, Z + Height + 8.0, 0, Angle);
                };
            };
        };
    }
    else // Monster
    {
        // Calculate number of active Auras
        for (int i = 0; i < AURA_MAX; i++)
            if (MonsterAura->Type[i].Active)
                AuraCount++;

        // Return if the monster is stealthy
        if (IsStealth(TID))
            return;
        
        // LOS Checks
        if (GameType() == GAME_SINGLE_PLAYER)
        {
            if (CheckSight(Players(0).TID, TID, CSF_NOBLOCKALL))
                SpawnOK = true;
        }
        else
        {
            for (int i = 0; i < MAX_PLAYERS; i++)
            {
                if (!PlayerInGame(i))
                    continue;
                
                if (CheckSight(Players(i).TID, TID, CSF_NOBLOCKALL))
                {
                    SpawnOK = true;
                    break;
                };
            };
        };
        
        // Return if LOS checks failed
        if (!SpawnOK)
            return;
        
        // Spawn the Aura
        if (GetActorProperty(TID, APROP_Friendly)) // Friendly
        {
            if (!Simple)
                SpawnForced("DRPGFriendlyAura", X, Y, Z + 32.0, 0, Angle)
            else
                SpawnForced("DRPGFriendlyIndicator", X, Y, Z + Height + 12.0 + Sin(Timer() / 64.0) * 4.0, 0, Angle);
        }
        else if (AuraCount >= AURA_MAX) // Shadow
        {
            if (!Simple)
                SpawnForced("DRPGBlackAura", X, Y, Z + Height / 2.0, AuraTID, Angle)
            else
                SpawnForced("DRPGBlackAuraIndicator", X, Y, Z + Height + 12.0 + Sin(Timer() / 64.0) * 4.0, 0, Angle);
        }
        else // Normal
        {
            for (int i = 0; i < AURA_MAX; i++)
                if (MonsterAura->Type[i].Active)
                {
                    // Create rotation for simple Aura icons
                    if (Simple && AuraCount > 1)
                    {
                        fixed AngleOffset = (1.0 / (fixed)AuraCount) * ((fixed)AuraAdd++ * 128.0);
                        X = GetActorX(TID) + Sin(((fixed)Timer() + AngleOffset) / 128.0) * (Radius * 2.0);
                        Y = GetActorY(TID) + Cos(((fixed)Timer() + AngleOffset) / 128.0) * (Radius * 2.0);
                        Z = GetActorZ(TID) + 4.0 + Sin(Timer() / 64.0) * 4.0;
                    };
                
                    // Spawn
                    if (!Simple)
                        SpawnForced(AuraActors[i], X, Y, Z + Height / 2.0, AuraTID, Angle)
                    else
                        SpawnForced(StrParam("%sIndicator\n", AuraActors[i]), X, Y, Z + Height + 8.0, 0, Angle);
                };
        };
    };
    
    // Pass Radius and Height to the Auras for DECORATE usage
    if (!Simple)
    {
        SetUserVariable(AuraTID, "user_radius", (int)Radius);
        SetUserVariable(AuraTID, "user_height", (int)Height);
    };
    
    // Remove the TID
    Thing_ChangeTID(AuraTID, 0);
};

// Returns whether a monster is in some form of stealth or not
function bool IsStealth(int tid)
{
    return
    (
        // Fuzzy
        GetActorProperty(tid, APROP_RenderStyle) == STYLE_Fuzzy ||
        GetActorProperty(tid, APROP_RenderStyle) == STYLE_OptFuzzy ||
        // Translucent
        (GetActorProperty(tid, APROP_RenderStyle) == STYLE_Translucent &&
            GetActorPropertyFixed(tid, APROP_Alpha) < 0.5) ||
        (GetActorProperty(tid, APROP_RenderStyle) == STYLE_TranslucentStencil &&
            GetActorPropertyFixed(tid, APROP_Alpha) < 0.5) ||
        (GetActorProperty(tid, APROP_RenderStyle) == STYLE_Add &&
            GetActorPropertyFixed(tid, APROP_Alpha) < 0.5) ||
        // Totally invisible
        GetActorProperty(tid, APROP_RenderStyle) == STYLE_None ||
        // Actor flags
        // These two cases are already handled by the RenderStyle checks above
        // CheckFlag(tid, "STEALTH") ||
        // CheckFlag(tid, "SHADOW") ||
        CheckFlag(tid, "INVISIBLE")
    );
};

function bool PlayerHasAura(int PlayerNum)
{
    bool HaveAura = false;
    
    for (int i = 0; i < AURA_MAX; i++)
        if (Players(PlayerNum).Aura.Type[i].Active)
        {
            HaveAura = true;
            break;
        };
    
    return HaveAura;
};

function bool MonsterHasAura(MonsterStatsPtr Stats)
{
    bool HaveAura = false;
    
    for (int i = 0; i < AURA_MAX; i++)
        if (Stats->Aura.Type[i].Active)
        {
            HaveAura = true;
            break;
        };
    
    return HaveAura;
};

function bool PlayerHasShadowAura(int PlayerNum)
{
    int AuraCount;
    
    for (int i = 0; i < AURA_MAX; i++)
        if (Player.Aura.Type[i].Active)
            AuraCount++;
    
    if (AuraCount >= AURA_MAX)
        return true
    else
        return false;
};

function bool MonsterHasShadowAura(MonsterStatsPtr Stats)
{
    int AuraCount;
    
    for (int i = 0; i < AURA_MAX; i++)
        if (Stats->Aura.Type[i].Active)
            AuraCount++;
    
    if (AuraCount >= AURA_MAX)
        return true
    else
        return false;
};

// --------------------------------------------------
// Drawing
// 

script void PrintTextWiggle(char *Text, int ID, int Color, int X, int Y, fixed HoldTime, fixed Speed, fixed Spacing, fixed Radius)
{
    int Time = (int)(HoldTime * 35.0);
    int TimeMax = Time;
    
    SetHudSize(640, 480, false);
    
    while (Time > 0)
    {
        for (int i = 0; Text[i] != NULL; i++)
        {
            fixed XOff = (fixed)X + (Spacing * i);
            fixed YOff = (fixed)Y + Sin((Timer() + i) / Speed) * Radius;
            HudMessage("%c\n", Text[i], HUDMSG_PLAIN | HUDMSG_ALPHA, ID + i, Color, (int)XOff, (int)YOff, 0.05, ((fixed)Time / (fixed)TimeMax));
        };
        
        Time--;
        Delay(1);
    };
};

// PrintSprite Utility Function
function void PrintSprite(str Sprite, int ID, fixed X, fixed Y, fixed DelayTime)
{
    SetFont(Sprite);
    HudMessage("A\n", HUDMSG_PLAIN, ID, CR_UNTRANSLATED, X, Y, DelayTime);
};

function void PrintSpriteFade(str Sprite, int ID, fixed X, fixed Y, fixed DelayTime, fixed HoldTime)
{
    SetFont(Sprite);
    HudMessage("A\n", HUDMSG_FADEOUT, ID, CR_UNTRANSLATED, X, Y, DelayTime, HoldTime);
};

function void PrintSpriteAlpha(str Sprite, int ID, fixed X, fixed Y, fixed DelayTime, fixed Alpha)
{
    SetFont(Sprite);
    HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA, ID, CR_UNTRANSLATED, X, Y, DelayTime, Alpha);
};

function void PrintSpritePulse(str Sprite, int ID, fixed X, fixed Y, fixed Alpha, fixed Speed, fixed Radius, bool AddBlend)
{
    SetFont(Sprite);
    
    if (AddBlend)
        HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA | HUDMSG_ADDBLEND, ID, CR_UNTRANSLATED, X, Y, 0.05, Alpha + (Sin((fixed)Timer() / Speed) * Radius))
    else
        HudMessage("A\n", HUDMSG_PLAIN | HUDMSG_ALPHA, ID, CR_UNTRANSLATED, X, Y, 0.05, Alpha + (Sin((fixed)Timer() / Speed) * Radius));
};

function void ClearMessage(int ID)
{
    HudMessage("\n", HUDMSG_PLAIN, ID, CR_WHITE, 0, 0, 0.05);
};

function void DrawPay(int Amount)
{
    SetFont("BIGFONT");
    SetHudSize(0, 0, false);
    HudMessage("+%d\n", Amount, HUDMSG_FADEOUT, PAY_ID, CR_GOLD, -0.12, 0.09, 4.0, 2.0);
};

function void DrawBattery()
{
    fixed X = GetCVarFixed("drpg_aug_x");
    fixed Y = GetCVarFixed("drpg_aug_y");
    int HoldTime = (GetCVar("drpg_aug_showbattery") ? 0.05 : 3.0);
    int FadeTime = (GetCVar("drpg_aug_showbattery") ? 0.05 : 2.0);
    
    SetHudSize(640, 480, false);
    PrintSpriteFade("AUGBATT", BATTERY_ID, X + 0.4, Y + 0.4, HoldTime, FadeTime);
    SetFont("BIGFONT");
    HudMessage("%d%%\n", Player.Augs.Battery, HUDMSG_FADEOUT, BATTERY_ID + 1, CR_YELLOW, X + 24.0, Y - 10.0, HoldTime, FadeTime);
};

function void DrawBar(str Fill, int X, int Y, int Amount, bool Pulse)
{
    for (int i = 0; i < Amount; i++)
        if (Pulse)
            PrintSpriteAlpha(Fill, 0, X + 0.1 + (i * 1.0), Y, 0.05, 0.75 + Sin((Timer() + i) / 32.0) * 0.25)
        else
            PrintSprite(Fill, 0, X + 0.1 + (i * 1.0), Y, 0.05);
};

// --------------------------------------------------
// Math
// 

// This function is specifically to avoid dividing by zero in the event that that can happen.
function int CalcPercent(int Current, int Max)
{
    if (Max == 0)
        return 100;
    return Current * 100 / Max;
};

// Computes n-th power of x
function int Pow(int x, int n)
{
    int y = 1;
    while (n-- > 0) y *= x;
    return y;
};

// Return the absolute value of a negative integer
function int Abs(int x)
{
    if (x < 0)
        return -x;

    return x;
};

// Rounds a fixed to the nearest integer
function int Round(fixed fixedNumber)
{
    return (int)(fixedNumber + 0.5);
};

// Gets the distance between two TIDs
function fixed Distance(int TID1, int TID2)
{
    fixed X = GetActorX(TID1) - GetActorX(TID2);
    fixed Y = GetActorY(TID1) - GetActorY(TID2);
    fixed Z = GetActorZ(TID1) - GetActorZ(TID2);
    
    return VectorLength(VectorLength(X, Y), Z);
};

// Gets the distance between two points on the HUD
function fixed DistanceScreen(int X1, int Y1, int X2, int Y2)
{
    fixed X = X1 - X2;
    fixed Y = Y1 - Y2;
    
    return VectorLength(X, Y);
};

// --------------------------------------------------
// Strings
// 

function bool StartsWith(str InString, str Prefix, bool NoCase)
{
    if (NoCase)
        return !StrICmp(InString, Prefix, StrLen(Prefix));
    return !StrCmp(InString, Prefix, StrLen(Prefix));
};

function bool EndsWith(str InString, str Suffix, bool NoCase)
{
    if (StrLen(InString) < StrLen(Suffix))
        return false;
    
    if (NoCase)
        return !StrICmp(StrRight(InString, StrLen(Suffix)), Suffix);
    return !StrCmp(StrRight(InString, StrLen(Suffix)), Suffix);
};

function bool Contains(str InString, str SubString, bool NoCase)
{
    int TargLen = StrLen(InString);
    int SubLen = StrLen(SubString);
    
    if (TargLen < SubLen)
        return false;
    
    for (int i = 0; i <= TargLen - SubLen; i++)
    {
        str Part = StrMid(InString, i, SubLen);
        if ((!NoCase && !StrCmp(Part, SubString)) || (NoCase && !StrICmp(Part, SubString)))
            return true;
    };
    
    return false;
};

// Formats time into MM:SS for display with Print or HudMessage
function str FormatTime(int t)
{
    int Hours = t / 35 / 60 / 60;
    int Minutes = t / 35 / 60 % 60;
    int Seconds = t / 35 % 60;
    str Time = "";
    
    // Hours
    if (Hours > 0)
        Time = StrParam("%d:\n", Hours);
    
    // Minutes
    if (Hours > 0 && Minutes < 10)
        Time = StrParam("%s0%d:\n", Time, Minutes)
    else
        Time = StrParam("%s%d:\n", Time, Minutes);
    
    // Seconds
    if (Seconds < 10)
        Time = StrParam("%s0%d\n", Time, Seconds)
    else
        Time = StrParam("%s%d\n", Time, Seconds);
    
    return Time;
};

// --------------------------------------------------
// Debugging/Cheats
// 

// HAAAAAAAAAAAAAAAX
acscript void Cheat(int StatBoost)
{
    // gg no re
    if (StatBoost == 0)
    {
        Player.ActualHealth = 0;
        ActivatorSound("mission/gottarget2", 127);
        return;
    };
    
    // Max Level/Rank
    Player.XP = XPTable[MAX_LEVEL - 1];
    Player.Rank = RankTable[MAX_RANK - 1];
    Player.PayBonus = 1000;
    
    // Stats
    Player.Strength = StatBoost;
    Player.Defense = StatBoost;
    Player.Vitality = StatBoost;
    Player.Energy = StatBoost;
    Player.Regeneration = StatBoost;
    Player.Agility = StatBoost;
    Player.Capacity = StatBoost;
    Player.Luck = StatBoost;
    
    // Max out all Skills
    for (int i = 0; i < MAX_CATEGORIES; i++)
        for (int j = 0; j < MAX_SKILLS; j++)
        {
            Player.SkillLevel[i][j].Level = Skills[i][j].MaxLevel;
            Player.SkillLevel[i][j].CurrentLevel = Skills[i][j].MaxLevel;
        };
    
    // Items - Tokens
    SetInventory("DRPGStatToken", 10000);
    SetInventory("DRPGStatCapToken", 100);
    SetInventory("DRPGSkillToken", 10000);
    
    // Items - Powerups
    SetInventory("PowerInvulnerable", 1);
    SetInventory("PowerShadow", 1);
    SetInventory("PowerIronFeet", 1);
    SetInventory("PowerLightAmp", 1);
    SetInventory("PowerStrength", 1);
    
    // Items - Ammo
    SetInventory("Clip", GetAmmoCapacity("Clip") * 2);
    SetInventory("Shell", GetAmmoCapacity("Shell") * 2);
    SetInventory("RocketAmmo", GetAmmoCapacity("RocketAmmo") * 2);
    SetInventory("Cell", GetAmmoCapacity("Cell") * 2);
    
    // Items - Keys
    SetInventory("DRPGRedCard", 1);
    SetInventory("DRPGYellowCard", 1);
    SetInventory("DRPGBlueCard", 1);
    SetInventory("DRPGRedSkull", 1);
    SetInventory("DRPGYellowSkull", 1);
    SetInventory("DRPGBlueSkull", 1);
    
    // Items - Stims
    SetInventory("DRPGStimSmall", 1000);
    SetInventory("DRPGStimMedium", 1000);
    SetInventory("DRPGStimLarge", 1000);
    SetInventory("DRPGStimXL", 1000);
    SetInventory("DRPGStimDetox", 1000);
    
    // Items - Misc
    SetInventory("DRPGContinue", 1000);
    SetInventory("DRPGChipGold", 1000);
    SetInventory("DRPGChipPlatinum", 1000);
    GiveAugs(100, 100, 100);
    GiveCredits(0);
    FullShield();
    GiveCompounds(40000);
    
    // Restore HP/EP/Shields
    Player.ActualHealth = Player.HealthMax * 2;
    Player.EP = Player.EPMax;
    Player.Shield.Charge = Player.Shield.Capacity;
    Player.Shield.Timer = 0;
};

// For testing different stats and their effects
acscript void ModStat(int Stat, int Value)
{
    switch (Stat)
    {
    case STAT_STRENGTH + 1:     Player.Strength = Value;        break;
    case STAT_DEFENSE + 1:      Player.Defense = Value;         break;
    case STAT_VITALITY + 1:     Player.Vitality = Value;        break;
    case STAT_ENERGY + 1:       Player.Energy = Value;          break;
    case STAT_REGENERATION + 1: Player.Regeneration = Value;    break;
    case STAT_AGILITY + 1:      Player.Agility = Value;         break;
    case STAT_CAPACITY + 1:     Player.Capacity = Value;        break;
    case STAT_LUCK + 1:         Player.Luck = Value;            break;
    };
};

// Give Credits
acscript void GiveCredits(int Amount)
{
    if (Amount == 0) Amount = 1000000000;
    GiveInventory("DRPGCredits", Amount);
    ActivatorSound("credits/payout", 127);
};

// Instant payout
acscript void Payout(int Time)
{
    if (Time > 0)
        Player.PayTimer = Time
    else
        Player.PayTimer = 0;
};

// Shuffle the Shop Special
acscript void ShopSpecialShuffle()
{
    ShopSpecialTimer = 0;
};

// Give all Augs
acscript void GiveAugs(int Canisters, int Upgrades, int Slots)
{
    GiveInventory("DRPGAugCanister", Canisters);
    GiveInventory("DRPGAugUpgradeCanister", Upgrades);
    GiveInventory("DRPGAugSlotUpgrade", Slots);
    
    for (int i = 0; i < MAX_AUGS; i++)
    {
        AugInfoPtr AugPtr = &AugData[i];
        Player.Augs.Level[i] = AugPtr->MaxLevel;
    };
};

// Give all Shield Components
acscript void FullShield()
{
    // Bodies
    for (int i = 0; i < ShieldPartsMax[0]; i++)
    {
        ShieldPartPtr Part = &ShieldParts[0][i];
        GiveInventory(Part->Actor, 1);
    };
    
    // Batteries
    for (int i = 0; i < ShieldPartsMax[1]; i++)
    {
        ShieldPartPtr Part = &ShieldParts[1][i];
        GiveInventory(Part->Actor, 1);
    };

    // Capacitors
    for (int i = 0; i < ShieldPartsMax[2]; i++)
    {
        ShieldPartPtr Part = &ShieldParts[2][i];
        GiveInventory(Part->Actor, 1);
    };
    
    // Accessories
    for (int i = 0; i < MAX_ACCESSORIES; i++)
    {
        ShieldAccsPtr Accessory = &ShieldAccessories[i];
        GiveInventory(Accessory->Actor, 1);
    };
};

// Full Locker
acscript void FullLocker(int Amount)
{
    for (int i = 0; i < ItemCategories; i++)
        for (int j = 0; j < ItemMax[i]; j++)
        {
            ItemInfoPtr ItemPtr = &ItemData[i][j];
            Player.Locker[i][j] = Amount;
        };
};

// Give all Stim Compounds
acscript void GiveCompounds(int Amount)
{
    for (int i = 0; i < MAX_COMPOUNDS; i++)
        if (Amount == 0)
            Player.Stim.Vials[i] = Player.Capacity * 10
        else
            Player.Stim.Vials[i] += Amount;
};

// --------------------------------------------------
// System
// 

function void CreateTranslations()
{
    // Damage Numbers - Critical
    CreateTranslationStart(DNUM_CRITICAL);
    CreateTranslationPalette(81, 111, 176, 176);
    CreateTranslationEnd();
    
    // Damage Numbers - Healed
    CreateTranslationStart(DNUM_HEAL);
    CreateTranslationPalette(81, 111, 112, 112);
    CreateTranslationEnd();

    // Damage Numbers - Scratch
    CreateTranslationStart(DNUM_SCRATCH);
    CreateTranslationPalette(81, 111, 100, 100);
    CreateTranslationEnd();
    
    // Credit Gain
    CreateTranslationStart(DNUM_CREDGAIN);
    CreateTranslationPalette(81, 111, 249, 249);
    CreateTranslationEnd();

    // Credit Loss
    CreateTranslationStart(DNUM_CREDLOSS);
    CreateTranslationPalette(81, 111, 248, 248);
    CreateTranslationEnd();
    
    // EP Gain
    CreateTranslationStart(DNUM_EPGAIN);
    CreateTranslationPalette(81, 111, 196, 196);
    CreateTranslationEnd();
    
    // EP Loss
    CreateTranslationStart(DNUM_EPLOSS);
    CreateTranslationPalette(81, 111, 200, 200);
    CreateTranslationEnd();
    
    // Shield Gain
    CreateTranslationStart(DNUM_SHIELDGAIN);
    CreateTranslationPalette(81, 111, 250, 250);
    CreateTranslationEnd();
    
    // Shield Loss
    CreateTranslationStart(DNUM_SHIELDLOSS);
    CreateTranslationPalette(81, 111, 251, 251);
    CreateTranslationEnd();
};

function bool CheckInput(int Key, int State)
{
    int Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
    int OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
    
    if (State == KEY_PRESSED)
        return (Buttons & Key && !(Buttons & Key));
    if (State == KEY_ONLYPRESSED)
        return (Buttons == Key && Buttons != Key);
    if (State == KEY_DOWN)
        return (Buttons & Key);
    if (State == KEY_UP)
        return (OldButtons & Key);
};

// This shit doesn't work at all because ZDoom is fucking stupid or something, fuck if I know
function void LogMessage(str Message, int Level)
{
    bool DebugMode = (ActivatorTID() == Player.TID ? GetCVar("drpg_debug") : GetUserCVar(PlayerNumber(), "drpg_debug"));
    
    if (Level == LOG_DEBUG)
        Message = StrParam("\cdDEBUG: \c-%s\n", Message);
    if (Level == LOG_WARNING)
        Message = StrParam("\ciWARNING: \c-%s\n", Message);
    if (Level == LOG_ERROR)
        Message = StrParam("\cgERROR: \c-%s\n", Message);
    
    // Don't log the message if the caller isn't in Debug Mode
    if (Level == LOG_DEBUG && !DebugMode)
        return;
    
    Log("%s\n", Message);
};

// --------------------------------------------------
// Dynamic Arrays
// 

function void ArrayCreate(DynamicArray *Array, char[5] Name, int InitSize, int ItemSize)
{
    if (Array->Data != nullptr)
        ArrayDestroy(Array);
    
    Array->Name = Name;
    
    if (GetCVar("drpg_debug"))
        Log("\cdDynamicArray: Allocating \cj%s\n", Array->Name);
    
    Array->Position = 0;
    Array->Size = InitSize;
    Array->ItemSize = ItemSize;
    Array->Data = Z_Malloc(Array->ItemSize * Array->Size, PU_STATIC, NULL);
    
    if (!Array->Data)
    {
        Log("\cgERROR: \c-Could not allocate space for array \cj%s\n", Array->Name);
        return;
    };
    
    if (GetCVar("drpg_debug"))
        Log("\cdDynamicArray: \cj%s\cd @ %p\n", Array->Name, Array->Data);
    
    memset(Array->Data, 0xAAAAAAAA, Array->Size * Array->ItemSize);
};

function void ArrayResize(DynamicArray *Array)
{
    if (Array->Data == nullptr)
    {
        Log("\cgERROR: \c-Tried to resize destroyed array \cj%s\n", Array->Name);
        return;
    };
    
    int OldSize = Array->Size;
    
    Array->Size *= 2;
    void *tmp = Z_Realloc(Array->Data, Array->ItemSize * Array->Size, PU_STATIC, NULL);
    
    if (!tmp)
    {
        Z_Free(Array->Data);
        Log("\cgERROR: \c-Cannot resize dynamic array \cj%s\n", Array->Name);
        return;
    };
    
    if (GetCVar("drpg_debug"))
        Log("\cdDynamicArray: Resizing array \cj%s\cd @ %p to \cj%d\cd elements\n", Array->Name, Array->Data, Array->Size);
    
    Array->Data = tmp;
    
    memset((char *)Array->Data + (Array->ItemSize * OldSize), 0xAAAAAAAA, (Array->Size * Array->ItemSize) - (Array->ItemSize * OldSize));
};

function void ArrayDestroy(DynamicArray *Array)
{
    if (GetCVar("drpg_debug"))
        Log("\cdDynamicArray: Destroying array \cj%s\cd @ %p\n", Array->Name, Array->Data);
    
    Z_Free(Array->Data);
    
    Array->Position = 0;
    Array->Size = 0;
    Array->ItemSize = 0;
    Array->Data = nullptr;
};

function void ArrayDump(DynamicArray *Array)
{
    Log("\ciDynamicArray \cj%s\c- @ %p\n", Array->Name, Array->Data);
    Log("\cd* Array size: \cj%d\n", Array->Size);
    Log("\cd* Item bytesize: \cj%d\n", Array->ItemSize);
    Log("\cd* End Position: \cj%d\n", Array->Position);
    Log("\n");
    
    Log("\ciItem data:\n");
    
    for (int i = 0; i < Array->Size; i++)
    {
        str DataString = StrParam("  %X: \n", i);
        for (int b = 0; b < Array->ItemSize; b++)
            DataString = StrParam("%s%X \n", DataString, (char)((char *)Array->Data)[Array->ItemSize * i + b]);
        
        if (i >= Array->Position)
            DataString = StrParam("%s\cj(\cgUnused\cj)\n", DataString);
        
        Log("%s\n", DataString);
    };
};
