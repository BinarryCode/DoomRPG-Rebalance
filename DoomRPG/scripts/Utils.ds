#include "AugData.dh"
#include "Augs.dh"
#include "Defs.dh"
#include "Globals.dh"
#include "RPG.dh"
#include "Shield.dh"
#include "Skills.dh"
#include "Stats.dh"
#include "Utils.dh"

int MapNumber;
int AuraTID = 20000;

// Skill Level Names
str[6] SkillLevels =
{
	"Easy";
	"Normal";
	"Hard";
	"Nightmare";
	"Hell";
};

acscript SetDamageType(int Type)
{
	Player.DamageType = Type;
};

// Add Toxicity to the Player
acscript AddToxicity(int Amount, bool Flash)
{
	Player.Toxicity += Amount;
	
	if (Flash)
		FadeRange(0, 255, 0, 0.25, 0, 255, 0, 0.0, 0.5);
};

// Get the max inventory size
acscript int CheckInventoryMax()
{
	return Player.Capacity * 5;
};

// Used for handling inventory items using the Capacity stat
acscript int CheckCapacity()
{
	int Items = 0;
	int MaxItems = CheckInventoryMax();
	
	// Don't do checks if you don't have the system disabled
	if (!GetCVar("drpg_inv_capacity")) return false;
	
	str[] ItemList =
	{
		// Health
		"Stimpack";
		"Medikit";
		"LargeMedikit";
		"XLMedikit";
		"MedPack";
		"SurgeryKit";
		
		// Armor
		"GreenArmor";
		"UsedGreenArmor";
		"BlueArmor";
		"UsedBlueArmor";
		"YellowArmor";
		"UsedYellowArmor";
		"RedArmor";
		"UsedRedArmor";
		"WhiteArmor";
		"UsedWhiteArmor";
		
		// Powerups
		"InvulnerabilitySphere";
		"InvulnerabilityCharge";
		"BlurSphere";
		"InvisibilityCharge";
		"RegenSphere";
		"RadSuit";
		"Infrared";
		"AllMap";
		"Berserk";
		"Wings";
		
        // Batteries
        "BatterySmall";
        "BatteryLarge";
        
		// DoomRL - Powerups
		"InvulnerabilitySphere2";
		"InvulnerabilityCharge2";
		"RadSuit2";
		"InvisibilityCharge2";
		"RadSuit2";
		"Infrared2";
		"Berserk2";

		// Sentinel (Indicates end of list)
		"";
	};
	
	for (int i = 0; ItemList[i] != ""; i++)
		if (CheckInventory(ItemList[i]) > 0)
			Items += CheckInventory(ItemList[i]);
	
	Player.InvItems = Items;
	
	if (Items >= MaxItems)
		return false
	else
		return true;
};

// Return Timer() for DECORATE
acscript int GetTimer()
{
	return Timer();
};

// Set Skill Level during the game
acscript SetSkill(int NewSkill)
{
	SetFont("BIGFONT");
	
	if (NewSkill < 0 || NewSkill > (GetCVar("drpg_ext_doomrl") ? 5 : 4))
	{
		HudMessage("Invalid Skill Level\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
		return;
	};
	
	FadeRange(255, 255, 255, 0.5, 255, 255, 255, 0.0, 0.5);
	ChangeSkill(NewSkill);
	ActivatorSound("misc/secret", 127);
	HudMessageBold("\cjSkill Level has been changed to\n\cg%d - %s\n", NewSkill + 1, SkillLevels[NewSkill],
				   HUDMSG_FADEOUT, 0, CR_WHITE, 1.5, 0.5, 2.0, 1.0);
};

// Respec - Respecialize your Player
acscript Respec(bool DoStats, bool DoSkills)
{
	// Vars
	int StatPoints;
	int SkillPoints;
	int OldCredits;
	
	// Respec Stats
	if (DoStats)
	{
		// Add stats into a pool of tokens to give back to the player
		StatPoints += Player.Strength;
		StatPoints += Player.Defense;
		StatPoints += Player.Vitality - 10;
		StatPoints += Player.Energy - 10;
		StatPoints += Player.Regeneration;
		StatPoints += Player.Agility;
		StatPoints += Player.Capacity - 10;
		StatPoints += Player.Luck;
		
		// Reset Stats
		Player.Strength = 0;
		Player.Defense = 0;
		Player.Vitality = 10;
		Player.Energy = 10;
		Player.Regeneration = 0;
		Player.Agility = 0;
		Player.Capacity = 10;
		Player.Luck = 0;

		// Give Respecced Stat Tokens back
		GiveInventory("StatToken", StatPoints);

		// Reset HP and EP
		SetActorProperty(Player.TID, APROP_Health, 100);
		Player.EPMax = 100;
		Player.EP = Player.EPMax;
		
		// Reset Shield
		Player.Shield.Charge = 0;
		Player.Shield.Timer = 375;
	};
	
	// Respec Skills
	if (DoSkills)
	{
		// Reset skills, add skill levels together into a pool of tokens to give back to the player
		for (int i = 0; i < MAX_CATEGORIES; i++)
			for (int j = 0; j < MAX_SKILLS; j++)
			{
				SkillPoints += Skills[i][j].Level;
				Skills[i][j].Level = 0;
				Skills[i][j].CurrentLevel = 0;
			};

		// Give Respecced Skill Tokens back
		GiveInventory("SkillToken", SkillPoints);

		// Remove Auras
		Player.Aura = 0;
		Player.AuraTimer = 0;
	};
	
	// Take 1/2 Credits
	GiveInventory("Credits", OldCredits);
	TakeInventory("Credits", CheckInventory("Credits") / 2);
	
	// FX
	FadeRange(255, 255, 255, 0.75, 0, 0, 0, 0.0, 2.5);
	HudMessage("Respec Complete\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.5, 2.5, 2.5);
	ActivatorSound("misc/secret", 127);
};

acscript AddEP(int Amount)
{
    if (Amount > 0)
        FadeRange(0, 255, 255, 0.25, 0, 255, 255, 0, 0.25);
    
	Player.EP += Amount;
    
	if (Player.EP > Player.EPMax)
		Player.EP = Player.EPMax;
};

acscript RemoveEP(int Percent)
{
    Player.EP -= ((Player.EP * Percent) / 100);
};

// Returns your current EP (for DECORATE)
acscript int GetEP()
{
	return Player.EP;
};

// Gets Max EP (for DECORATE)
acscript int GetEPMax()
{
	return Player.EPMax;
};

// Returns the amount to heal given the percentage out of max HP (for DECORATE)
acscript int GetHealPercent(int Percent)
{
	return Player.HealthMax * Percent / 100;
};

// Returns your max Health (for DECORATE)
acscript int GetHealthMax()
{
	return Player.HealthMax;
};

// Returns the capacity of your current Shield (for DECORATE)
acscript int GetShieldMax()
{
	return Player.Shield.Capacity;
};

// Returns the Agility for A_SetTics calls in DECORATE
acscript int GetSpeed(int Tics)
{
	return Tics - ((Tics - 1) / 100) * Player.Agility;
};

// Used by DECORATE to check if both your Health and EP are at max
acscript bool HPEPMax()
{
	return (GetActorProperty(Player.TID, APROP_Health) >= GetActorProperty(Player.TID, APROP_SpawnHealth) && Player.EP >= Player.EPMax);
};

// Used by the RegenSphere to temporarily increase regen rates
acscript RegenBoost()
{
	Player.RegenBoostTimer += (35 * 5) + ((Player.Regeneration / 13.33) * 35);
};

// HAAAAAAAAAAAAAAAX
acscript Cheat(int StatBoost)
{
	int ItemMax = 1000;
	
	// Max Level/Rank
	Player.XP = XPTable[MAX_LEVEL - 1];
	Player.Rank = RankTable[MAX_RANK - 2];
	
	// Stats
	Player.Strength += StatBoost;
	Player.Defense += StatBoost;
	Player.Vitality += StatBoost;
	Player.Energy += StatBoost;
	Player.Regeneration += StatBoost;
	Player.Agility += StatBoost;
	Player.Capacity += StatBoost;
	Player.Luck += StatBoost;
	
	// Max out all Skills
	for (int i = 0; i < MAX_CATEGORIES; i++)
		for (int j = 0; j < MAX_SKILLS; j++)
		{
			Skills[i][j].Level = Skills[i][j].MaxLevel;
			Skills[i][j].CurrentLevel = Skills[i][j].MaxLevel;
		};
	
	// Items - Tokens
	GiveInventory("StatToken", 10000);
	GiveInventory("StatCapToken", 100);
	GiveInventory("SkillToken", 10000);
	
	// Checck Stat Caps
	CheckStatCaps();

	// Items - Health
	GiveInventory("StimPack", ItemMax);
	GiveInventory("Medikit", ItemMax);
	GiveInventory("LargeMedikit", ItemMax);
	GiveInventory("XLMedikit", ItemMax);
	GiveInventory("MedPack", ItemMax);
	GiveInventory("SurgeryKit", ItemMax);
	GiveInventory("Continue", ItemMax);
	
	// Items - Armor
	if (!GetCVar("drpg_ext_doomrl"))
	{
		TakeInventory("BasicArmor", 10000000);
		GiveInventory("WhiteArmor", 1);
		Delay(1);
		for (int k = 0; k < ItemMax; k++)
		{
			GiveInventory("UsedGreenArmor", ItemMax);
			GiveInventory("GreenArmor", ItemMax);
			GiveInventory("UsedBlueArmor", ItemMax);
			GiveInventory("BlueArmor", ItemMax);
			GiveInventory("UsedYellowArmor", ItemMax);
			GiveInventory("YellowArmor", ItemMax);
			GiveInventory("UsedRedArmor", ItemMax);
			GiveInventory("RedArmor", ItemMax);
			GiveInventory("UsedWhiteArmor", ItemMax);
			GiveInventory("WhiteArmor", ItemMax);
		};
	};
	
	// Items - Powerups
	GiveInventory("InvulnerabilitySphere", ItemMax);
	GiveInventory("InvulnerabilityCharge", ItemMax);
	GiveInventory("BlurSphere", ItemMax);
	GiveInventory("InvisibilityCharge", ItemMax);
	GiveInventory("RadSuit", ItemMax);
	GiveInventory("Infrared", ItemMax);
	GiveInventory("Berserk", ItemMax);
	GiveInventory("PowerStrength", 1);
	GiveInventory("AllMap", ItemMax);
	
	// Items - Ammo
	GiveInventory("Clip", GetAmmoCapacity("Clip"));
	GiveInventory("Shell", GetAmmoCapacity("Shell"));
	GiveInventory("RocketAmmo", GetAmmoCapacity("RocketAmmo"));
	GiveInventory("Cell", GetAmmoCapacity("Cell"));
	
	// Items - Misc
	GiveAugs(100, 100, 100);
	GiveCredits(0);
	FullShield();
	GiveInventory("RedCard", 1);
	GiveInventory("YellowCard", 1);
	GiveInventory("BlueCard", 1);
	GiveInventory("RedSkull", 1);
	GiveInventory("YellowSkull", 1);
	GiveInventory("BlueSkull", 1);
	GiveInventory("PowerInvulnerable", 1);
	GiveInventory("PowerShadow", 1);
	GiveInventory("PowerIronFeet", 1);
	GiveInventory("PowerLightAmp", 1);
	
	// Stims
	GiveInventory("StimSmall", ItemMax);
	GiveInventory("StimMedium", ItemMax);
	GiveInventory("StimLarge", ItemMax);
	GiveInventory("StimXL", ItemMax);
	
	// Restore HP/EP/Shields
	HealThing(1000000);
	Player.EP = Player.EPMax;
	Player.Shield.Charge = Player.Shield.Capacity;
	Player.Shield.Timer = 0;
};

// For testing different stats and their effects
acscript ModStat(int Stat, int Value)
{
	switch (Stat)
	{
		case 1:	Player.Strength = Value;		break;
		case 2:	Player.Defense = Value;			break;
		case 3:	Player.Vitality = Value;		break;
		case 4:	Player.Energy = Value;			break;
		case 5:	Player.Regeneration = Value;	break;
		case 6:	Player.Agility = Value;			break;
		case 7:	Player.Capacity = Value;		break;
		case 8:	Player.Luck = Value;			break;
	};
};

// Give Credits
acscript GiveCredits(int Amount)
{
	if (Amount == 0) Amount = 1000000000;
	GiveInventory("Credits", Amount);
	ActivatorSound("credits/payout", 127);
};

// Instant payout
acscript Payout(int Time)
{
	if (Time > 0)
		Player.PayTimer = Time
	else
		Player.PayTimer = 0;
};

// Shuffle the Shop Special
acscript ShopSpecialShuffle()
{
	ShopSpecialTimer = 0;
};

// Give all Augs
acscript GiveAugs(int Canisters, int Upgrades, int Slots)
{
	if (Canisters)
	{
		GiveInventory("AugCanister", Canisters);
		GiveInventory("AugUpgradeCanister", Upgrades);
		GiveInventory("AugSlotUpgrade", Slots);
	};
	
	for (int i = 0; i < MAX_AUGS; i++)
		Player.Augs.Level[i] = AugData[i].MaxLevel;
};

// Give all Shield Components
acscript FullShield()
{
	// Bodies
	GiveInventory("ShieldBody1", 1);
	GiveInventory("ShieldBody2", 1);
	GiveInventory("ShieldBody3", 1);
	GiveInventory("ShieldBody4", 1);
	GiveInventory("ShieldBody5", 1);
	GiveInventory("ShieldBody6", 1);
	GiveInventory("ShieldBody7", 1);
	
	// Batteries
	GiveInventory("ShieldBattery1", 1);
	GiveInventory("ShieldBattery2", 1);
	GiveInventory("ShieldBattery3", 1);
	GiveInventory("ShieldBattery4", 1);
	GiveInventory("ShieldBattery5", 1);
	GiveInventory("ShieldBattery6", 1);
	GiveInventory("ShieldBattery7", 1);

	// Capacitors
	GiveInventory("ShieldCapacitor1", 1);
	GiveInventory("ShieldCapacitor2", 1);
	GiveInventory("ShieldCapacitor3", 1);
	GiveInventory("ShieldCapacitor4", 1);
	GiveInventory("ShieldCapacitor5", 1);
	
	// Accessories
	GiveInventory("ShieldAccessory1", 1);
	GiveInventory("ShieldAccessory2", 1);
	GiveInventory("ShieldAccessory3", 1);
	GiveInventory("ShieldAccessory4", 1);
	GiveInventory("ShieldAccessory5", 1);
	GiveInventory("ShieldAccessory6", 1);
	GiveInventory("ShieldAccessory7", 1);
};

// Give all Stim Compounds
acscript GiveCompounds(int Amount)
{
	for (int i = 0; i < MAX_COMPOUNDS; i++)
		if (Amount > 0)
			Player.Stim.Vials[i] += Amount
		else
			Player.Stim.Vials[i] = Player.Capacity * 10;
};

// For thrusting things with more realistic momentum handling
acscript ThrustMomentum()
{
	fixed VelocityX = GetActorVelX(0);
	fixed VelocityY = GetActorVelY(0);
	fixed Angle = VectorAngle(VelocityX, VelocityY);
	int Force = Abs(VelocityX) + Abs(VelocityY);

	ThrustThing(Angle * 256, Force * 3, 0, 0);
	ThrustThingZ(0, Force * 4, 0, 1);
   
	Delay(3);
};

function void CreateTranslations()
{
	// Damage Numbers - Critical
	CreateTranslationStart(DNUM_CRITICAL);
	CreateTranslationPalette(81, 111, 176, 176);
	CreateTranslationEnd();
	
	// Damage Numbers - Healed
	CreateTranslationStart(DNUM_HEAL);
	CreateTranslationPalette(81, 111, 112, 112);
	CreateTranslationEnd();

	// Damage Numbers - Scratch
	CreateTranslationStart(DNUM_SCRATCH);
	CreateTranslationPalette(81, 111, 100, 100);
	CreateTranslationEnd();
	
	// Credit Gain
	CreateTranslationStart(DNUM_CREDGAIN);
	CreateTranslationPalette(81, 111, 249, 249);
	CreateTranslationEnd();

	// Credit Loss
	CreateTranslationStart(DNUM_CREDLOSS);
	CreateTranslationPalette(81, 111, 248, 248);
	CreateTranslationEnd();
	
	// EP Gain
	CreateTranslationStart(DNUM_EPGAIN);
	CreateTranslationPalette(81, 111, 196, 196);
	CreateTranslationEnd();
	
	// EP Loss
	CreateTranslationStart(DNUM_EPLOSS);
	CreateTranslationPalette(81, 111, 200, 200);
	CreateTranslationEnd();
	
	// Shield Gain
	CreateTranslationStart(DNUM_SHIELDGAIN);
	CreateTranslationPalette(81, 111, 250, 250);
	CreateTranslationEnd();
	
	// Shield Loss
	CreateTranslationStart(DNUM_SHIELDLOSS);
	CreateTranslationPalette(81, 111, 251, 251);
	CreateTranslationEnd();
};

// Drop your entire inventory on the ground
function void DropInventory()
{
	DroppedItem[] ItemList =
	{
		// Health
		{ "Stimpack"; };
		{ "Medikit"; };
		{ "LargeMedikit"; };
		{ "XLMedikit"; };
		{ "MedPack"; };
		{ "SurgeryKit"; };
		{ "Continue"; };
		
		// Armor
		{ "GreenArmor"; };
		{ "UsedGreenArmor"; };
		{ "BlueArmor"; };
		{ "UsedBlueArmor"; };
		{ "YellowArmor"; };
		{ "UsedYellowArmor"; };
		{ "RedArmor"; };
		{ "UsedRedArmor"; };
		{ "WhiteArmor"; };
		{ "UsedWhiteArmor"; };
		
		// Powerups
		{ "InvulnerabilitySphere"; };
		{ "InvulnerabilityCharge"; };
		{ "BlurSphere"; };
		{ "InvisibilityCharge"; };
		{ "RegenSphere"; };
		{ "RadSuit"; };
		{ "Infrared"; };
		{ "AllMap"; };
		{ "Berserk"; };
		{ "Wings"; };
		{ "StimSmall"; };
		{ "StimMedium"; };
		{ "StimLarge"; };
		
		// DoomRL - Powerups
		{ "InvulnerabilitySphere2"; };
		{ "RadSuit2"; };
		{ "Infrared2"; };
		{ "Berserk2"; };

		// DoomRL - Modpacks
		{ "RLPowerModItem"; };
		{ "RLBulkModItem"; };
		{ "RLAgilityModItem"; };
		{ "RLTechnicalModItem"; };
		{ "RLSniperModItem"; };
		{ "RLFirestormModItem"; };
		{ "RLNanoModItem"; };
		{ "RLOnyxModItem"; };
		{ "RLArmorModItem"; };
		{ "RLModLimit"; true; true; 4; };
		{ "RLScavengerModLimit"; true; true; 8; };
		{ "RLArmorModItemInInventory"; true; };
		
		// Sentinel (Indicates end of list)
		{ ""; };
	};
	
	for (int i = 0; ItemList[i].Actor != ""; ++i)
		for (int j = 0; j < CheckInventory(ItemList[i].Actor); j++)
		{
			// Limit the drops if you have more than 25 to prevent massive amounts of lag
			if (j >= 25) break;
			
			if (ItemList[i].TakeAll)
				TakeInventory(ItemList[i].Actor, ItemList[i].Max)
			else
				TakeInventory(ItemList[i].Actor, 1);
			
			if (!ItemList[i].NoDrop)
				DropItem(0, ItemList[i].Actor, 1, 255);
		};
};

// Fires a projectile from the Player
function bool FireProjectile(str Type)
{
	fixed X = GetActorX(0);
	fixed Y = GetActorY(0);
	fixed Z = GetActorZ(0);
	fixed Pitch = GetActorPitch(0);
	fixed Angle = GetActorAngle(0);
	fixed XSpeed = Cos(Angle) * 16.0;
	fixed YSpeed = Sin(Angle) * 16.0;
	fixed ZSpeed = -Sin(Pitch) * 16.0;
	fixed FireHeight = GetActorViewHeight(0) * 0.8;
	int TID = UniqueTID();
	
	SpawnProjectile(0, Type, 0, 0, 0, 0, TID);
	SetActorVelocity(TID, XSpeed, YSpeed, ZSpeed, 0, 0);
	SetActorAngle(TID, Angle);
	SetActorPosition(TID, X, Y, Z + FireHeight, 0);
	Thing_ChangeTID(TID, 0);
	
	return true;
};

// Emits a Nova from the Player
function bool Nova(str Type, int Projectiles)
{
	fixed X = GetActorX(0);
	fixed Y = GetActorY(0);
	fixed Z = GetActorZ(0);
	fixed Pitch = GetActorPitch(0);
	fixed Angle = GetActorAngle(0);
	fixed XSpeed = Cos(Angle) * 16.0;
	fixed YSpeed = Sin(Angle) * 16.0;
	fixed ZSpeed = -Sin(Pitch) * 16.0;
	fixed FireHeight = GetActorViewHeight(0) * 0.8;
	int TID = UniqueTID();
	fixed AngleAdd;
	
	AngleAdd = 1.0 / Projectiles;
	
	for (int i = 0; i < Projectiles; i++)
	{
		XSpeed = Cos(Angle) * 16.0;
		YSpeed = Sin(Angle) * 16.0;
		ZSpeed = -Sin(Pitch) * 16.0;
		
		SpawnProjectile(0, Type, 0, 0, 0, 0, TID);
		SetActorVelocity(TID, XSpeed, YSpeed, ZSpeed, 0, 0);
		SetActorAngle(TID, Angle);
		SetActorPosition(TID, X, Y, Z + FireHeight, 0);
		Thing_ChangeTID(TID, 0);
		
		Angle += AngleAdd;
	};
	
	return true;
};

// PrintSprite Utility Function
function void PrintSprite(str sprite, int id, fixed x, fixed y, fixed d)
{
	SetFont(sprite);
	HudMessage("A\n", HUDMSG_PLAIN, id, CR_UNTRANSLATED, x, y, d);
};

function void PrintSpriteFade(str sprite, int id, fixed x, fixed y, fixed d, fixed h)
{
	SetFont(sprite);
	HudMessage("A\n", HUDMSG_FADEOUT, id, CR_UNTRANSLATED, x, y, d, h);
};

function void ClearMessage(int ID)
{
	HudMessage("\n", HUDMSG_PLAIN, ID, CR_WHITE, 0, 0, 0.05);
};

function int SetInventory(str Item, int Count)
{
	int n = Count - CheckInventory(Item);
	
	if (n > 0)
		GiveInventory(Item, n)
	else if (n < 0)
		TakeInventory(Item, -n);
	
	return n;
};

function int SetActorInventory(int tid, str item, int count)
{
	int n = count - CheckActorInventory (tid, item);
	
	if (n > 0)
		GiveActorInventory(tid, item, n)
	else if (n < 0)
		TakeActorInventory(tid, item, -1 * n);
	
	return n;
};

// Spawn a popoff number
function Popoff(int TID, int Value, int Color)
{
	int[] Digits;
	int DigitTID = UniqueTID();
	int DigitBase = 1;
	fixed X = GetActorX(TID);
	fixed Y = GetActorY(TID);
	fixed Z = GetActorZ(TID) + CheckInventory("HeightCheck") - 4;
	
	// Prevent digit overflow
	if (Value > 9999999)
		Value = 9999999;
	
	// Put the digits into the array
	for (int i = 0; i < DNUM_DIGITS; i++)
		Digits[i] = GetDigit(Abs(Value), i);
	
	// Digit Spawning
	for (int i = 0; i < DNUM_DIGITS; i++)
	{
		str DigitActor = StrParam("Digit%dNum%d\n", i + 1, Digits[i]);
		
		if (Value >= DigitBase || Value <= -DigitBase)
			switch (Digits[1])
			{
				case 0:	Spawn(DigitActor, X, Y, Z, DigitTID, 0);	break;
				case 1:	Spawn(DigitActor, X, Y, Z, DigitTID, 0);	break;
				case 2:	Spawn(DigitActor, X, Y, Z, DigitTID, 0);	break;
				case 3:	Spawn(DigitActor, X, Y, Z, DigitTID, 0);	break;
				case 4:	Spawn(DigitActor, X, Y, Z, DigitTID, 0);	break;
				case 5:	Spawn(DigitActor, X, Y, Z, DigitTID, 0);	break;
				case 6:	Spawn(DigitActor, X, Y, Z, DigitTID, 0);	break;
				case 7:	Spawn(DigitActor, X, Y, Z, DigitTID, 0);	break;
				case 8:	Spawn(DigitActor, X, Y, Z, DigitTID, 0);	break;
				case 9:	Spawn(DigitActor, X, Y, Z, DigitTID, 0);	break;
			};
		
		DigitBase *= 10;
	};
	
	// Color
	if (Color > 0)
		Thing_SetTranslation(DigitTID, Color);
	
	// Set Fade Speed
	SetUserVariable(DigitTID, "user_fade", GetCVar("drpg_damagenumbers_fade"));
	
	// Float away
	SetActorVelocity(DigitTID, RandomFixed(-1.0, 1.0), RandomFixed(-1.0, 1.0), 0.5, 0, 0);
};

// For Damage Digits
function int GetDigit(int Num, int Digit)
{
	return (Num / Pow(10, Digit)) % 10;
};

// Formats time into MM:SS for display with Print or HudMessage
function str FormatTime(int t)
{
	int Minutes = t / 35 / 60;
	int Seconds = t / 35 % 60;
	str Time;
	
	// Calculate Minutes and Seconds
	if (Seconds < 10)
		Time = StrParam("%d:0%d\n", Minutes, Seconds)
	else
		Time = StrParam("%d:%d\n", Minutes, Seconds);
		
	return Time;
};

// Returns whether a monster is in some form of stealth or not
function bool IsStealth(int tid)
{
	return
	(
		// Fuzzy
		GetActorProperty(tid, APROP_RenderStyle) == STYLE_Fuzzy ||
		GetActorProperty(tid, APROP_RenderStyle) == STYLE_OptFuzzy ||
		// Translucent
		(GetActorProperty(tid, APROP_RenderStyle) == STYLE_Translucent &&
			GetActorPropertyFixed(tid, APROP_Alpha) < 0.5) ||
		(GetActorProperty(tid, APROP_RenderStyle) == STYLE_TranslucentStencil &&
			GetActorPropertyFixed(tid, APROP_Alpha) < 0.5) ||
		(GetActorProperty(tid, APROP_RenderStyle) == STYLE_Add &&
			GetActorPropertyFixed(tid, APROP_Alpha) < 0.5) ||
		// Totally invisible
		GetActorProperty(tid, APROP_RenderStyle) == STYLE_None ||
		// Actor flags
		// These two cases are already handled by the RenderStyle checks above
		//CheckFlag(tid, "STEALTH") ||
		//CheckFlag(tid, "SHADOW") ||
		CheckFlag(tid, "INVISIBLE")
	);
};

// Return the amount of ammo corresponding to an ammo pickup
function int GetAmmoAmount(str Item)
{
	int Amount = 1;
	
	// If it's ammo, we need to get the real amounts to give if you're using the Give buy mode
	if (Item == "Clip")			Amount = 10;
	if (Item == "ClipBox")		Amount = 50;
	if (Item == "Shell")		Amount = 4;
	if (Item == "ShellBox")		Amount = 20;
	if (Item == "RocketAmmo")	Amount = 1;
	if (Item == "RocketBox")	Amount = 5;
	if (Item == "Cell")			Amount = 20;
	if (Item == "CellPack")		Amount = 100;
	
	// If it's ammo and it's the large version, just change it down to the base type
	if (Item == "ClipBox")		Item = "Clip";
	if (Item == "ShellBox")		Item = "Shell";
	if (Item == "RocketBox")	Item = "RocketAmmo";
	if (Item == "CellPack")		Item = "Cell";
	
	// Now apply difficulty-based multipliers to the amount if it's ammo
	if (Item == "Clip" || Item == "Shell" || Item == "RocketAmmo" || Item == "Cell")
		if (GameSkill() == 1 || GameSkill() >= 5)
			Amount *= 2;
	
	return Amount;
};

// Calculates pay for the Rank Payout
function int CalculatePay()
{
	return (int)(((((fixed)Player.RankLevel + 1.0) * 10.0) + ((fixed)Player.PayKills * ((fixed)Player.RankLevel + 1.0))) * (1.0 + (fixed)Player.PayBonus / 100.0));
};

function void DrawPay(int Amount)
{
	SetFont("BIGFONT");
	SetHudSize(0, 0, false);
	HudMessage("+%d\n", Amount, HUDMSG_FADEOUT, PAY_ID, CR_GOLD, -0.12, 0.09, 4.0, 2.0);
};

function void DrawToxicity(int X, int Y)
{
	str Color;
	
	// Pixel Color
	if (Player.Toxicity >= 0 && Player.Toxicity <= 25)
		Color = "PGreen";
	if (Player.Toxicity >= 26 && Player.Toxicity <= 50)
		Color = "PYellow";
	if (Player.Toxicity >= 51 && Player.Toxicity <= 75)
		Color = "POrange";
	if (Player.Toxicity >= 76)
		Color = "PRed";
	
	// Draw Pixel
	if (Player.Toxicity >= 100)
		PrintSpriteFade(Color, ID_TOXMETER + (Timer() % 100), X + (Timer() % 100), Y, 0.05, 1.0)
	else
		PrintSpriteFade(Color, ID_TOXMETER + (Timer() % 100), X + (Timer() % 100), Y + Round(Sin((fixed)Timer() / (116.0 - Player.Toxicity)) * 8.0), 0.05, 1.0);
};

// Computes n-th power of x
function int Pow(int x, int n)
{
	int y = 1;
	while (n-- > 0) y *= x;
	return y;
};

// Return the absolute value of a negative integer
function int Abs(int x)
{
	if (x < 0)
		return -x;

	return x;
};

// Rounds a fixed to the nearest integer
function int Round(fixed fixedNumber)
{
	return (int)(fixedNumber += 0.5);
};

// Gets the distance between two TIDs
function fixed Distance(int TID1, int TID2)
{
	fixed x, y, z, d;
	
	x = GetActorX(TID1) - GetActorX(TID2);
	y = GetActorY(TID1) - GetActorY(TID2);
	z = GetActorZ(TID1) - GetActorZ(TID2);
	d = Sqrt(x * x + y * y + z * z);
	
	return d;
};
