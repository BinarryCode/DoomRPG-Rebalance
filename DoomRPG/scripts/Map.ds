#include "RPG.dh"

#include "Map.dh"
#include "Stats.dh"
#include "Outpost.dh"

// Level Info
static LevelInfo *CurrentLevel;
static LevelInfo *KnownLevels;
static int NumKnownLevels;
static int LastVisitedLevel;

// Map Init Script
script void MapInit() open
{
    // Running the game for the first time
    if (!KnownLevels)
    {
        KnownLevels = malloc(sizeof(LevelInfo));
        CurrentLevel = NULL;
        NumKnownLevels = 1;
        
        if (!KnownLevels)
        {
            Log("\cgWARNING: \caCould not allocate \cd%d\ca bytes for level info!\n", sizeof(LevelInfo));
            return;
        };
        
        // Special case for starting in the Outpost: Add MAP01 with some bogus info
        if (GetLevelInfo(LEVELINFO_LEVELNUM) == 999)
        {
            KnownLevels[0].LevelNum = 1;
            KnownLevels[0].LumpName = "MAP01";
            KnownLevels[0].NiceName = "Unknown Map";
            KnownLevels[0].NeedsRealInfo = true;
            return;
        }
        else
        {
            CurrentLevel = &KnownLevels[0];
            // So that FindCurrentLevelInfoIndex can pick it up immediately
            CurrentLevel->LevelNum = GetLevelInfo(LEVELINFO_LEVELNUM);
            CurrentLevel->NeedsRealInfo = true;
        };
    };
    
    int Index = FindLevelInfoIndex();
    
    // Outpost, or the map has no level number
    if (Index == -2 || Index == -3)
    {
        CurrentLevel = NULL;
        return;
    }
    else if (Index == -1) // New map - We need to create new info for it
    {
        Index = NumKnownLevels;
        int NewSize = sizeof(LevelInfo) * (NumKnownLevels + 1);
        
        register LevelInfo *TempArray = realloc(KnownLevels, NewSize);
        
        if (!TempArray)
        {
            Log("\cgWARNING: \caCould not allocate \cd%d\ca bytes for level info!\n", NewSize);
            CurrentLevel = NULL;
            return;
        };
        
        KnownLevels = TempArray;
        NumKnownLevels++;
        
        CurrentLevel = &KnownLevels[Index];
        CurrentLevel->NeedsRealInfo = true;
    }
    else
        CurrentLevel = &KnownLevels[Index];
    
    if (CurrentLevel->NeedsRealInfo)
    {
        CurrentLevel->LevelNum = GetLevelInfo(LEVELINFO_LEVELNUM);
        
        CurrentLevel->LumpName = StrParam("%N\n", PRINTNAME_LEVEL);
        CurrentLevel->NiceName = StrParam("%N\n", PRINTNAME_LEVELNAME);
        
        CurrentLevel->MaxMonstersKilled = 0;
        CurrentLevel->MaxItemsFound = 0;
        CurrentLevel->MaxSecretsFound = 0;
        CurrentLevel->ShortestTime = 0x7FFFFFFF;
        
        CurrentLevel->TotalMonsters = GetLevelInfo(LEVELINFO_TOTAL_MONSTERS);
        CurrentLevel->TotalItems = GetLevelInfo(LEVELINFO_TOTAL_ITEMS);
        CurrentLevel->TotalSecrets = GetLevelInfo(LEVELINFO_TOTAL_SECRETS);
        
        // These never change so we don't need to update them
        CurrentLevel->Par = GetLevelInfo(LEVELINFO_PAR_TIME);
        CurrentLevel->Sucks = GetLevelInfo(LEVELINFO_SUCK_TIME);
        
        CurrentLevel->KillBonus = false;
        CurrentLevel->ItemsBonus = false;
        CurrentLevel->SecretsBonus = false;
        CurrentLevel->AllBonus = false;
        
        CurrentLevel->NeedsRealInfo = false;
    };
    
    if (CurrentLevel)
        MapLoop();
};

script void MapLoop()
{
    int XPBonus;
    int RankBonus;
    
    int MonstersKilled;
    int ItemsFound;
    int SecretsFound;
    
    int MonstersLastKilled = 0;
    int ItemsLastFound = 0;
    int SecretsLastFound = 0;
    
    Start:
    // These need to be updated on a constant basis because they can change due
    // to scripting and mission spawns
    CurrentLevel->TotalMonsters = GetLevelInfo(LEVELINFO_TOTAL_MONSTERS);
    CurrentLevel->TotalItems = GetLevelInfo(LEVELINFO_TOTAL_ITEMS);
    CurrentLevel->TotalSecrets = GetLevelInfo(LEVELINFO_TOTAL_SECRETS);
    
    // Check to see if these are unobtainable
    if (CurrentLevel->TotalMonsters == 0)
        CurrentLevel->KillBonus = true;
    if (CurrentLevel->TotalItems == 0)
        CurrentLevel->ItemsBonus = true;
    if (CurrentLevel->TotalSecrets == 0)
        CurrentLevel->SecretsBonus = true;
    if (CurrentLevel->TotalMonsters == 0 && CurrentLevel->TotalItems == 0 && CurrentLevel->TotalSecrets == 0)
        CurrentLevel->AllBonus = true;
    
    MonstersKilled = GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
    ItemsFound = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
    SecretsFound = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
    
    // MAX KILL / ITEM / SECRET TRACKERS
    
    if (MonstersKilled > CurrentLevel->MaxMonstersKilled)
        CurrentLevel->MaxMonstersKilled = MonstersKilled;
    
    if (ItemsFound > CurrentLevel->MaxItemsFound)
    {
        // This counts only unique items
        /*
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i) ||  Players(i).Mission.Type != MT_ITEMS)
                continue;
            
            Players(i).Mission.Current += ItemsFound - CurrentLevel->MaxItemsFound;
        };
        */
        
        CurrentLevel->MaxItemsFound = ItemsFound;
    };
    
    // This counts ALL items (Current behavior)
    if (ItemsFound > ItemsLastFound)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i) || Players(i).Mission.Type != MT_ITEMS)
                continue;
            
            Players(i).Mission.Current += ItemsFound - ItemsLastFound;
        };
    };
    
    // Ditto, with secrets. These SHOULD be unique-only, because they're not
    // secrets anymore once you know about them.
    if (SecretsFound > CurrentLevel->MaxSecretsFound)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0, 1.0);
            
            RankBonus = RankTable[Players(i).RankLevel] / 100;
            Players(i).Rank += RankBonus;
            
            if (Players(i).Mission.Type != MT_SECRETS)
                continue;

            Players(i).Mission.Current += SecretsFound - CurrentLevel->MaxSecretsFound;
        };
        
        CurrentLevel->MaxSecretsFound = SecretsFound;
    };
    
    // KILL / ITEM / SECRET SPECIAL BONUSES
    
    if (MonstersKilled >= CurrentLevel->TotalMonsters && !CurrentLevel->KillBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(255, 0, 0, 0.25, 255, 0, 0, 0, 1.0);
            
            XPBonus = XPTable[Players(i).Level] / 100;
            Player.XP += XPBonus;
            
            HudMessage("100%% Monsters Killed!\n%d XP Bonus\n", XPBonus,
                       HUDMSG_FADEOUT, 0, CR_BRICK, 1.5, 0.4, 3.0, 3.0);
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->KillBonus = true;
    };

    if (ItemsFound >= CurrentLevel->TotalItems && !CurrentLevel->ItemsBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(0, 255, 255, 0.25, 0, 255, 255, 0, 1.0);
            
            Players(i).EP = Players(i).EPMax;
            HealThing(1000000);
            
            HudMessage("100%% Items Found!\nFull HP/EP Restore\n",
                       HUDMSG_FADEOUT, 0, CR_LIGHTBLUE, 1.5, 0.6, 3.0, 3.0);
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->ItemsBonus = true;
    };

    if (SecretsFound >= CurrentLevel->TotalSecrets && !CurrentLevel->SecretsBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0, 1.0);
            
            RankBonus = RankTable[Players(i).RankLevel] / 20;
            Players(i).Rank += RankBonus;

            HudMessage("100%% Secrets Found!\n%d Rank Bonus\n", RankBonus,
                       HUDMSG_FADEOUT, 0, CR_YELLOW, 1.5, 0.8, 3.0, 3.0);
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->SecretsBonus = true;
    };
    
    if (CurrentLevel->KillBonus && CurrentLevel->ItemsBonus && CurrentLevel->SecretsBonus && !CurrentLevel->AllBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(255, 255, 255, 0.25, 255, 255, 255, 0, 1.0);
            
            XPBonus = XPTable[Players(i).Level] / 100;
            RankBonus = RankTable[Players(i).RankLevel] / 20;
            
            Players(i).XP += XPBonus;
            Players(i).Rank += RankBonus;
            
            Players(i).EP = Players(i).EPMax;
            HealThing(1000000);
            
            HudMessage("\ca100%% Monsters killed!\n\cn100%% Items Found!\n\ck100%% Secrets Found!\n\n\cj%d XP Bonus\n\ck%d Rank Bonus\n\cnFull HP/EP Restore\n",
                       XPBonus, RankBonus,
                       HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.2, 5.0, 5.0);
            
            // Payout Bonus Increase
            Players(i).PayBonus++;
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->AllBonus = true;
    };

    Delay(1);
    
    MonstersLastKilled = MonstersKilled;
    ItemsLastFound = ItemsFound;
    SecretsLastFound = SecretsFound;
    
    goto Start;
};

// Level exit script
// Can't use NamedExecute in xlat, lame
acscript void MapExit(bool Secret) @ MAP_EXIT_SCRIPTNUM
{
    int ParTime = GetLevelInfo(LEVELINFO_PAR_TIME);
    bool Waiting = true;
    
    // Prevent level exit until everyone is outside the menu
    if (InMultiplayer && PlayerCount() > 1)
        while (Waiting)
        {
            Waiting = false;
            
            for (int i = 0; i < MAX_PLAYERS; i++)
                if (Players(i).InMenu || Players(i).InShop || Players(i).OutpostMenu > 0)
                    Waiting = true;
            
            Delay(35 * 3);
        };
    
    // How long it took to reach the exit
    int ExitTime = Timer() / 35;
    if (CurrentLevel->ShortestTime > ExitTime)
        CurrentLevel->ShortestTime = ExitTime;
    
    // Check par time and give bonus if you beat it
    if (ParTime > 0 && ExitTime < ParTime && (CurrentLevel && !CurrentLevel->ParBonus))
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            SetActivator(Players(i).TID);
            int RankBonus = RankTable[Players(i).RankLevel] / 20;
            
            FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0.0, 1.0);
            HudMessage("Par Time Beaten!\n%d Rank Bonus\n",
                       RankBonus,
                       HUDMSG_FADEOUT, 0, CR_GOLD, 1.5, 0.5, 3.0, 2.0);
        
            
            Players(i).Rank += RankBonus;
        };
        
        AmbientSound("misc/secret", 127);
        
        if (CurrentLevel)
            CurrentLevel->ParBonus = true;
        
        Delay(35 * 5);
    };
    
    // Now exit the level
    if (Secret)
        Exit_Secret(0)
    else
        Exit_Normal(0);
};

function int FindLevelInfoIndex(int LevelNum)
{
    if (!LevelNum)
        LevelNum = GetLevelInfo(LEVELINFO_LEVELNUM);

    if (LevelNum == 999)
        return -2; // Special value to mean the Outpost.
    if (LevelNum == 0)
        return -3; // The map has a bogus level number, so we just don't know.
    
    for (int i = 0; i < NumKnownLevels; i++)
        if (KnownLevels[i].LevelNum == LevelNum)
            return i;
    
    return -1;
};
