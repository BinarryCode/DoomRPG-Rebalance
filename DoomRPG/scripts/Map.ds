#include "RPG.dh"

#include "Map.dh"
#include "Monsters.dh"
#include "Stats.dh"
#include "Outpost.dh"
#include "Utils.dh"

// Level Info
static LevelInfo *CurrentLevel;
static DynamicArray KnownLevels;
static bool WaitingForReplacements;
static int LastVisitedLevel;
static int AllBonusMaps; // For the OCD Shield
static int CurrentSkill; // Keeps track of skill changes based on events
static int PassingEventTimer;

// Map Init Script
script void MapInit() open
{
    // Running the game for the first time
    if (KnownLevels.Data == nullptr)
    {
        CurrentSkill = GameSkill() - 1;
        ArrayCreate(&KnownLevels, "LVLS\x00", 32, sizeof(LevelInfo));
        CurrentLevel = NULL;
        PassingEventTimer = GetCVar("drpg_mapevent_eventtime") * 35 * 60;
        
        if (KnownLevels.Data == nullptr)
        {
            Log("\cgWARNING: \caCould not allocate level info!\n");
            return;
        };
        
        // Special case for starting in the Outpost: Add MAP01 with some bogus info
        if (GetLevelInfo(LEVELINFO_LEVELNUM) == 999)
        {
            LevelInfo *DummyMap = &((LevelInfo *)KnownLevels.Data)[KnownLevels.Position++];
            DummyMap->LevelNum = 1;
            DummyMap->LumpName = "MAP01";
            DummyMap->NiceName = "Unknown Map";
            DummyMap->NeedsRealInfo = true;
            return;
        }
        else
        {
            // We don't need to Resize since the array size will always be 0 here
            CurrentLevel = &(((LevelInfo *)KnownLevels.Data)[KnownLevels.Position++]);
            // So that FindLevelInfoIndex can pick it up immediately
            CurrentLevel->LevelNum = GetLevelInfo(LEVELINFO_LEVELNUM);
            CurrentLevel->NeedsRealInfo = true;
        };
    };
    
    int Index = FindLevelInfoIndex();
    
    // The map has no level number
    if (Index == -3)
    {
        CurrentLevel = NULL;
        return;
    }
    else if (Index == -2) // UAC Outpost
    {
        CurrentLevel = NULL;
        SetupOutpostEvent();
        return;
    }
    else if (Index == -1) // New map - We need to create new info for it
    {
        CurrentLevel = &(((LevelInfo *)KnownLevels.Data)[KnownLevels.Position++]);
        CurrentLevel->NeedsRealInfo = true;
        
        if (KnownLevels.Position == KnownLevels.Size)
            ArrayResize(&KnownLevels);
    }
    else
        CurrentLevel = &(((LevelInfo *)KnownLevels.Data)[Index]);
    
    if (CurrentLevel->NeedsRealInfo)
    {
        CurrentLevel->LevelNum = GetLevelInfo(LEVELINFO_LEVELNUM);
        
        CurrentLevel->LumpName = StrParam("%N\n", PRINTNAME_LEVEL);
        CurrentLevel->NiceName = StrParam("%N\n", PRINTNAME_LEVELNAME);
        
        CurrentLevel->Completed = false;
        
        CurrentLevel->MaxMonstersKilled = GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
        CurrentLevel->MaxTotalMonsters = GetLevelInfo(LEVELINFO_TOTAL_MONSTERS);
        CurrentLevel->MaxMonsterPercentage = CalcPercent(GetLevelInfo(LEVELINFO_KILLED_MONSTERS), GetLevelInfo(LEVELINFO_TOTAL_MONSTERS));
        CurrentLevel->MaxItemsFound = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
        CurrentLevel->MaxTotalItems = GetLevelInfo(LEVELINFO_TOTAL_ITEMS);
        CurrentLevel->MaxItemPercentage = CalcPercent(GetLevelInfo(LEVELINFO_FOUND_ITEMS), GetLevelInfo(LEVELINFO_TOTAL_ITEMS));
        CurrentLevel->MaxSecretsFound = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
        CurrentLevel->MaxTotalSecrets = GetLevelInfo(LEVELINFO_TOTAL_SECRETS);
        CurrentLevel->MaxSecretPercentage = CalcPercent(GetLevelInfo(LEVELINFO_FOUND_SECRETS), GetLevelInfo(LEVELINFO_TOTAL_SECRETS));
        
        // For rank giving and mission counting
        CurrentLevel->UniqueSecrets = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
        
        CurrentLevel->ShortestTime = 0x7FFFFFFF;
        
        // These never change so we don't need to update them
        CurrentLevel->Par = GetLevelInfo(LEVELINFO_PAR_TIME);
        CurrentLevel->Sucks = GetLevelInfo(LEVELINFO_SUCK_TIME);
        
        CurrentLevel->KillBonus = false;
        CurrentLevel->ItemsBonus = false;
        CurrentLevel->SecretsBonus = false;
        CurrentLevel->AllBonus = false;
        CurrentLevel->ParBonus = false;
        
        // Check to see if these are unobtainable
        if (CurrentLevel->MaxTotalMonsters == 0)
            CurrentLevel->KillBonus = true;
        if (CurrentLevel->MaxTotalItems == 0)
            CurrentLevel->ItemsBonus = true;
        if (CurrentLevel->MaxTotalSecrets == 0)
            CurrentLevel->SecretsBonus = true;
        if (CurrentLevel->MaxTotalMonsters == 0 && CurrentLevel->MaxTotalItems == 0 && CurrentLevel->MaxTotalSecrets == 0)
            CurrentLevel->AllBonus = true;
        if (CurrentLevel->Par == 0)
            CurrentLevel->ParBonus = true;
        CalculateBonusMaps();
        
        CurrentLevel->Event = MAPEVENT_NONE;
        CurrentLevel->MonsterPositions = BLANKDYNAMICARRAY;
        
        // Allocate the Monster Positions dynamic array
        ArrayCreate(&CurrentLevel->MonsterPositions, "MPOS\x00", 64, sizeof(Position));
        
        // Decide the map's event, if any
        DecideMapEvent(CurrentLevel);
        
        CurrentLevel->NeedsRealInfo = false;
    };
    
    WaitingForReplacements = true;
    Delay(2);
    
    // Reduce monster population based on difficulty settings
    static bool WaitLock = true;
    ReduceMonsterCount(&WaitLock);
    while (WaitLock)
        Delay(1);
    
    // Populate the positions array
    for (int i = 1; i < MonsterID; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        // Array has grown too big, resize it
        if (CurrentLevel->MonsterPositions.Position == CurrentLevel->MonsterPositions.Size)
            ArrayResize(&CurrentLevel->MonsterPositions);
        
        // Store position
        ((Position *)CurrentLevel->MonsterPositions.Data)[CurrentLevel->MonsterPositions.Position++] = Monsters[i].Position;
        
        // Prevent running away on gigantic maps (see holyhell.wad MAP05)
        if ((i % 4096) == 0)
            Delay(1);
    };
    
    // Set up the currently in-effect map event
    SetupMapEvent();
    
    WaitingForReplacements = false;
    
    if (CurrentLevel)
        MapLoop();
};

script void ReduceMonsterCount(bool *WaitLock)
{
    int TotalMonsters = GetLevelInfo(LEVELINFO_TOTAL_MONSTERS);
    
    if (TotalMonsters == 0)
    {
        *WaitLock = false;
        return;
    };
    
    if (TotalMonsters * GetCVar("drpg_monster_population") / 100 == TotalMonsters)
    {
        *WaitLock = false;
        return;
    };
    
    int MonstersToRemove = TotalMonsters - (TotalMonsters * GetCVar("drpg_monster_population") / 100);
    if (TotalMonsters <= MonstersToRemove)
        MonstersToRemove = TotalMonsters - 1;
    
    if (GetCVar("drpg_debug"))
        Log("\cdDEBUG: \ccReducing monster count to \cd%d\cc from \cd%d\n", TotalMonsters - MonstersToRemove, TotalMonsters);
    
    int Iterations = 0;
    while (MonstersToRemove)
    {
        for (int i = Random(1, MonsterID - 1); i < MonsterID; i++)
        {
            if (!Monsters[i].Init || ClassifyActor(Monsters[i].TID) == ACTOR_NONE || !(CheckFlag(Monsters[i].TID, "COUNTKILL")))
                continue;
            
            Thing_Remove(Monsters[i].TID);
            Monsters[i].Init = false;
            Monsters[i].TID = 0;
            
            MonstersToRemove--;
            
            break;
        };
        
        Iterations++;
        
        if ((Iterations % 4096) == 0)
            Delay(1);
    };
    
    *WaitLock = false;
};

function bool CheckMapEvent(int Event)
{
    switch (Event)
    {
        case MAPEVENT_MEGABOSS:
            if (AveragePlayerLevel() < 50)
                return false;
            return true;
        
        case MAPEVENT_ALLAURAS:
            if (AveragePlayerLevel() < 20)
                return false;
            return true;
        
        case MAPEVENT_HARMONIZEDAURAS:
            if (AveragePlayerLevel() < 10)
                return false;
            return true;
        
        case MAPEVENT_BONUS_RAINBOWS:
            if (Random(0, 3))
                return false;
            return true;
        
        case MAPEVENT_HELLUNLEASHED:
            if (AveragePlayerLevel() < 20)
                return false;
            return true;
        
        case MAPEVENT_SKILL_HELL:
            if (CurrentSkill >= 4)
                return false;
            return true;
        case MAPEVENT_SKILL_ARMAGEDDON:
            if (CurrentSkill >= 5)
                return false;
            if (CompatMode != COMPAT_DRLA || AveragePlayerLevel() < 10)
                return false;
            return true;
        
        case MAPEVENT_TOXICHAZARD:
        case MAPEVENT_NUCLEARBOMB:
        case MAPEVENT_LOWPOWER:
        case MAPEVENT_ONEMONSTER:
        default:
            return true;
    };
    
    return false;
};

script void DecideMapEvent(LevelInfo *TargetLevel)
{
    static str[MAPEVENT_MAX] EventNames =
    {
        "None";
        
        "MegaBoss";
        "Environmental Hazard";
        "Thermonuclear Bomb";
        "Low Power";
        "All Auras";
        "One-Monster";
        "Hell Unleashed";
        "Harmonized Destruction";
        
        "RAINBOWS!";
        
        "Skills - Hell";
        "Skills - Armageddon";
    };
    
    // We need to clear all of the event data before choosing one
    
    // Megaboss
    TargetLevel->MegabossActor = nullptr;
    
    // Environmental Hazard
    TargetLevel->HazardLevel = 0;
    TargetLevel->RadLeft = 0;
    TargetLevel->GeneratorFuel = 0;
    
    // Thermonuclear Bomb
    TargetLevel->BombTime = 0;
    TargetLevel->BombExplode = false;
    TargetLevel->BombAnnouncing = false;
    for (int i = 0; i < MAX_NUKE_KEYS; i++)
    {
        TargetLevel->BombKeyActive[i] = false;
        TargetLevel->BombKeyDisarming[i] = false;
        TargetLevel->BombKeyTimer[i] = 0;
    };
    
    // Low Power
    TargetLevel->PowerGeneratorActive = false;
    
    // One-Monster
    TargetLevel->SelectedMonster = nullptr;
    
    // Hell Unleashed
    TargetLevel->HellUnleashedActive = false;
    TargetLevel->PandoraBoxTID = 0;
    TargetLevel->LevelAdd = 0;
    TargetLevel->RareAdd = 0;
    
    // Harmonized Destruction
    TargetLevel->AuraType = 0;
    
    // Don't bother creating an event if the level has no monsters
    if (GetLevelInfo(LEVELINFO_TOTAL_MONSTERS) == 0)
    {
        TargetLevel->Event = MAPEVENT_NONE;
        return;
    };
    
    if (RandomFixed(0.0, 99.9) > GetCVarFixed("drpg_mapevent_chance"))
    {
        TargetLevel->Event = MAPEVENT_NONE;
        return; // No special event
    };
    
    int Rerolls = 256; // Just in case *no* events are possible for some reason
    while (TargetLevel->Event == MAPEVENT_NONE && Rerolls)
    {
        TargetLevel->Event = Random(MAPEVENT_NONE + 1, MAPEVENT_MAX - 1);
        
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: Trying \cj%s\n", EventNames[TargetLevel->Event]);
        
        if (!CheckMapEvent(TargetLevel->Event))
        {
            if (GetCVar("drpg_debug"))
                Log("\cdDEBUG: \cj%s\cg not possible\n", EventNames[TargetLevel->Event]);
            TargetLevel->Event = MAPEVENT_NONE;
        };
        
        Rerolls--;
    };
    
    if (TargetLevel->Event == MAPEVENT_NONE)
        return;
    
    if (GetCVar("drpg_debug") && TargetLevel->Event != MAPEVENT_NONE)
        Log("\cdDEBUG: Special Event on \cc%s\cd: \cg%s\n", TargetLevel->NiceName, EventNames[TargetLevel->Event]);
    
    // Initialize some basic info for the chosen event
    
    if (TargetLevel->Event == MAPEVENT_MEGABOSS)
    {
        TargetLevel->MegabossActor = &MegaBosses[Random(0, MAX_MEGABOSSES - 1)];
        
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: Chosen Boss: \cg%s\n", TargetLevel->MegabossActor->Actor);
    }
    else if (TargetLevel->Event == MAPEVENT_TOXICHAZARD)
    {
        TargetLevel->HazardLevel = Random(1, 5);
        TargetLevel->RadLeft = 100;
    }
    else if (TargetLevel->Event == MAPEVENT_ONEMONSTER)
    {
        bool Extras = (CompatMode == COMPAT_EXTRAS);
        bool DRLA = (CompatMode == COMPAT_DRLA);
        
        if (DRLA)
            TargetLevel->SelectedMonster = &MonsterDataDRLA[Random(0, MAX_DEF_MONSTERS_DRLA - 1)]
        else
            TargetLevel->SelectedMonster = &MonsterData[Random(0, MAX_DEF_MONSTERS - 1)];
        
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: Chosen Monster: \cg%s\n", TargetLevel->SelectedMonster->Name);
    }
    else if (TargetLevel->Event == MAPEVENT_HARMONIZEDAURAS)
    {
        TargetLevel->AuraType = Random(0, AURA_MAX);
    };
};

script void PassingEvents() open
{
    while (true)
    {
        if (GetCVar("drpg_mapevent_eventtime") == 0)
            return;
        
        Delay(1);
        PassingEventTimer--;
        
        if (PassingEventTimer <= 0)
        {
            if (GetCVar("drpg_debug"))
                Log("\cdDEBUG: \cfRe-rolling events for all inactive levels\n");
            
            for (int i = 0; i < KnownLevels.Position; i++)
            {
                LevelInfo *ThisLevel = &(((LevelInfo *)KnownLevels.Data)[i]);
                
                if (!ThisLevel->Completed)
                {
                    if (GetCVar("drpg_debug"))
                        Log("\cdDEBUG: \cgIncomplete: %s\n", ThisLevel->LumpName);
                    continue;
                };
                
                if (CurrentLevel && ThisLevel->LevelNum == CurrentLevel->LevelNum)
                {
                    if (GetCVar("drpg_debug"))
                        Log("\cdDEBUG: \cdCurrent: %s\n", ThisLevel->LumpName);
                    continue;
                };
                
                if (GetCVar("drpg_debug"))
                    Log("\cdDEBUG: \cqInactive: %s\n", ThisLevel->LumpName);
                
                DecideMapEvent(ThisLevel);
            };
            
            PassingEventTimer = GetCVar ("drpg_mapevent_eventtime") * 35 * 60;
        };
    };
};

script void SetupMapEvent()
{
    switch (CurrentLevel->Event)
    {
        // Normal Events
        // --------------------------------------------------
        
        case MAPEVENT_MEGABOSS:
            // Megaboss: One incredibly powerful super-monster spawns, nothing else in level.
            MegaBossEvent();
            break;
        
        case MAPEVENT_TOXICHAZARD:
            // Environmental Hazard: Entire map is filled with damaging radiation. Monsters can drop extra Radiation Suits when killed.
            EnvironmentalHazard();
            break;
        
        case MAPEVENT_NUCLEARBOMB:
            // Thermonuclear Bomb: A Thermonuclear Bomb spawns next to you on map start. You have PAR * 3 to escape before it explodes.
            ThermonuclearBombEvent();
            break;
        
        case MAPEVENT_LOWPOWER:
            // Low Power: Light levels are extremely diminished. IR goggles recommended.
            LowPowerEvent();
            break;
        
        case MAPEVENT_ALLAURAS:
            // All Auras: Everything spawns with evil, evil auras.
            SetMusic("AllAuras");
            SetHudSize(640, 480, false);
            SetFont("BIGFONT");
            HudMessage("The air crackles with the darkest of magics!\n", HUDMSG_FADEOUT, 0, CR_DARKRED, 320.0, 150.0, 1.0, 19.0);
            SetHudSize(0, 0, false);
            break;
        
        case MAPEVENT_ONEMONSTER:
            // One-Monster: All monsters are of a single type.
            OneMonsterEvent();
            break;
        
        case MAPEVENT_HELLUNLEASHED:
            // Hell Unleashed: Monsters will continue to spawn in over time
            // Monster levels and rare drop rates will steadily increase while you stay in the level
            HellUnleashedEvent();
            break;
        
        case MAPEVENT_HARMONIZEDAURAS:
            // Harmonized Destruction: Everything spawns with the same aura.
            HarmonizedDestructionEvent();
            break;
        
        // Bonus Events
        // --------------------------------------------------
        
        case MAPEVENT_BONUS_RAINBOWS:
            // RAINBOWS: ALL OF THE COLORS!
            RainbowEvent();
            break;
        
        // Bonus Events
        // --------------------------------------------------
        
        case MAPEVENT_SKILL_HELL:
            if (GameSkill() != 5)
                ChangeLevel(CurrentLevel->LumpName, 0, CHANGELEVEL_NOINTERMISSION, 4);
            SetHudSize(640, 480, false);
            SetFont("BIGFONT");
            HudMessageBold("It smells of burnt flesh and rotting corpses. It is likely you could be joining them soon.\n", HUDMSG_FADEOUT, 0, CR_BRICK, 320.4, 150.0, 1.0, 19.0);
            SetHudSize(0, 0, false);
            break;
        
        case MAPEVENT_SKILL_ARMAGEDDON:
            if (GameSkill() != 6)
                ChangeLevel(CurrentLevel->LumpName, 0, CHANGELEVEL_NOINTERMISSION, 5);
            SetMusic("Skill6");
            SetHudSize(640, 480, false);
            SetFont("BIGFONT");
            HudMessage("A foul misfortune sweeps the land, turning up the darkest creatures. There is no God now.\n", HUDMSG_FADEOUT, 0, CR_GREY, 320.4, 150.0, 1.0, 19.0);
            SetHudSize(0, 0, false);
            break;
        
        // Standard Level
        // --------------------------------------------------
        
        default:
            break;
    };
};

script void MegaBossEvent()
{
    bool Spawned;
    bool Spotted;
    int TID;
    int BossType;
    int Index;
    Position *ChosenPosition;
    
    // Ambient Music
    SetMusic(StrParam("MBossA%d\n", Random(1, 2)));
    
    // Pick Boss
    CurrentLevel->MegabossActor = &MegaBosses[Random(0, MAX_MEGABOSSES - 1)];
    
    // Replace them with nothing
    for (int i = 1; i < MonsterID; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        Monsters[i].ReplaceActor = "None";
    };
    
    WaitingForReplacements = false;
    Delay(1); // Monsters disappear!
    
    // Shuffle positions
    for (int i = 0; i < CurrentLevel->MonsterPositions.Position; i++)
    {
        int X = Random(0, CurrentLevel->MonsterPositions.Position - 1);
        Position TempPosition;
        
        TempPosition = ((Position *)CurrentLevel->MonsterPositions.Data)[i];
        ((Position *)CurrentLevel->MonsterPositions.Data)[i] = ((Position *)CurrentLevel->MonsterPositions.Data)[X];
        ((Position *)CurrentLevel->MonsterPositions.Data)[X] = TempPosition;
    };
    
    // Spawning
    while (!Spawned)
    {
        TID = UniqueTID();
        ChosenPosition = &((Position *)CurrentLevel->MonsterPositions.Data)[Index];
        Spawned = Spawn(CurrentLevel->MegabossActor->Actor, ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z, TID, ChosenPosition->Angle * 256);
        
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: Iterating for Spawn Point... (Class %s, Index %d, Position %k/%k/%k\n", CurrentLevel->MegabossActor->Actor, Index, ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z);
        
        // Successful spawn
        if (Spawned)
        {
            SpawnForced("TeleportFog", ChosenPosition->X, ChosenPosition->Y, ChosenPosition->Z, 0, 0);
            GiveActorInventory(TID, "DRPGWhiteAuraGiver", 1);
            if (GetCVar("drpg_debug"))
                Log("\cdDEBUG: \cg%s MegaBoss successfully spawned\n", CurrentLevel->MegabossActor->Actor);
        };
        
        Index++;
        if (Index > MonsterID)
            Index = 0;
        
        Delay(1);
    };
    
    // EVIL WARNING LAUGHTER
    AmbientSound("mission/gottarget2", 127);
    
    // Loop
    while (true)
    {
        // Checks to perform while the player has not been spotted
        if (!Spotted)
        {
            // Cycle locations every minute until the player has been spotted
            if ((Timer() % (35 * 60)) == 0)
            {
                SetActivator(TID);
                TeleportMonster();
                SetActivator(0);
            };
            
            // Check LOS
            for (int i = 0; i < MAX_PLAYERS; i++)
                if (CheckSight(TID, Players(i).TID, 0))
                {
                    SetMusic(CurrentLevel->MegabossActor->Music);
                    Spotted = true;
                    break;
                };
        };
        
        // Defeated
        if (GetActorProperty(TID, APROP_Health) <= 0)
        {
            SetMusic("*"); // TODO: Some sort of victory fanfare thingy here?
            Delay(35 * 60); // Let the players pick up the loot
            CurrentLevel->Event = MAPEVENT_NONE;
            return;
        };
        
        Delay(1);
    };
};

script void EnvironmentalHazard()
{
    bool NeutralizerSpawned = false;
    int NeutralizerTID;
    SetMusic("EvHazard");
    
    Delay (1);
    
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        if (!PlayerInGame(i))
            continue;
        
        TakeActorInventory(Players(i).TID, "DRPGNeutralizerFuel", 5);
        
        // [KS] If the players are level 0 (ie just started the game) and the first map is an Environmental Hazard,
        // give a free suit so they have some minutes to find more.
        
        // BUG: Giving DRPGRadSuit directly doesn't do anything. Shouldn't it place suits in the inventory bar? Silly ZDoom.
        
        if (Players(i).Level < 1)
            GiveActorInventory(Players(i).TID, "DRPGRadSuitPower", 1);
        
        UseActorInventory(Players(i).TID, "DRPGRadSuit");
        
        // [KS] Haaaaaaaax
        GiveActorInventory(Players(i).TID, "AntiRadiationForMyVoodooDolls", 1);
    };
    
    // Setup
    EnvironmentalHazardSetColors();
    EnvironmentalHazardDamage();
    
    // Spawn the Neutralizer Fuel Tanks
    DynamicLootGenerator("DRPGNeutralizerFuel", 3 * GameSkill() + Random(1, 5));
    
    while (!NeutralizerSpawned)
    {
        NeutralizerTID = UniqueTID();
        NeutralizerSpawned = SpawnEventActor("DRPGRadiationNeutralizer", NeutralizerTID);
        Delay(1);
    };
    
    int CheckPar = GetLevelInfo(LEVELINFO_PAR_TIME);
    if (CheckPar == 0)
        CheckPar = 3;
    
    CheckPar *= 35;
    
    int RadTimeRequired = CheckPar / 100;
    while (CurrentLevel->Event == MAPEVENT_TOXICHAZARD)
    {
        if (CurrentLevel->GeneratorFuel)
        {
            if (!GetUserVariable(NeutralizerTID, "user_running"))
            {
                SetUserVariable(NeutralizerTID, "user_running", 1);
                Thing_Activate(NeutralizerTID);
            };
            
            CurrentLevel->GeneratorFuel--;
            
            if (Timer() % RadTimeRequired == 0)
            {
                CurrentLevel->RadLeft--;
                
                if (CurrentLevel->RadLeft == 0)
                {
                    CurrentLevel->HazardLevel--;
                    
                    if (CurrentLevel->HazardLevel == 0)
                    {
                        if (GetUserVariable(NeutralizerTID, "user_running"))
                            Thing_Deactivate(NeutralizerTID);
                        EnvironmentalHazardDisarm();
                        return;
                    };
                    
                    CurrentLevel->RadLeft = 100;
                    EnvironmentalHazardSetColors();
                    AmbientSound("radiation/lowered", 127);
                    SetFont("BIGFONT");
                    HudMessageBold("Radiation level reduced to %d\n", CurrentLevel->HazardLevel, HUDMSG_FADEOUT | HUDMSG_LOG, 0, CR_YELLOW, 0.5, 0.25, 2.0, 1.0);
                };
            };
        }
        else
        {
            if (GetUserVariable(NeutralizerTID, "user_running"))
                Thing_Deactivate(NeutralizerTID);
        };
        
        Delay(1);
    };
};

script void EnvironmentalHazardSetColors()
{
    if (CurrentLevel->Event != MAPEVENT_TOXICHAZARD)
    {
        for (int i = 0; i <= SHORT_MAX; i++)
        {
            Sector_SetColor(i, 255, 255, 255);
            Sector_SetFade(i, 0, 0, 0);
        };
        
        return;
    };
    
    int FadeR = (63  * CurrentLevel->HazardLevel) / 5;
    int FadeG = (131 * CurrentLevel->HazardLevel) / 5;
    int FadeB = (47  * CurrentLevel->HazardLevel) / 5;
    
    int ColorR = 255 - ((192 * CurrentLevel->HazardLevel) / 5);
    int ColorG = 255 - ((124 * CurrentLevel->HazardLevel) / 5);
    int ColorB = 255 - ((208 * CurrentLevel->HazardLevel) / 5);
    
    for (int i = 0; i <= SHORT_MAX; i++)
    {
        Sector_SetColor(i, ColorR, ColorG, ColorB);
        Sector_SetFade(i, FadeR, FadeG, FadeB);
    };
};

script void EnvironmentalHazardDamage()
{
    while (CurrentLevel->HazardLevel)
    {
        int Damage = 20;

        if (CurrentLevel->HazardLevel < 3)
            Damage = 5
        else if (CurrentLevel->HazardLevel < 5)
            Damage = 10;
        
        for (int i = 0; i <= SHORT_MAX; i++)
            SectorDamage(i, Damage, "Radiation", "PowerIronFeet", DAMAGE_PLAYERS | DAMAGE_IN_AIR | DAMAGE_SUBCLASSES_PROTECT);
        
        // Damage Turrets
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            // Player is not in-game
            if (!PlayerInGame(i)) continue;
            
            // Don't have a turret or it isn't out
            if (!Players(i).Turret.Upgrade[TU_BUILD] || !Players(i).Turret.Active) continue;
            
            Thing_Damage2(Players(i).Turret.TID, Damage, "Radiation");
            SetUserVariable(Players(i).Turret.TID, "user_damage_type", DT_RADIATION);
        };
        
        Delay(32);
    };
};

acscript void EnvironmentalHazardRefillGenerator()
{
    SetActivator(0, AAPTR_TARGET);
    
    if (CurrentLevel->Event != MAPEVENT_TOXICHAZARD)
        return;
    
    if (!CheckInventory("DRPGNeutralizerFuel"))
        return;
    
    TakeInventory("DRPGNeutralizerFuel", 1);
    CurrentLevel->GeneratorFuel = 35 * 30 * (6 - GameSkill());
    
    if (CurrentLevel->GeneratorFuel < 35 * 30)
        CurrentLevel->GeneratorFuel = 35 * 30;
    
    AmbientSound("radiation/refuel", 127);
    SetFont("BIGFONT");
    HudMessageBold("Generator refueled\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.25, 2.0, 1.0);
};

script void EnvironmentalHazardDisarm()
{
    if (CurrentLevel->Event != MAPEVENT_TOXICHAZARD)
        return;
    
    EnvironmentalHazardSetColors();
    CurrentLevel->Event = MAPEVENT_NONE;
    
    SetMusic("*");
    
    SetFont("BIGFONT");
    HudMessageBold("Radiation cleared\n", HUDMSG_FADEOUT | HUDMSG_LOG, 0, CR_GREEN, 0.5, 0.25, 2.0, 1.0);
    AmbientSound("radiation/cleared", 127);
};

script void ThermonuclearBombEvent()
{
    int BombTID = UniqueTID();
    int MaxKeys = GameSkill() + 3;
    bool BombSpawned = false;
    bool BombDisarmed = false;
    
    // Calculate bomb time
    CurrentLevel->BombTime = (GetLevelInfo(LEVELINFO_PAR_TIME) ? GetLevelInfo(LEVELINFO_PAR_TIME) * 3 : 300) * 35;
    
    // Reset key states
    for (int i = 0; i < MAX_NUKE_KEYS; i++)
    {
        CurrentLevel->BombKeyActive[i] = false;
        CurrentLevel->BombKeyDisarming[i] = false;
    };
    
    // Setup Keys
    if (GetCVar("drpg_debug"))
        Log("\cdDEBUG: \c-Generating %d keys for bomb\n", MaxKeys);
    while (MaxKeys > 0)
    {
        int RandomKey = Random(0, MAX_NUKE_KEYS - 1);
        
        if (!CurrentLevel->BombKeyActive[RandomKey])
        {
            CurrentLevel->BombKeyActive[RandomKey] = true;
            CurrentLevel->BombKeyTimer[RandomKey] = CurrentLevel->BombTime / MAX_NUKE_KEYS * 2;
            MaxKeys--;
        };
        
        Delay(1);
    };
    
    // Spawn the Bomb
    while (!BombSpawned)
    {
        BombSpawned = SpawnEventActor("DRPGThermonuclearBomb", BombTID);
        Delay(1);
    };
    
    SetMusic("");
    
    Delay(35);
    
    // Warning message
    SetHudSize(640, 480, false);
    SetFont("BIGFONT");
    HudMessageBold("\cgWARNING! WARNING!\n\c[White]THERMONUCLEAR BOMB ACTIVATED!\n\ciTIME UNTIL DETONATION: %s\n",
                   FormatTime(CurrentLevel->BombTime), HUDMSG_TYPEON, 0, CR_RED, 320.4, 160.0, 3.0, 0.03, 0.5);
    AmbientSound("nuke/alert", 127);
    SetHudSize(0, 0, false);
    
    Delay(35 * 4);
    
    SetMusic("Bomb");
    
    // Set bomb's active state
    SetActorState(BombTID, "SpawnActive");
    
    // Bomb Loop
    while (CurrentLevel->BombTime > 0 && !BombDisarmed && !CurrentLevel->BombExplode)
    {
        // Announcements
        ThermonuclearBombAnnounce(CurrentLevel->BombTime);
        
        // Acceleration handling
        fixed Velocity = AbsFixed(GetActorVelX(BombTID)) + AbsFixed(GetActorVelX(BombTID));
        if (Velocity > 0)
            PlaySound(BombTID, "nuke/beep", CHAN_BODY, 1.0, true, ATTN_NORM)
        else
            StopSound(BombTID, CHAN_BODY);
        if (Velocity > 7.5) // WHOOPS, you made it angry, now die
            CurrentLevel->BombExplode = true;
        
        // Decrease key timers if the key is being disarmed, also disarm the specified lock if disarming is finished
        for (int i = 0; i < MAX_NUKE_KEYS; i++)
        {
            if (CurrentLevel->BombKeyDisarming[i])
                CurrentLevel->BombKeyTimer[i]--;
            
            if (CurrentLevel->BombKeyDisarming[i] && CurrentLevel->BombKeyTimer[i] <= 0)
            {
                CurrentLevel->BombKeyActive[i] = false;
                CurrentLevel->BombKeyDisarming[i] = false;
                PlaySound(BombTID, "nuke/unlock", CHAN_ITEM, 1.0, false, ATTN_NORM);
            };
        };
        
        // Disarm the bomb if all keys are disarmed
        int DisarmCount = 0;
        for (int i = 0; i < MAX_NUKE_KEYS; i++)
            if (!CurrentLevel->BombKeyActive[i])
                DisarmCount++;
        if (DisarmCount >= MAX_NUKE_KEYS)
        {
            CurrentLevel->BombTime = 0;
            BombDisarmed = true;
        };
        
        CurrentLevel->BombTime--;
        Delay(1);
    };
    
    // Successful disarm
    if (BombDisarmed)
    {
        CurrentLevel->Event = MAPEVENT_NONE;
        
        SetActorState(BombTID, "Disarmed");
        SetUserVariable(BombTID, "user_disarmed", 1);
        ActivatorSound("nuke/disarmed", 127);
        SetMusic("*");
        
        // Level/Rank up
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (Players(i).Level < MAX_LEVELS)
                Players(i).XP = XPTable[Players(i).Level];
            if (Players(i).RankLevel < MAX_RANK)
                Players(i).Rank = RankTable[Players(i).RankLevel];
        };
    }
    else if (!BombDisarmed || CurrentLevel->BombExplode) // Epic failure, explode everyone to die
    {
        StopSound(BombTID, CHAN_BODY);
        AmbientSound("nuke/detonate", 127);
        
        SetActorState(BombTID, "Explode");
        
        // Kill Players
        // So technically, a player may not die if they are using invincibility or have high enough health and resists, but it's close enough :P
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            Thing_Damage2(Players(i).TID, 12500, "Melee");
            Thing_Damage2(Players(i).TID, 12500, "Fire");
        };
        
        // Kill Monsters
        for (int i = 0; i < MonsterID; i++)
            Thing_Destroy(Monsters[i].TID, true, 0);
        
        CurrentLevel->Event = MAPEVENT_NONE;
        
        SetMusic("");
        
        Delay(35 * 5);
        SetMusic("*");
    };
    
    // Remove all keys from the players
    while (true)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
            for (int j = 0; j < MAX_NUKE_KEYS; j++)
                SetActorInventory(Players(i).TID, StrParam("DRPGNukeKey%d\n", j + 1), 0);
        
        Delay(1);
    };
};

script void ThermonuclearBombAnnounce(int Time)
{
    int Minutes = Time / 60 / 35;
    int Seconds = Time / 35 % 60;
    bool ValidMinutes = (Minutes == 1 || Minutes == 2 || Minutes == 3 || Minutes == 4 || Minutes == 5 || Minutes == 10 || Minutes == 20);
    bool ValidSeconds = (Seconds == 0 || Seconds == 1 || Seconds == 2 || Seconds == 3 || Seconds == 4 || Seconds == 5 || Seconds == 10 || Seconds == 20 || Seconds == 30);
    
    // Return if there is currently an announcement playing
    if (CurrentLevel->BombAnnouncing) return;
    
    if (ValidMinutes || ValidSeconds)
    {
        CurrentLevel->BombAnnouncing = true;
        
        // Minutes
        if (Minutes > 0 && ValidMinutes && Seconds == 0)
        {
            AmbientSound("nuke/announce1", 127);
            Delay(35 * 1.9);
            AmbientSound("nuke/announce2", 127);
            Delay(35 * 1.4);
            AmbientSound(StrParam("nuke/minutes/%d\n", Minutes), 127);
        };
        
        // Seconds
        if (Minutes == 0 && ValidSeconds)
        {
            AmbientSound(StrParam("nuke/seconds/%d\n", Seconds), 127);
            Delay(35);
        };
    };
    
    CurrentLevel->BombAnnouncing = false;
};

acscript void ThermonuclearBombActivate()
{
    SetActivator(GetActorProperty(0, APROP_TargetTID));
    
    for (int i = 0; i < MAX_NUKE_KEYS; i++)
        if (CheckInventory(StrParam("DRPGNukeKey%d\n", i + 1)))
        {
            CurrentLevel->BombKeyActive[i] = false;
            TakeInventory(StrParam("DRPGNukeKey%d\n", i + 1), 1);
        };
    
    for (int i = 0; i < MAX_NUKE_KEYS; i++)
    {
        if (!CurrentLevel->BombKeyActive[i]) continue;
        
        if (!CurrentLevel->BombKeyDisarming[i])
        {
            CurrentLevel->BombKeyDisarming[i] = true;
            break;
        }
        else
            break;
    };
};

acscript void ThermonuclearBombExplode()
{
    CurrentLevel->BombExplode = true;
};

script void LowPowerEvent()
{
    int GeneratorTID = UniqueTID();
    bool GeneratorSpawned = false;
    
    AmbientSound("misc/poweroff", 127);
    SetMusic("LowPower");
    
    // Darken all the sectors
    for (int i = 0; i <= SHORT_MAX; i++)
    {
        Light_Stop(i);
        Light_Flicker(i, 48, 96);
        Sector_SetColor(i, 64, 96, 255, 0);
    };
    
    // Spawn the Generator
    while (!GeneratorSpawned)
    {
        GeneratorSpawned = SpawnEventActor("DRPGGenerator", GeneratorTID);
        Delay(1);
    };
    
    // Wait until the generator is powered back up
    while (!CurrentLevel->PowerGeneratorActive)
        Delay(1);
    
    // Generator is now active - Activate emergency lighting
    CurrentLevel->Event = MAPEVENT_NONE;
    AmbientSound("misc/poweron", 127);
    SetActorState(GeneratorTID, "PoweredUp");
    SetUserVariable(GeneratorTID, "user_powered", 1);
    for (int i = 0; i <= SHORT_MAX; i++)
    {
        Light_Stop(i);
        Light_Glow(i, 160, 96, 35 * 3);
        Sector_SetColor(i, 255, 128, 32, 0);
    };
    
    // Remove generator power cells from the players
    while (true)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            SetActorInventory(Players(i).TID, "DRPGGeneratorCell", 0);
            SetActorInventory(Players(i).TID, "DRPGGeneratorCellDead", 0);
        };
        
        Delay(1);
    };
};

acscript void PowerGeneratorActivate()
{
    SetActivator(GetActorProperty(0, APROP_TargetTID));
    
    if (CheckInventory("DRPGGeneratorCell"))
    {
        CurrentLevel->PowerGeneratorActive = true;
        TakeInventory("DRPGGeneratorCell", 1);
    };
};

// TODO: Calculate which monster should spawn based on their base threat level and average player levels
script void OneMonsterEvent()
{
    bool Extras = (CompatMode == COMPAT_EXTRAS);
    bool DRLA = (CompatMode == COMPAT_DRLA);
    
    for (int i = 0; i < MonsterID; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        if (Extras)
            Monsters[i].ReplaceActor = StrParam("DRPG%sExtras\n", CurrentLevel->SelectedMonster->Actor)
        else if (DRLA)
            Monsters[i].ReplaceActor = StrParam("%sRPG\n", CurrentLevel->SelectedMonster->Actor)
        else
            Monsters[i].ReplaceActor = StrParam("DRPG%s\n", CurrentLevel->SelectedMonster->Actor);
    };
    
    // Level feeling
    SetHudSize(640, 480, false);
    SetFont("BIGFONT");
    HudMessage("%s\n", CurrentLevel->SelectedMonster->Feeling, HUDMSG_FADEOUT, 0, CR_BRICK, 320.4, 150.0, 1.0, 19.0);
    SetHudSize(0, 0, false);
};

script void HellUnleashedEvent()
{
    bool BoxSpawned = false;
    
    // Generate a TID for the box
    CurrentLevel->PandoraBoxTID = UniqueTID();
    
    // Spawn Pandora's Box
    while (!BoxSpawned && !CurrentLevel->HellUnleashedActive)
    {
        BoxSpawned = SpawnEventActor("DRPGPandoraBox", CurrentLevel->PandoraBoxTID);
        Delay(35);
    };
    
    Start:
    
    while (CurrentLevel->HellUnleashedActive >= 2)
    {
        fixed ParTime = (fixed)GetLevelInfo(LEVELINFO_PAR_TIME);
        if (ParTime <= 0) // Assign a default value to prevent divide-by-zero
            ParTime = 35 * 60 * 5; // 5 Minutes
        fixed AddMult = 0.1 / ParTime;
        
        // Cap this to make sure it isn't too low
        if (AddMult < 0.001)
            AddMult = 0.001;
        
        // Spawn in next wave of enemies
        if ((Timer() % (35 * (int)ParTime)) == 0)
            HellUnleashedSpawnMonsters();
        
        // Slowly increment the values
        CurrentLevel->LevelAdd += RandomFixed(AddMult, AddMult * 1.0);
        CurrentLevel->RareAdd += RandomFixed(AddMult * 0.01, AddMult * 0.1);
        
        // Level Imposed Caps
        if (CurrentLevel->LevelAdd > (fixed)AveragePlayerLevel() * (fixed)GameSkill())
            CurrentLevel->LevelAdd = (fixed)AveragePlayerLevel() * (fixed)GameSkill();
        if (CurrentLevel->RareAdd > AveragePlayerLevel() / 10.0)
            CurrentLevel->RareAdd = AveragePlayerLevel() / 10.0;
        
        // Hard Caps
        if (CurrentLevel->LevelAdd > 1000)
            CurrentLevel->LevelAdd = 1000;
        if (CurrentLevel->RareAdd > 100)
            CurrentLevel->RareAdd = 100;
        
        Delay(1);
    };
    
    Delay(1);
    goto Start;
};

acscript void HellUnleashedStart()
{
    // Spit out a rare item for each player
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        if (!PlayerInGame(i)) continue;
        
        ItemInfoPtr Item = GetRewardItem(MAX_DIFFICULTIES - 1);
        int ItemTID = UniqueTID();
        fixed X = GetActorX(CurrentLevel->PandoraBoxTID);
        fixed Y = GetActorY(CurrentLevel->PandoraBoxTID);
        fixed Z = GetActorZ(CurrentLevel->PandoraBoxTID) + 16.0;
        
        SpawnForced(Item->Actor, X, Y, Z, ItemTID, 0);
        SetActorVelocity(ItemTID, RandomFixed(-4.0, 4.0), RandomFixed(-4.0, 4.0), RandomFixed(2.0, 8.0), true, false);
    };
    
    CurrentLevel->HellUnleashedActive = 1;
    
    Delay(35 * 8);
    
    CurrentLevel->HellUnleashedActive = 2;
    
    SetMusic("HellUnle");
};

script void HellUnleashedSpawnMonsters()
{
    if (GetCVar("drpg_debug"))
        Log("\cdDEBUG: \c-Spawning next wave of monsters...\n");
    
    Delay(1); // Maximize our instructions
    
    for (int i = 0; i < CurrentLevel->MonsterPositions.Position; i++)
    {
        int TID = UniqueTID();
        Position *CurrentPosition = &((Position *)CurrentLevel->MonsterPositions.Data)[i];; // Totally leaving this typo here because IT'S CRYING OKAY, I AM TOO
        
        // Determine a monster
        MonsterInfoPtr Monster;
        if (CompatMode == COMPAT_DRLA)
            Monster = &MonsterDataDRLA[Random(0, MAX_DEF_MONSTERS_DRLA - 1)]
        else
            Monster = &MonsterData[Random(0, MAX_DEF_MONSTERS - 1)];
        
        bool Success = Spawn(Monster->Actor, CurrentPosition->X, CurrentPosition->Y, CurrentPosition->Z, TID, CurrentPosition->Angle);
        if (Success)
            Spawn("TeleportFog", CurrentPosition->X, CurrentPosition->Y, CurrentPosition->Z, 0, CurrentPosition->Angle);
        
        // Stagger the loop here so that we can make monsters appear to spawn in semi-randomly
        Delay(Random(1, 10));
        
        // Setup Stats
        MonsterStatsPtr Stats = &Monsters[GetMonsterID(TID)];
        Stats->Level += (int)CurrentLevel->LevelAdd;
        Stats->NeedReinit = true;
    };
};

script void HarmonizedDestructionEvent()
{
    if (AveragePlayerLevel() < 20 && CurrentLevel->AuraType == AURA_MAX)
        CurrentLevel->AuraType = Random(0, AURA_MAX - 1);
    
    if (GetCVar("drpg_debug"))
        Log("\cdDEBUG: Aura type %d\n", CurrentLevel->AuraType);
    
    for (int i = 0; i < MonsterID; i++)
    {
        if (!Monsters[i].Init)
            continue;
        
        if (CurrentLevel->AuraType == AURA_MAX)
        {
            for (int j = 0; j < AURA_MAX; j++)
                Monsters[i].Aura.Type[j].Active = true;
        }
        else
            Monsters[i].Aura.Type[CurrentLevel->AuraType].Active = true;
        
        Monsters[i].Flags &= MF_NOAURAGEN; // Don't let our aura get overwritten
    };
    
    // Level feeling
    SetMusic("OneAura");
    SetHudSize(640, 480, false);
    SetFont("BIGFONT");
    if (CurrentLevel->AuraType != AURA_MAX)
        HudMessage("A strange, malicious harmony fills the air.\n", HUDMSG_FADEOUT, 0, CR_DARKRED, 320.0, 150.0, 1.0, 19.0)
    else
        HudMessage("A strange, malicious harmony fills the air.\nAnd frankly, it's terrifying.\n", HUDMSG_FADEOUT, 0, CR_DARKRED, 320.0, 150.0, 1.0, 19.0);
    SetHudSize(0, 0, false);
};

script void RainbowEvent()
{
    SetMusic("RAINBOWS");
    
    fixed Angle = 0;
    int Red, Green, Blue;
    
    for (int i = 0; i <= SHORT_MAX; i++)
        Light_ChangeToValue(i, 176);
    
    Delay(1);
    
    Start:
    Angle -= 1.0 / 350;
    if (Angle < 0.0) Angle = 1.0 + Angle;
    Red = 128 + (Sin(Angle) * 128.0);
    Green = 128 + (Sin(Angle + 0.33) * 128.0);
    Blue = 128 + (Sin(Angle + 0.67) * 128.0);
    
    for (int i = 0; i <= SHORT_MAX; Sector_SetColor(i++, Red, Green, Blue, 128));
    
    Delay(1);
    goto Start;
};

script void SetupOutpostEvent()
{
    // TODO: Outpost Invasions, Power Fluctuations, etc
    return;
};

script void MapLoop()
{
    int XPBonus;
    int RankBonus;
    
    int ItemsFound;
    int SecretsFound;
    
    int ItemsLastFound = 0;
    
    Delay(5); // Allow Map Events to change the monster/item counts
    
    Start:
    
    // Mission Trackers
    ItemsFound = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
    SecretsFound = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
    
    if (ItemsFound > ItemsLastFound)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i) || Players(i).Mission.Type != MT_ITEMS)
                continue;
            
            Players(i).Mission.Current += ItemsFound - ItemsLastFound;
        };
    };
    
    // These should be unique-only, because they're not secrets anymore once
    // you know about them.
    if (SecretsFound > CurrentLevel->UniqueSecrets)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0, 1.0);
            
            RankBonus = RankTable[Players(i).RankLevel] / 100;
            Players(i).Rank += RankBonus;
            
            if (Players(i).Mission.Type != MT_SECRETS)
                continue;

            Players(i).Mission.Current += SecretsFound - CurrentLevel->UniqueSecrets;
        };
        
        CurrentLevel->UniqueSecrets = SecretsFound;
    };
    
    // Kills/Item/Secrets special bonuses
    if (CalcPercent(GetLevelInfo(LEVELINFO_KILLED_MONSTERS), GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)) > CurrentLevel->MaxMonsterPercentage && CurrentLevel->Event != MAPEVENT_MEGABOSS)
    {
        CurrentLevel->MaxMonstersKilled = GetLevelInfo(LEVELINFO_KILLED_MONSTERS);
        CurrentLevel->MaxTotalMonsters = GetLevelInfo(LEVELINFO_TOTAL_MONSTERS);
        CurrentLevel->MaxMonsterPercentage = CalcPercent(GetLevelInfo(LEVELINFO_KILLED_MONSTERS), GetLevelInfo(LEVELINFO_TOTAL_MONSTERS));
    };
    if (CalcPercent(GetLevelInfo(LEVELINFO_FOUND_ITEMS), GetLevelInfo(LEVELINFO_TOTAL_ITEMS)) > CurrentLevel->MaxItemPercentage)
    {
        CurrentLevel->MaxItemsFound = GetLevelInfo(LEVELINFO_FOUND_ITEMS);
        CurrentLevel->MaxTotalItems = GetLevelInfo(LEVELINFO_TOTAL_ITEMS);
        CurrentLevel->MaxItemPercentage = CalcPercent(GetLevelInfo(LEVELINFO_FOUND_ITEMS), GetLevelInfo(LEVELINFO_TOTAL_ITEMS));
    };
    if (CalcPercent(GetLevelInfo(LEVELINFO_FOUND_SECRETS), GetLevelInfo(LEVELINFO_TOTAL_SECRETS)) > CurrentLevel->MaxSecretPercentage)
    {
        CurrentLevel->MaxSecretsFound = GetLevelInfo(LEVELINFO_FOUND_SECRETS);
        CurrentLevel->MaxTotalSecrets = GetLevelInfo(LEVELINFO_TOTAL_SECRETS);
        CurrentLevel->MaxSecretPercentage = CalcPercent(GetLevelInfo(LEVELINFO_FOUND_SECRETS), GetLevelInfo(LEVELINFO_TOTAL_SECRETS));
    };
    
    if (CurrentLevel->MaxMonsterPercentage >= 100 && !CurrentLevel->KillBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(255, 0, 0, 0.25, 255, 0, 0, 0, 1.0);
            
            XPBonus = XPTable[Players(i).Level] / 100;
            Player.XP += XPBonus;
            
            HudMessage("Monsters Killed Bonus!\n%d XP Bonus\n", XPBonus,
                       HUDMSG_FADEOUT, 0, CR_BRICK, 1.5, 0.4, 3.0, 3.0);
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->KillBonus = true;
    };

    if (CurrentLevel->MaxItemPercentage >= 100 && !CurrentLevel->ItemsBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(0, 255, 255, 0.25, 0, 255, 255, 0, 1.0);
            
            HealThing(SHIELD_HEALTH);
            Players(i).EP = Players(i).EPMax;
            
            HudMessage("Items Found Bonus!\nFull HP/EP Restore\n",
                       HUDMSG_FADEOUT, 0, CR_LIGHTBLUE, 1.5, 0.6, 3.0, 3.0);
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->ItemsBonus = true;
    };

    if (CurrentLevel->MaxSecretPercentage >= 100 && !CurrentLevel->SecretsBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0, 1.0);
            
            RankBonus = RankTable[Players(i).RankLevel] / 20;
            Players(i).Rank += RankBonus;

            HudMessage("Secrets Found Bonus!\n%d Rank Bonus\n", RankBonus,
                       HUDMSG_FADEOUT, 0, CR_YELLOW, 1.5, 0.8, 3.0, 3.0);
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->SecretsBonus = true;
    };
    
    if (CurrentLevel->KillBonus && CurrentLevel->ItemsBonus && CurrentLevel->SecretsBonus && !CurrentLevel->AllBonus)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i))
                continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(255, 255, 255, 0.25, 255, 255, 255, 0, 1.0);
            
            XPBonus = XPTable[Players(i).Level] / 100;
            RankBonus = RankTable[Players(i).RankLevel] / 20;
            
            Players(i).XP += XPBonus;
            Players(i).Rank += RankBonus;
            
            HealThing(SHIELD_HEALTH);
            Players(i).EP = Players(i).EPMax;
            
            HudMessage("\caMonsters Killed Bonus!\n\cnItems Found Bonus!\n\ckSecrets Found Bonus!\n\n\cj%d XP Bonus\n\ck%d Rank Bonus\n\cnFull HP/EP Restore\n",
                       XPBonus, RankBonus,
                       HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.2, 5.0, 5.0);
            
            // Payout Bonus Increase
            Players(i).PayBonus++;
        };
        
        SetActivator(0, AAPTR_NULL);
        
        CurrentLevel->AllBonus = true;
        CalculateBonusMaps();
    };
    
    if (CalcPercent(GetLevelInfo(LEVELINFO_KILLED_MONSTERS), GetLevelInfo(LEVELINFO_TOTAL_MONSTERS)) >= 100 && (CurrentLevel->Event == MAPEVENT_ALLAURAS || CurrentLevel->Event == MAPEVENT_HARMONIZEDAURAS || CurrentLevel->Event == MAPEVENT_ONEMONSTER))
    {
        // All Auras and One-Monster events are ended by killing everything on the map
        if (Timer() > 4)
        {
            AmbientSound("misc/secret", 127);
            HudMessageBold("Everything falls silent.\n", HUDMSG_FADEOUT, 0, CR_LIGHTBLUE, 0.5, 0.7, 5.0, 5.0);
        };
        
        CurrentLevel->Event = MAPEVENT_NONE;
        CurrentLevel->SelectedMonster = nullptr;
    };
    
    Delay(1);
    
    ItemsLastFound = ItemsFound;
    
    goto Start;
};

// Level exit script
// Can't use NamedExecute in xlat, lame
acscript void MapExit(bool Secret) @ MAP_EXIT_SCRIPTNUM
{
    int ParTime = GetLevelInfo(LEVELINFO_PAR_TIME);
    bool Waiting = true;
    
    // Megabosses prevent you from leaving until they are killed
    // Hell Unleashed prevents you from leaving until you have opened the box
    if (CurrentLevel->Event == MAPEVENT_MEGABOSS || (CurrentLevel->Event == MAPEVENT_HELLUNLEASHED && !CurrentLevel->HellUnleashedActive))
    {
        AmbientSound("mission/gottarget2", 127);
        
        SetHudSize(640, 480, false);
        SetFont("BIGFONT");
        HudMessageBold("\cgA mysterious force prevents you from leaving!\n",
                       HUDMSG_TYPEON, 0, CR_RED, 320.4, 160.0, 3.0, 0.03, 0.5);
        SetHudSize(0, 0, false);
        
        // Wait until the event is over
        while (CurrentLevel->Event == MAPEVENT_MEGABOSS || (CurrentLevel->Event == MAPEVENT_HELLUNLEASHED && !CurrentLevel->HellUnleashedActive))
            Delay(35 * 5);
    };
    
    // How long it took to reach the exit
    int ExitTime = Timer() / 35;
    if (CurrentLevel->ShortestTime > ExitTime)
        CurrentLevel->ShortestTime = ExitTime;
    
    // Prevent level exit until everyone is outside the menu
    if (InMultiplayer && PlayerCount() > 1)
        while (Waiting)
        {
            Waiting = false;
            
            for (int i = 0; i < MAX_PLAYERS; i++)
                if (Players(i).InMenu || Players(i).InShop || Players(i).OutpostMenu > 0)
                    Waiting = true;
            
            Delay(35 * 3);
        };
    
    // Check par time and give bonus if you beat it
    if (ParTime > 0 && ExitTime < ParTime && (CurrentLevel && !CurrentLevel->ParBonus))
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i)) continue;
            
            SetActivator(Players(i).TID);
            int RankBonus = RankTable[Players(i).RankLevel] / 20;
            
            SetFont("SMALLFONT");
            FadeRange(255, 255, 0, 0.25, 255, 255, 0, 0.0, 1.0);
            HudMessage("Par Time Beaten!\n%d Rank Bonus\n", RankBonus, HUDMSG_FADEOUT, 0, CR_GOLD, 1.5, 0.5, 3.0, 2.0);
            
            Players(i).Rank += RankBonus;
        };
        
        AmbientSound("misc/parbonus", 127);
        
        if (CurrentLevel)
            CurrentLevel->ParBonus = true;
        
        Delay(35 * 5);
    };
    
    // Remove the Hell Unleashed event
    if (CurrentLevel && CurrentLevel->Event == MAPEVENT_HELLUNLEASHED && CurrentLevel->HellUnleashedActive)
        CurrentLevel->Event = MAPEVENT_NONE;
    
    // Remove the RAINBOWS event
    if (CurrentLevel && CurrentLevel->Event == MAPEVENT_BONUS_RAINBOWS)
        CurrentLevel->Event = MAPEVENT_NONE;
    
    // Remove the Skill events and restore the skill level
    if (CurrentLevel && (CurrentLevel->Event == MAPEVENT_SKILL_HELL || CurrentLevel->Event == MAPEVENT_SKILL_ARMAGEDDON))
    {
        ChangeSkill(CurrentSkill);
        CurrentLevel->Event = MAPEVENT_NONE;
    };
    
    CurrentLevel->Completed = true; // We finished the map
    
    // Now exit the level
    if (Secret)
        Exit_Secret(0)
    else
        Exit_Normal(0);
};

function bool SpawnEventActor(str Actor, int TID)
{
    fixed Angle = 1.0 - GetActorAngle(Players(0).TID);
    fixed X = GetActorX(Players(0).TID) + Cos(Angle) * 128.0;
    fixed Y = GetActorY(Players(0).TID) + Sin(Angle) * 128.0;
    fixed Z = GetActorZ(Players(0).TID);
    bool Spawned = Spawn(Actor, X, Y, Z, TID, 0);
    
    if (!CheckSight(TID, Players(0).TID, 0) || !Spawned)
    {
        Thing_Remove(TID);
        return false;
    }
    else
        return true;
};

function int FindLevelInfoIndex(int LevelNum)
{
    if (LevelNum == 0)
        LevelNum = GetLevelInfo(LEVELINFO_LEVELNUM);
    
    if (LevelNum == 999)
        return -2; // Special value to mean the Outpost.
    if (LevelNum == 0)
        return -3; // The map has a bogus level number, so we just don't know.
    
    for (int i = 0; i < KnownLevels.Position; i++)
        if (((LevelInfo *)KnownLevels.Data)[i].LevelNum == LevelNum)
            return i;
    
    return -1;
};

script void CalculateBonusMaps()
{
    int Count = 0;
    
    for (int i = 0; i < KnownLevels.Position; i++)
        if (((LevelInfo *)KnownLevels.Data)[i].AllBonus)
            Count++;
    
    AllBonusMaps = Count;
};

acscript void SetMapEvent(int Level, int ID)
{
    if (Level == 0)
        Level = GetLevelInfo(LEVELINFO_LEVELNUM);
    
    int LevelIndex = FindLevelInfoIndex(Level);
    if (LevelIndex == -2)
    {
        Log("\cgOutpost Events aren't implemented yet.\n");
        return;
    }
    else if (LevelIndex == -1 || LevelIndex == -3)
    {
        Log("\cgCan't set an event for that level - Visit it first.\n");
        return;
    };
    
    LevelInfo *MapToChange = &((LevelInfo *)KnownLevels.Data)[LevelIndex];
    MapToChange->Event = ID;
    
    if (MapToChange->Event == MAPEVENT_HARMONIZEDAURAS)
        MapToChange->AuraType = Random(0, AURA_MAX);
    
    if (CurrentLevel == MapToChange)
        Log("\cjYou will need to warp back to this level to see changes take effect.\n");
};
