#include "RPG.dh"

#include "Crate.dh"
#include "ItemData.dh"
#include "Utils.dh"

static str[MAX_DIFFICULTIES] CrateRarityNames =
{
    "\cjBasic";
    "\cjCommon";
    "\cdUncommon";
    "\cdSuperior";
    "\cnRare";
    "\cnVery Rare";
    "\ciElite";
    "\ctLegendary";
    "\cfSupreme";
};

int CrateID = 0;
ItemSpace CrateInfo[CRATE_MAX] Crates;

acscript void InitCrate()
{
    if (CrateID >= CRATE_MAX)
    {
        Log("\cgERROR:\c- Maximum Crate ID exceeded!\n");
        Thing_Remove(0);
        return;
    };
    
    SetUserVariable(0, "user_id", CrateID);
    
    // Default Properties
    Crates[CrateID].TID = UniqueTID();
    Crates[CrateID].Rarity = -1;
    
    CrateID++;
};

acscript void UseCrate(int ID)
{
    // Hackity hacks so you can't open the crate yet if the rewards list is not done being generated
    if (!RewardsInit) return;
    
    SetActivator(GetActorProperty(0, APROP_TargetTID));
    
    // Initialize the Crate if it is empty
    if (!Crates[ID].Init)
    {
        int LuckMod = Player.Luck / 20;
        int Rarity = (Crates[ID].Rarity == -1 ? -1 : Crates[ID].Rarity);
        int Amount = 3;
        
        // Calculate Rarity
        if (Rarity == -1)
            for (int i = Rarity; i < MAX_DIFFICULTIES - 1; i++)
                if (Random(0, (MAX_DIFFICULTIES + (MAX_DIFFICULTIES / 3)) - LuckMod) <= 0)
                    Rarity++;
        if (Rarity < 0) // Make sure the Rarity still isn't -1, or else bad things will happen
            Rarity = 0;
        
        // Calculate Amount
        for (int i = Amount; i < CRATE_MAX_ITEMS - 1; i++)
            if (Random(0, i) <= 0)
                Amount++;
        Amount += PlayerCount() - 1;  // Add +1 per extra player in-game
        if (Amount > CRATE_MAX_ITEMS) // Make sure we don't overflow
            Amount = CRATE_MAX_ITEMS;
        
        Crates[ID].Init = true;
        Crates[ID].Rarity = Rarity;
        
        GenerateCrate(ID, Amount);
    };
    
    // Check if you're in a menu
    if (Player.InMenu || Player.InShop || Player.CrateOpen) return;
    
    // Check if the crate is empty
    if (CrateEmpty(ID)) return;
    
    Player.CrateOpen = true;
    Player.CrateID = ID;
    ActivatorSound("crate/open", 127);
    
    Delay(1);
    
    while (Player.CrateOpen)
    {
        SetHudSize(GetCVar("drpg_menu_width"), GetCVar("drpg_menu_height"), true);
        
        SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
        
        // Set the crate to it's empty sprite if it's empty
        if (CrateEmpty(Player.CrateID))
            SetActorState(Crates[ID].TID, "Empty");
        
        DrawCrate();
        CrateInput();
    
        Delay(1);
    };
    
    SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
};

function void GenerateCrate(int ID, int Amount)
{
    for (int i = 0; i < Amount; i++)
    {
        Crates[ID].Active[i] = true;
        Crates[ID].Item[i] = GetRewardItem(Crates[ID].Rarity);
    };
    
    // DRLA Set shenanigans
    if (CompatMode == COMPAT_DRLA)
    {
        struct SetInfo
        {
            str Name;
            str Token;
            
            struct SetItemInfo
            {
                str Name;
                fixed Chance;
            } [32] Items;
        };
        
        static SetInfo[MAX_DRLA_SETS] SetItems =
        {
            {
                "Death From Above"; "RLDeathFromAboveSetBonusActive";
                {
                    { "RLAntigravSteelBoots";               40; };
                    { "RLAntigravProtectiveBoots";          30; };
                    { "RLAntigravPlasteelBoots";            20; };
                    { "RLJetpackArmor";                     40; };    
                    { nullptr; };
                };
            };
            {
                "Demonic"; "RLDemonicSetBonusActive";
                {
                    { "RLDemonicCarapaceArmor";             40; };
                    { "RLDemonicBoots";                     40; };
                    { nullptr; };
                };
            };
            {
                "Tactical"; "RLTacticalSetBonusActive";
                {
                    { "RLTacticalArmor";                    40; };
                    { "RLTacticalBoots";                    40; };
                    { nullptr; };
                };
            };
            {
                "Gothic"; "RLGothicSetBonusActive";
                {
                    { "RLGothicArmor";                      40; };
                    { "RLGothicBoots";                      40; };
                    { nullptr; };
                };
            };
            {
                "Phaseshift"; "RLPhaseshiftSetBonusActive";
                {
                    { "RLPhaseshiftArmor";                  40; };
                    { "RLPhaseshiftBoots";                  40; };
                    { nullptr; };
                };
            };
            {
                "Roysten"; "RLRoystenSetBonusActive";
                {
                    { "RLRoystensCommandArmor";             25; };
                    { "RLRoystensCombatBoots";              25; };
                    { nullptr; };
                };
            };
            {
                "Architect"; "RLArchitectSetBonusActive";
                {
                    { "RLSoloOperativeSuitArmor";           25; };
                    { "RLSoloOperativeBoots";               25; };
                    { nullptr; };
                };
            };
            {
                "Torgue"; "RLTorgueSetBonusActive";
                {
                    { "RLTorgueBlastplateArmor";            25; };
                    { "RLTorgueBlastBoots";                 25; };
                    { nullptr; };
                };
            };
            {
                "Enclave"; "RLEnclaveSetBonusActive";
                {
                    { "RLNuclearPowerArmor";                25; };
                    { "RLNuclearPowerBoots";                25; };
                    { nullptr; };
                };
            };
            {
                "Sentry Sentinel"; "RLSentrySentinelSetBonusActive";
                {
                    { "RLTacticalAssemblerSuitArmor";       25; };
                    { "RLTacticalAssemblerBoots";           25; };
                    { nullptr; };
                };
            };
            {
                "Sensible Strategist"; "RLSensibleStrategistSetBonusActive";
                {
                    { "RLTacticalAssemblerSuitArmor";       25; };
                    { "RLTacticalAssemblerBoots";           25; };
                    { nullptr; };
                };
            };
            {
                "Lava"; "RLLavaSetBonusActive";
                {
                    { "RLLavaArmor";                        20; };
                    { "RLLavaBoots";                        20; };
                    { nullptr; };
                };
            };
            {
                "Inquisitor"; "RLInquisitorsSetBonusActive";
                {
                    { "RLMaleksArmor";                      20; };
                    { "RLNyarlaptotepsBoots";               20; };
                    { nullptr; };
                };
            };
            {
                "Cerberus"; "RLCerberusSetBonusActive";
                {
                    { "RLTristarBlaster";                   25; };
                    { "RLCerberusArmor";                    25; };
                    { "RLCerberusBoots";                    25; };
                    { nullptr; };
                };
            };
            {
                "Angelic"; "RLAngelicAttireSetBonusActive";
                {
                    { "RLAngelicArmor";                     10; };
                    { "RLAngelicBoots";                     10; };
                    { nullptr; };
                };
            };
            {
                "Nuclear"; "RLNuclearWeaponSetBonusActive";
                {
                    { "RLNuclearPlasmaPistol";              25; };
                    { "RLNuclearPlasmaRifle";               15; };
                    { "RLNuclearBFG9000";                   10; };
                    { "RLNuclearOnslaught";                 0.2; };
                    { "RLNuclearArmor";                     20; };
                    { "RLNuclearPowerArmor";                3; };
                    { "RLHighPowerNuclearPlasmaPistol";     0; };
                    { "RLStormNuclearPlasmaPistol";         0; };
                    { "RLSuperchargedNuclearPlasmaPistol";  0; };
                    { "RLNuclearPlasmaShotgun";             0; };
                    { "RLNuclearPlasmaRifleMkII";           0; };
                    { "RLAssaultRifleNuclearPlasmaRifle";   0; };
                    { "RLBurstCannonNuclearPlasmaRifle";    0; };
                    { "RLHighPowerNuclearPlasmaRifle";      0; };
                    { "RLHighPowerNuclearBFG9000";          0; };
                    { "RLNuclearVBFG9000";                  0; };
                    { "RLNuclearBiggestFuckingGun";         0; };
                    { nullptr; };
                };
            };
        };
        
        int SetAmount = Amount;
        
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: \c-Checking DRLA sets...\n");
        
        for (int i = 0; i < MAX_DRLA_SETS; i++)
        {
            if (GetCVar("drpg_debug"))
                Log("\cdDEBUG: \c-Set \cd%d\c-: \cd%s\n", i + 1, SetItems[i].Name);
            
            // Skip this set if you already have it
            if (CheckInventory(SetItems[i].Token)) continue;
            
            bool HaveItem = false;
            for (int j = 0; SetItems[i].Items[j].Name != nullptr; j++)
            {
                if (GetCVar("drpg_debug"))
                    Log("\cdDEBUG: \c-Set \cd%d \c-Item \cd%d\c-: \cd%s\n", i + 1, j + 1, SetItems[i].Items[j].Name);
                
                if (CheckInventory(SetItems[i].Items[j].Name) || CheckInventory(StrParam("%sToken\n", SetItems[i].Items[j].Name)))
                {
                    HaveItem = true;
                    if (GetCVar("drpg_debug"))
                        Log("\cdDEBUG: \c-Have this item, continue...\n");
                    break;
                };
            };
            
            if (HaveItem)
            {
                for (int j = 0; SetItems[i].Items[j].Name != nullptr; j++)
                {
                    ItemInfoPtr ItemPtr = FindItem(SetItems[i].Items[j].Name);
                    
                    if (GetCVar("drpg_debug"))
                        Log("\cdDEBUG: \c-Set \cd%d \c-Item \cd%d\c-: \cd%s \c-(Chance: \cf%k%%\c-)\n", i + 1, j + 1, SetItems[i].Items[j].Name, SetItems[i].Items[j].Chance);
                    
                    // Stop checking items if we've filled the crate
                    if (SetAmount >= CRATE_MAX_ITEMS)
                    {
                        if (GetCVar("drpg_debug"))
                            Log("\cdDEBUG: \c-Crate is full! Stopping set checks\n");
                        return;
                    };
                    
                    // Skip this item if you have it
                    if (CheckInventory(SetItems[i].Items[j].Name) || CheckInventory(StrParam("%sToken\n", SetItems[i].Items[j].Name))) continue;
                    
                    if (RandomFixed(0.0, 100.0) <= SetItems[i].Items[j].Chance)
                    {
                        // Couldn't find the item
                        if (ItemPtr == nullptr) continue;
                        
                        Crates[ID].Active[SetAmount] = true;
                        Crates[ID].Item[SetAmount] = ItemPtr;
                        
                        if (GetCVar("drpg_debug"))
                            Log("\cdDEBUG: \cfSet Item Spawned!\n");
                        
                        SetAmount++;
                    };
                };
            };
        };
    };
};

function void CrateTakeItem()
{
    bool Spawned = SpawnForced(Crates[Player.CrateID].Item[Player.CrateIndex]->Actor, GetActorX(0), GetActorY(0), GetActorZ(0), 0, 0);
    SetActorVelocity(Player.TID, 0.01, 0.01, 0, true, false);
    
    if (Spawned)
    {
        Crates[Player.CrateID].Active[Player.CrateIndex] = false;
        Crates[Player.CrateID].Item[Player.CrateIndex] = nullptr;
    };
};

function bool CrateEmpty(int ID)
{
    int Items = 0;
    for (int i = 0; i < CRATE_MAX_ITEMS; i++)
        if (Crates[ID].Active[i])
            Items++;
    
    return !(Items > 0);
};

function void DrawCrate()
{
    // Width/Height
    int Width = 9;
    int Height = 6;
    
    // Coordinates
    fixed BaseX;
    fixed BaseY;
    fixed BoxX;
    fixed BoxY;
    fixed X;
    fixed Y;
    fixed IconX;
    fixed IconY;
    
    // Title
    SetFont("BIGFONT");
    HudMessage("UAC Supply Crate (%s\c-)\n", CrateRarityNames[Crates[Player.CrateID].Rarity], HUDMSG_PLAIN, 0, CR_GREEN, 24.1, 24.0, 0.05);
    
    for (int i = 0; i < Height; i++)
    {
        // Reset base X
        BaseX = 0.0;
        
        for (int j = 0; j < Width; j++)
        {
            int Index = j + (i * Width);
            
            ItemInfoPtr ItemSpace *Item = &Crates[Player.CrateID].Item[Index];
            bool Active = Crates[Player.CrateID].Active[Index];
            str Icon = (* Item)->Sprite.Name;
            str Name = (* Item)->Name;
            int IconXOff = (* Item)->Sprite.XOff;
            int IconYOff = (* Item)->Sprite.YOff;
            
            // Setup X and Y
            X = 26.0 + BaseX;
            Y = 50.0 + BaseY;
            BoxX = 48.0 + BaseX;
            BoxY = 72.0 + BaseY;
            IconX = 48.0 + BaseX;
            IconY = 72.0 + BaseY;
            IconX += IconXOff;
            IconY += IconYOff;
            
            // Icon
            SetHudClipRect(X, Y, 44, 44);
            if (Active)
                if (Player.CrateIndex == Index)
                    PrintSpritePulse(Icon, 0, IconX, IconY, 0.75, 32.0, 0.25)
                else
                    PrintSprite(Icon, 0, IconX, IconY, 0.05);
            SetHudClipRect(0, 0, 0, 0);
            
            // Box
            if (Player.CrateIndex == Index)
            {
                if (Active)
                    PrintSprite("ItemBoxH", 0, BoxX, BoxY, 0.05)
                else
                    PrintSprite("ItemBoxR", 0, BoxX, BoxY, 0.05);
            };
            PrintSprite("ItemBoxB", 0, BoxX, BoxY, 0.05);
            
            // Item Name
            if (Player.CrateIndex == Index && Active)
            {
                SetFont("BIGFONT");
                HudMessage("%s\n", Name, HUDMSG_PLAIN, 0, CR_WHITE, 24.1, 344.1, 0.05);
            };
            
            // Increment X
            BaseX += 48.0;
        };
        
        // Increment Y
        BaseY += 48.0;
    };
};

function void CrateInput()
{
    int Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
    int OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
    
    if (Buttons & BT_SPEED && !(OldButtons & BT_SPEED))
    {
        ActivatorSound("crate/close", 127);
        Player.CrateOpen = false;
    };
    if (Buttons & BT_USE && !(OldButtons & BT_USE))
    {
        ActivatorSound("menu/move", 127);
        CrateTakeItem();
    };
    if (Buttons & BT_FORWARD && !(OldButtons & BT_FORWARD))
    {
        ActivatorSound("menu/move", 127);
        Player.CrateIndex -= 9;
        if (Player.CrateIndex < 0) Player.CrateIndex = 0;
    };
    if (Buttons & BT_BACK && !(OldButtons & BT_BACK))
    {
        ActivatorSound("menu/move", 127);
        Player.CrateIndex += 9;
        if (Player.CrateIndex > CRATE_MAX_ITEMS - 1) Player.CrateIndex = CRATE_MAX_ITEMS - 1;
    };
    if ((Buttons & BT_LEFT && !(OldButtons & BT_LEFT)) ||
        (Buttons & BT_MOVELEFT && !(OldButtons & BT_MOVELEFT)))
    {
        ActivatorSound("menu/move", 127);
        Player.CrateIndex--;
        if (Player.CrateIndex < 0) Player.CrateIndex = 0;
    };
    if ((Buttons & BT_RIGHT && !(OldButtons & BT_RIGHT)) ||
        (Buttons & BT_MOVERIGHT && !(OldButtons & BT_MOVERIGHT)))
    {
        ActivatorSound("menu/move", 127);
        Player.CrateIndex++;
        if (Player.CrateIndex > CRATE_MAX_ITEMS - 1) Player.CrateIndex = CRATE_MAX_ITEMS - 1;
    };
};

acscript void DumpCrate()
{
    for (int i = 0; i < CrateID; i++)
    {
        Log("\cd===== Crate %d =====\n", i);
        
        for (int j = 0; j < CRATE_MAX_ITEMS; j++)
        {
            if (!Crates[i].Active[j]) continue;
            
            Log("  %s (%s)\n", Crates[i].Item[j]->Name, Crates[i].Item[j]->Actor);
        };
    };
};
