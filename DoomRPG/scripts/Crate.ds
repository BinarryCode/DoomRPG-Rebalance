#include "RPG.dh"

#include "Crate.dh"
#include "ItemData.dh"
#include "Stats.dh"
#include "Utils.dh"

static str[MAX_DIFFICULTIES] CrateRarityNames =
{
    "\cjBasic";
    "\cjCommon";
    "\cdUncommon";
    "\cdSuperior";
    "\cnRare";
    "\cnVery Rare";
    "\ciElite";
    "\ctLegendary";
    "\cfSupreme";
};

int CrateID = 0;
ItemSpace CrateInfo[CRATE_MAX] Crates;

acscript void InitCrate()
{
    if (CrateID >= CRATE_MAX)
    {
        Log("\cgERROR:\c- Maximum Crate ID exceeded!\n");
        Thing_Remove(0);
        return;
    };
    
    SetUserVariable(0, "user_id", CrateID);
    
    // TID
    int TID = UniqueTID();
    Crates[CrateID].TID = TID;
    Thing_ChangeTID(0, TID);
    
    // Defaults
    Crates[CrateID].Rarity = -1;
    Crates[CrateID].Hacking = -1;
    
    CrateID++;
};

acscript void UseCrate(int ID)
{
    // Hackity hacks so you can't open the crate yet if the rewards list is not done being generated
    if (!RewardsInit) return;
    
    SetActivator(GetActorProperty(0, APROP_TargetTID));
    
    // Initialize the Crate if it is empty
    if (!Crates[ID].Init)
    {
        int LuckMod = Player.Luck / 20;
        int Rarity = (Crates[ID].Rarity == -1 ? -1 : Crates[ID].Rarity);
        int Amount = 3;
        
        // Calculate Rarity
        if (Rarity == -1)
            for (int i = Rarity; i < MAX_DIFFICULTIES - 1; i++)
                if (Random(0, (MAX_DIFFICULTIES + (MAX_DIFFICULTIES / 3)) - LuckMod) <= 0)
                    Rarity++;
        if (Player.Augs.Active[AUG_LUCK])
            Rarity += Player.Augs.Level[AUG_LUCK];
        if (Player.Aura.Type[AURA_YELLOW].Active)
            Rarity += Player.Aura.Type[AURA_YELLOW].Level;
        if (Rarity < 0) // Make sure the Rarity still isn't -1, or else bad things will happen
            Rarity = 0;
        if (Rarity > MAX_DIFFICULTIES - 1)
            Rarity = MAX_DIFFICULTIES - 1;
        
        // Calculate Amount
        for (int i = Amount; i < CRATE_MAX_ITEMS - 1; i++)
            if (Random(0, i) <= 0)
                Amount++;
        Amount += PlayerCount() - 1;  // Add +1 per extra player in-game
        if (Amount > CRATE_MAX_ITEMS) // Make sure we don't overflow
            Amount = CRATE_MAX_ITEMS;
        
        Crates[ID].Init = true;
        Crates[ID].Rarity = Rarity;
        
        GenerateCrate(ID, Amount, false);
    };
    
    // Check if you're in a menu
    if (Player.InMenu || Player.InShop || Player.CrateOpen) return;
    
    // Check if the crate is empty
    if (CrateEmpty(ID)) return;
    
    Player.CrateOpen = true;
    Player.CrateID = ID;
    ActivatorSound("crate/open", 127);
    
    Delay(1);
    
    while (Player.CrateOpen)
    {
        SetHudSize(GetCVar("drpg_menu_width"), GetCVar("drpg_menu_height"), true);
        
        SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
        
        if (Crates[Player.CrateID].Hacking != PlayerNumber())
        {
            DrawCrate();
            CrateInput();
        };
        
        Delay(1);
    };
    
    SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
};

acscript void CrateHack()
{
    static int[MAX_NODES] NodeMax =
    {
        8; 8; 1; 2; 2; 1;
    };
    
    HackNode[MAX_NODES] Nodes;
    bool Hacking = true;
    int GenTotal = 0;
    int GenType = 0;
    int[NODE_MAX] GenNodes;
    int Tries = 3;
    int X = Random(25, 275);
    int Direction = (Random(1, 2) == 1 ? -1 : 1);
    
    // Don't allow multiple players to hack the same item
    if (Crates[Player.CrateID].Hacking >= 0)
    {
        PrintError(StrParam("%N\c- is already hacking an item in this crate\n", Crates[Player.CrateID].Hacking + 1));
        ActivatorSound("menu/error", 127);
        return;
    };
    
    // Initialize things
    for (int i = 0; i < MAX_NODES; i++)
        Nodes[i].Active = false;
    for (int i = 0; i < NODE_MAX; i++)
        GenNodes[i] = 0;
    
    // Generate Nodes
    while (GenType < NODE_MAX)
    {
        bool Conflict = false;
        int Start = Random(0, 300 - 12);
        int End = 4 * Random(1, 2);
        
        // Make sure we don't generate over the max amount of allowed node types
        if (GenNodes[GenType] >= NodeMax[GenType])
        {
            GenType++;
            continue;
        };
        
        // Make sure there are no node conflicts
        for (int i = 0; i < MAX_NODES; i++)
            if (Nodes[i].Active && !Conflict)
                for (int j = 0; j < End; j++)
                    if (Start + j >= Nodes[i].Start && Start + j <= Nodes[i].Start + Nodes[i].End)
                    {
                        Conflict = true;
                        break;
                    };
        
        // Get new coordinates due to a conflict
        if (Conflict)
            continue;
        
        // Setup Node
        Nodes[GenTotal].Active = true;
        Nodes[GenTotal].Type = GenType;
        Nodes[GenTotal].Start = Start;
        Nodes[GenTotal].End = End;
        
        GenTotal++;
        GenNodes[GenType]++;
        
        if ((Timer() % 5) == 0)
            Delay(1);
    };
    
    Delay(4);
    
    ActivatorSound("hacking/begin", 127);
    
    Crates[Player.CrateID].Hacking = PlayerNumber();
    
    while (Hacking)
    {
        int Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
        int OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
        
        SetHudSize(320, 240, false);
        
        // HACKIFICATIONS
        SetFont("SMALLFONT");
        HudMessage("HACKING IN PROGRESS...\n", HUDMSG_PLAIN, 0, CR_GREEN, 160.0, 100.0, 0.05);
        for (int i = 0; i < 16; i++)
        HudMessage("%c\n", (Random(1, 2) == 1 ? '0' : '1'), HUDMSG_FADEOUT, 0, CR_GREEN, 10.0 + (8.0 * Random(1, 36)), 150.0 + (8.0 * Random(1, 10)), 0.25, 0.75);
        
        // Cursor
        PrintSprite("HackCurs", 0, 10.1 + X, 120.0, 0.05);
        
        // Nodes
        for (int i = 0; i < MAX_NODES; i++)
            if (Nodes[i].Active)
                DrawBar(StrParam("HackNod%d\n", Nodes[i].Type + 1), 10 + Nodes[i].Start, 120, Nodes[i].End, true);
        
        // Back
        DrawBar(StrParam("HackBak%d\n", Tries), 10, 120, 300, true);
        
        // Move Cursor
        X += Direction;
        if ((Crates[Player.CrateID].Rarity / 3) > 0)
            X += ((Crates[Player.CrateID].Rarity / 3) * Direction);
        if (X < 0)
        {
            X = 0;
            Direction = -Direction;
        }
        else if (X > 300)
        {
            X = 300;
            Direction = -Direction;
        };
        
        // Input
        if (Buttons == BT_USE && OldButtons != BT_USE)
        {
            bool HitNothing = true;
            int XPBonus = XPTable[Player.Level] / 100;
            int RankBonus = RankTable[Player.RankLevel] / 100;
            
            // Check Nodes
            for (int i = 0; i < MAX_NODES; i++)
                if (Nodes[i].Active)
                    if (X >= Nodes[i].Start && X <= Nodes[i].Start + Nodes[i].End)
                    {
                        HitNothing = false;
                        Nodes[i].Active = false;
                        
                        switch (Nodes[i].Type)
                        {
                        case NODE_DESTROY:
                            ActivatorSound("hacking/critfail", 127);
                            Crates[Player.CrateID].Active[Player.CrateIndex] = false;
                            Hacking = false;
                            break;
                        case NODE_EXPLODE:
                            ActivatorSound("hacking/critfail", 127);
                            SetActorState(Crates[Player.CrateID].TID, "Explode");
                            Hacking = false;
                            Player.CrateOpen = false;
                            break;
                        case NODE_UNLOCK:
                            ActivatorSound("hacking/success", 127);
                            Crates[Player.CrateID].Firewall[Player.CrateIndex] = false;
                            Hacking = false;
                            break;
                        case NODE_XP:
                            ActivatorSound("hacking/select", 127);
                            SetFont("SMALLFONT");
                            HudMessage("+%ld XP\n", XPBonus, HUDMSG_FADEOUT, 0, CR_WHITE, 160.0, 140.0, 2.0, 1.0);
                            Player.XP += XPBonus;
                            break;
                        case NODE_RANK:
                            ActivatorSound("hacking/select", 127);
                            SetFont("SMALLFONT");
                            HudMessage("+%ld Rank\n", RankBonus, HUDMSG_FADEOUT, 0, CR_YELLOW, 160.0, 140.0, 2.0, 1.0);
                            Player.Rank += RankBonus;
                            break;
                        case NODE_RETRY:
                            ActivatorSound("hacking/select", 127);
                            SetFont("SMALLFONT");
                            HudMessage("Extra Try\n", HUDMSG_FADEOUT, 0, CR_CYAN, 160.0, 140.0, 2.0, 1.0);
                            if (Tries < 3)
                                Tries++;
                            break;
                        };
                        
                        break;
                    };
            
            if (HitNothing)
            {
                ActivatorSound("hacking/select", 127);
                Tries--;
                
                if (Tries <= 0)
                {
                    ActivatorSound("hacking/fail", 127);
                    Crates[Player.CrateID].Active[Player.CrateIndex] = false;
                    Hacking = false;
                };
            };
        };
        if (Buttons & BT_SPEED)
        {
            ActivatorSound("hacking/select", 127);
            Hacking = false;
        };
        
        Delay(1);
    };
    
    Crates[Player.CrateID].Hacking = -1;
};

function void GenerateCrate(int ID, int Amount, bool Add)
{
    int i;
    int Firewalls;
    
    if (Crates[ID].SupplyDrop)
    {
        int NumPlayers = 0;
        
        // Count the number of players
        for (int j = 0; j < MAX_PLAYERS; j++)
            if (PlayerInGame(j))
                NumPlayers++;
        
        // Create a backpack for every player in the game
        for (int j = 0; j < NumPlayers; j++)
        {
            Crates[ID].Active[i] = true;
            Crates[ID].Item[i] = FindItem("DRPGBigBackpack");
            i++;
        };
    };
    
    for (; i < Amount; i++)
    {
        Crates[ID].Active[i] = true;
        Crates[ID].Item[i] = GetRewardItem(Crates[ID].Rarity);
        
        // Firewall
        if (!Crates[ID].SupplyDrop && (Crates[ID].Item[i]->Rank == -1 || Crates[ID].Item[i]->Rank >= 2 || Crates[ID].Item[i]->Price >= 1000) && Random(1, 2) == 1 && Firewalls < Amount / 3)
        {
            Crates[ID].Firewall[i] = true;
            Firewalls++;
        };
    };
    
    // DRLA Set shenanigans
    if (CompatMode == COMPAT_DRLA)
    {
        struct SetInfo
        {
            str Name;
            str Token;
            
            struct SetItemInfo
            {
                str Name;
                fixed Chance;
            } [32] Items;
        };
        
        static SetInfo[MAX_DRLA_SETS] SetItems =
        {
            {
                "Death From Above"; "RLDeathFromAboveSetBonusActive";
                {
                    { "RLAntigravSteelBoots";               40; };
                    { "RLAntigravProtectiveBoots";          30; };
                    { "RLAntigravPlasteelBoots";            20; };
                    { "RLJetpackArmor";                     40; };    
                    { nullptr; };
                };
            };
            {
                "Demonic"; "RLDemonicSetBonusActive";
                {
                    { "RLDemonicCarapaceArmor";             40; };
                    { "RLDemonicBoots";                     40; };
                    { nullptr; };
                };
            };
            {
                "Tactical"; "RLTacticalSetBonusActive";
                {
                    { "RLTacticalArmor";                    40; };
                    { "RLTacticalBoots";                    40; };
                    { nullptr; };
                };
            };
            {
                "Gothic"; "RLGothicSetBonusActive";
                {
                    { "RLGothicArmor";                      40; };
                    { "RLGothicBoots";                      40; };
                    { nullptr; };
                };
            };
            {
                "Phaseshift"; "RLPhaseshiftSetBonusActive";
                {
                    { "RLPhaseshiftArmor";                  40; };
                    { "RLPhaseshiftBoots";                  40; };
                    { nullptr; };
                };
            };
            {
                "Roysten"; "RLRoystenSetBonusActive";
                {
                    { "RLRoystensCommandArmor";             25; };
                    { "RLRoystensCombatBoots";              25; };
                    { nullptr; };
                };
            };
            {
                "Architect"; "RLArchitectSetBonusActive";
                {
                    { "RLSoloOperativeSuitArmor";           25; };
                    { "RLSoloOperativeBoots";               25; };
                    { nullptr; };
                };
            };
            {
                "Torgue"; "RLTorgueSetBonusActive";
                {
                    { "RLTorgueBlastplateArmor";            25; };
                    { "RLTorgueBlastBoots";                 25; };
                    { nullptr; };
                };
            };
            {
                "Enclave"; "RLEnclaveSetBonusActive";
                {
                    { "RLNuclearPowerArmor";                25; };
                    { "RLNuclearPowerBoots";                25; };
                    { nullptr; };
                };
            };
            {
                "Sentry Sentinel"; "RLSentrySentinelSetBonusActive";
                {
                    { "RLTacticalAssemblerSuitArmor";       25; };
                    { "RLTacticalAssemblerBoots";           25; };
                    { nullptr; };
                };
            };
            {
                "Sensible Strategist"; "RLSensibleStrategistSetBonusActive";
                {
                    { "RLTacticalAssemblerSuitArmor";       25; };
                    { "RLTacticalAssemblerBoots";           25; };
                    { nullptr; };
                };
            };
            {
                "Lava"; "RLLavaSetBonusActive";
                {
                    { "RLLavaArmor";                        20; };
                    { "RLLavaBoots";                        20; };
                    { nullptr; };
                };
            };
            {
                "Inquisitor"; "RLInquisitorsSetBonusActive";
                {
                    { "RLMaleksArmor";                      20; };
                    { "RLNyarlaptotepsBoots";               20; };
                    { nullptr; };
                };
            };
            {
                "Cerberus"; "RLCerberusSetBonusActive";
                {
                    { "RLTristarBlaster";                   25; };
                    { "RLCerberusArmor";                    25; };
                    { "RLCerberusBoots";                    25; };
                    { nullptr; };
                };
            };
            {
                "Angelic"; "RLAngelicAttireSetBonusActive";
                {
                    { "RLAngelicArmor";                     10; };
                    { "RLAngelicBoots";                     10; };
                    { nullptr; };
                };
            };
            {
                "Nuclear"; "RLNuclearWeaponSetBonusActive";
                {
                    { "RLNuclearPlasmaPistol";              25; };
                    { "RLNuclearPlasmaRifle";               15; };
                    { "RLNuclearBFG9000";                   10; };
                    { "RLNuclearOnslaught";                 0.2; };
                    { "RLNuclearArmor";                     20; };
                    { "RLNuclearPowerArmor";                3; };
                    { "RLHighPowerNuclearPlasmaPistol";     0; };
                    { "RLStormNuclearPlasmaPistol";         0; };
                    { "RLSuperchargedNuclearPlasmaPistol";  0; };
                    { "RLNuclearPlasmaShotgun";             0; };
                    { "RLNuclearPlasmaRifleMkII";           0; };
                    { "RLAssaultRifleNuclearPlasmaRifle";   0; };
                    { "RLBurstCannonNuclearPlasmaRifle";    0; };
                    { "RLHighPowerNuclearPlasmaRifle";      0; };
                    { "RLHighPowerNuclearBFG9000";          0; };
                    { "RLNuclearVBFG9000";                  0; };
                    { "RLNuclearBiggestFuckingGun";         0; };
                    { nullptr; };
                };
            };
        };
        
        int SetAmount = Amount;
        
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: \c-Checking DRLA sets...\n");
        
        for (int i = 0; i < MAX_DRLA_SETS; i++)
        {
            if (GetCVar("drpg_debug"))
                Log("\cdDEBUG: \c-Set \cd%d\c-: \cd%s\n", i + 1, SetItems[i].Name);
            
            // Skip this set if you already have it
            if (CheckInventory(SetItems[i].Token)) continue;
            
            bool HaveItem = false;
            for (int j = 0; SetItems[i].Items[j].Name != nullptr; j++)
            {
                if (GetCVar("drpg_debug"))
                    Log("\cdDEBUG: \c-Set \cd%d \c-Item \cd%d\c-: \cd%s\n", i + 1, j + 1, SetItems[i].Items[j].Name);
                
                if (CheckInventory(SetItems[i].Items[j].Name) || CheckInventory(StrParam("%sToken\n", SetItems[i].Items[j].Name)))
                {
                    HaveItem = true;
                    if (GetCVar("drpg_debug"))
                        Log("\cdDEBUG: \c-Have this item, continue...\n");
                    break;
                };
            };
            
            if (HaveItem)
            {
                for (int j = 0; SetItems[i].Items[j].Name != nullptr; j++)
                {
                    ItemInfoPtr ItemPtr = FindItem(SetItems[i].Items[j].Name);
                    fixed Chance = SetItems[i].Items[j].Chance * (1.0 + (Crates[ID].Rarity * 0.125));
                    fixed Pick = RandomFixed(0.0, 100.0);
                    
                    // Skip this item if you have it
                    if (CheckInventory(SetItems[i].Items[j].Name) || CheckInventory(StrParam("%sToken\n", SetItems[i].Items[j].Name))) continue;
                    
                    // Stop checking items if we've filled the crate
                    if (SetAmount >= CRATE_MAX_ITEMS)
                    {
                        if (GetCVar("drpg_debug"))
                            Log("\cdDEBUG: \c-Crate is full! Stopping set checks\n");
                        return;
                    };
                    
                    if (GetCVar("drpg_debug"))
                        Log("\cdDEBUG: \c-Set \cd%d \c-Item \cd%d\c-: \cd%s \c-(Chance: \cf%k%% \c-/ Pick: \cf%k%%\c-)\n", i + 1, j + 1, SetItems[i].Items[j].Name, Chance, Pick);
                    
                    if (Pick <= Chance)
                    {
                        // Couldn't find the item
                        if (ItemPtr == nullptr) continue;
                        
                        Crates[ID].Active[SetAmount] = true;
                        Crates[ID].Item[SetAmount] = ItemPtr;
                        
                        if (GetCVar("drpg_debug"))
                            Log("\cdDEBUG: \cfSet Item Spawned!\n");
                        
                        SetAmount++;
                    };
                };
            };
        };
    };
};

function void CrateTakeItem()
{
    bool Spawned = SpawnForced(Crates[Player.CrateID].Item[Player.CrateIndex]->Actor, GetActorX(0), GetActorY(0), GetActorZ(0), 0, 0);
    SetActorVelocity(Player.TID, 0.01, 0.01, 0, true, false);
    
    if (Spawned)
    {
        Crates[Player.CrateID].Active[Player.CrateIndex] = false;
        Crates[Player.CrateID].Item[Player.CrateIndex] = nullptr;
    };
};

function bool CrateEmpty(int ID)
{
    for (int i = 0; i < CRATE_MAX_ITEMS; i++)
        if (Crates[ID].Active[i])
            return false;
    
    return true;
};

function void DrawCrate()
{
    // Width/Height
    int Width = 9;
    int Height = 6;
    
    // Coordinates
    fixed BaseX;
    fixed BaseY;
    fixed BoxX;
    fixed BoxY;
    fixed X;
    fixed Y;
    fixed IconX;
    fixed IconY;
    
    // Title
    SetFont("BIGFONT");
    HudMessage("UAC Supply Crate (%s\c-)\n", CrateRarityNames[Crates[Player.CrateID].Rarity], HUDMSG_PLAIN, 0, CR_GREEN, 24.1, 24.0, 0.05);
    
    for (int i = 0; i < Height; i++)
    {
        // Reset base X
        BaseX = 0.0;
        
        for (int j = 0; j < Width; j++)
        {
            int Index = j + (i * Width);
            
            ItemInfoPtr ItemSpace *Item = &Crates[Player.CrateID].Item[Index];
            bool Active = Crates[Player.CrateID].Active[Index];
            bool Firewall = Crates[Player.CrateID].Firewall[Index];
            str Icon = (* Item)->Sprite.Name;
            str Name = (* Item)->Name;
            int IconXOff = (* Item)->Sprite.XOff;
            int IconYOff = (* Item)->Sprite.YOff;
            
            // Setup X and Y
            X = 26.0 + BaseX;
            Y = 50.0 + BaseY;
            BoxX = 48.0 + BaseX;
            BoxY = 72.0 + BaseY;
            IconX = 48.0 + BaseX;
            IconY = 72.0 + BaseY;
            IconX += IconXOff;
            IconY += IconYOff;
            
            // Firewall
            if (Active && Firewall)
                PrintSpritePulse("FIREICN", 0, X - 2.0 + 0.1, Y + 0.1, 0.75, 32.0, 0.25);
            
            // Icon
            SetHudClipRect(X, Y, 44, 44);
            if (Active)
                if (Player.CrateIndex == Index)
                    PrintSpritePulse(Icon, 0, IconX, IconY, 0.75, 32.0, 0.25)
                else
                    PrintSprite(Icon, 0, IconX, IconY, 0.05);
            SetHudClipRect(0, 0, 0, 0);
            
            // Box
            if (Player.CrateIndex == Index)
            {
                if (Active)
                    PrintSprite("ItemBoxH", 0, BoxX, BoxY, 0.05)
                else
                    PrintSprite("ItemBoxR", 0, BoxX, BoxY, 0.05);
            };
            PrintSprite("ItemBoxB", 0, BoxX, BoxY, 0.05);
            
            // Item Name
            if (Player.CrateIndex == Index && Active)
            {
                SetFont("BIGFONT");
                HudMessage("%s\n", Name, HUDMSG_PLAIN, 0, CR_WHITE, 24.1, 344.1, 0.05);
            };
            
            // Increment X
            BaseX += 48.0;
        };
        
        // Increment Y
        BaseY += 48.0;
    };
};

function void CrateInput()
{
    int Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
    int OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
    
    if (Buttons & BT_SPEED && !(OldButtons & BT_SPEED))
    {
        ActivatorSound("crate/close", 127);
        Player.CrateOpen = false;
        
        // Set the crate to it's inactive state if it's empty
        if (CrateEmpty(Player.CrateID))
            SetActorState(Crates[Player.CrateID].TID, "Empty");
    };
    if (Buttons & BT_USE && !(OldButtons & BT_USE))
    {
        if (Crates[Player.CrateID].Active[Player.CrateIndex] && Crates[Player.CrateID].Firewall[Player.CrateIndex])
            CrateHack()
        else if (Crates[Player.CrateID].Active[Player.CrateIndex])
        {
            ActivatorSound("menu/move", 127);
            CrateTakeItem();
        };
    };
    if (Buttons & BT_FORWARD && !(OldButtons & BT_FORWARD))
    {
        ActivatorSound("menu/move", 127);
        Player.CrateIndex -= 9;
        if (Player.CrateIndex < 0) Player.CrateIndex = 0;
    };
    if (Buttons & BT_BACK && !(OldButtons & BT_BACK))
    {
        ActivatorSound("menu/move", 127);
        Player.CrateIndex += 9;
        if (Player.CrateIndex > CRATE_MAX_ITEMS - 1) Player.CrateIndex = CRATE_MAX_ITEMS - 1;
    };
    if ((Buttons & BT_LEFT && !(OldButtons & BT_LEFT)) ||
        (Buttons & BT_MOVELEFT && !(OldButtons & BT_MOVELEFT)))
    {
        ActivatorSound("menu/move", 127);
        Player.CrateIndex--;
        if (Player.CrateIndex < 0) Player.CrateIndex = 0;
    };
    if ((Buttons & BT_RIGHT && !(OldButtons & BT_RIGHT)) ||
        (Buttons & BT_MOVERIGHT && !(OldButtons & BT_MOVERIGHT)))
    {
        ActivatorSound("menu/move", 127);
        Player.CrateIndex++;
        if (Player.CrateIndex > CRATE_MAX_ITEMS - 1) Player.CrateIndex = CRATE_MAX_ITEMS - 1;
    };
};

acscript void DumpCrate()
{
    for (int i = 0; i < CrateID; i++)
    {
        Log("\cd===== Crate %d =====\n", i);
        
        for (int j = 0; j < CRATE_MAX_ITEMS; j++)
        {
            if (!Crates[i].Active[j]) continue;
            
            Log("  %s (%s)\n", Crates[i].Item[j]->Name, Crates[i].Item[j]->Actor);
        };
    };
};
