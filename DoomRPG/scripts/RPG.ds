#include "RPG.dh"

#include "Arena.dh"
#include "Augs.dh"
#include "GUI.dh"
#include "HealthBars.dh"
#include "HUD.dh"
#include "ItemData.dh"
#include "Menu.dh"
#include "Mission.dh"
#include "Monsters.dh"
#include "Outpost.dh"
#include "Popoffs.dh"
#include "Shield.dh"
#include "Shop.dh"
#include "Skills.dh"
#include "Stats.dh"
#include "Stims.dh"
#include "Turret.dh"
#include "Utils.dh"

// Version
const str Version = "v0.9.13 Beta - Phat Lewt Edition";

// Flags
static bool InBase;
static bool Transported;
static bool GlobalsInitialized;
static int CompatMode;
    
// Arrays
static str[MAX_PLAYERS] PlayerWeapon;

// Structs
static PlayerData[MAX_PLAYERS] _PlayerData;

// Items
bool ItemsInitialized;
int[MAX_ITEMS] ItemTIDs;

// --------------------------------------------------
// Multiplayer HUD
// 

// HUD Item Counts
GlobalArray(18) int[MAX_PLAYERS] Credits @ 0;

// Energy Points (EP)
GlobalArray(2)  int[MAX_PLAYERS] EP @ 0;

// Shield
GlobalArray(50) int[MAX_PLAYERS] Shield @ 0;
GlobalArray(51) int[MAX_PLAYERS] ShieldCapacity @ 0;
GlobalArray(52) int[MAX_PLAYERS] ShieldHealth @ 0;

script void GlobalInit() open
{
    if (!GlobalsInitialized)
    {
        // Version Info
        Log("\cnDoom RPG %s (Compiled on %s at %s) loaded!\n", Version, __DATE__, __TIME__);
        
        // Compatibility checking
        CheckCompatibility();
        
        // Get the XP Curve from the CVAR
        XPCurve = GetCVar("drpg_xp_curve");
        
        // Initialize XP, Stat and Rank Tables
        InitXPTable();
        Delay(1);
        InitStatXPTable();
        Delay(1);
        InitNegativeStatXPTable();
        Delay(1);
        InitRankTable();
        
        // Arena Wave
        ArenaMaxWave = 1;
        
        GlobalsInitialized = true;
        
        Delay(1); // Allow CVARs to update
    };
    
    // Create Translations
    CreateTranslations();
    
    // Initial build of ItemData
    BuildItemData();
        
    // Initial build of SkillData
    BuildSkillData();
    
    // Initial build of TurretUpgradeData
    BuildTurretData();
    
    // Initialize the Item handling script
    ItemHandler();
    
    // Initialize the Dynamic Loot Generator
    if (GetCVar("drpg_loot_system") && !InBase)
        DynamicLootGenerator("DRPGGenericDropper");
};

// Init Script
script void Init() enter
{
    // Wait until globals are initialized
    while (!GlobalsInitialized) Delay(1);
    
    // [KS] This needs to be done on its' own, so death exits don't rob you of your TID and break EVERYTHING EVER FFS
    if (ActivatorTID() == 0)
    {
        AssignTIDs();
        DefaultLoadout();
    };
    
    if (!Player.FirstRun)
    {
        // Funds
        GiveInventory("DRPGCredits", GetCVar("drpg_start_credits"));
        GiveInventory("DRPGModule", GetCVar("drpg_start_modules"));
        GiveInventory("DRPGTurretPart", GetCVar("drpg_start_turretparts"));
        
        // Level/Rank
        if (GetCVar("drpg_start_level") > 0)
        {
            Player.Level = GetCVar("drpg_start_level");
            Player.XP = XPTable[Player.Level - 1];
        };
        if (GetCVar("drpg_start_rank") > 0)
        {
            Player.RankLevel = GetCVar("drpg_start_rank");
            Player.Rank = RankTable[Player.RankLevel - 1];
        };
        
        // Stats
        Player.Strength = GetCVar("drpg_start_strength");
        Player.Defense = GetCVar("drpg_start_defense");
        Player.Vitality = GetCVar("drpg_start_vitality");
        Player.PrevVitality = Player.Vitality;
        Player.Energy = GetCVar("drpg_start_energy");
        Player.PrevEnergy = Player.Energy;
        Player.Regeneration = GetCVar("drpg_start_regeneration");
        Player.Agility = GetCVar("drpg_start_agility");
        Player.Capacity = GetCVar("drpg_start_capacity");
        Player.Luck = GetCVar("drpg_start_luck");
        
        // Stat XP
        Player.StrengthXP = StatTable[Player.Strength - 1];
        Player.DefenseXP = StatTable[Player.Defense - 1];
        Player.VitalityXP = StatTable[Player.Vitality - 1];
        Player.EnergyXP = StatTable[Player.Energy - 1];
        Player.RegenerationXP = StatTable[Player.Regeneration - 1];
        Player.AgilityXP = StatTable[Player.Agility - 1];
        Player.CapacityXP = StatTable[Player.Capacity - 1];
        Player.LuckXP = StatTable[Player.Luck - 1];
        
        // Default Health/EP
        Player.EP = Player.Energy * 10;
        Player.ActualHealth = Player.Vitality * 10;
        Player.PrevHealth = Player.ActualHealth;
        SetActorProperty(0, APROP_Health, Player.ActualHealth);
        
        // Set the default skill indices
        for (int i = 0; i < MAX_SKILLKEYS; i++)
        {
            Player.SkillCategory[i] = -1;
            Player.SkillIndex[i] = -1;
        };
        
        // Transport should always be known
        Player.SkillLevel[MAX_CATEGORIES - 1][SkillCategoryMax[MAX_CATEGORIES - 1] - 1].Level = 1;
        Player.SkillLevel[MAX_CATEGORIES - 1][SkillCategoryMax[MAX_CATEGORIES - 1] - 1].CurrentLevel = 1;
        
        // Set default selected skill to nothing
        Player.SkillSelected = -1;
        
        // Fill Augmentation Battery
        Player.Augs.Battery = Player.Capacity * 10;
        
        // Setup the New! shield parts arrays
        for (int i = 0; i < SHIELDPAGE_MAX; i++)
            for (int j = 0; j < MAX_PARTS; j++)
                Player.NewShieldParts[i][j] = true;
        for (int i = 0; i < MAX_ACCESSORIES; i++)
            Player.NewShieldAccessoryParts[i] = true;
        
        // Done first run
        Player.FirstRun = true;
    };
    
    // Death exit handling
    if (Player.ActualHealth <= 0)
        Player.ActualHealth = Player.HealthMax;
    
    // Apply camera textures and vars
    SetCameraToTexture(Player.TID, StrParam("P%iVIEW\n", PlayerNumber() + 1), 110);
    SetCameraToTexture(Player.TID, StrParam("P%iSVIEW\n", PlayerNumber() + 1), 90);
    Player.PlayerView = PlayerNumber();
    
    // Remove Aura if the keep Aura CVAR is off
    if (!GetCVar("drpg_skill_keepauras"))
        RemoveAura();
    
    // Transport FX
    if (Transported)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            // Player is not in-game
            if (!PlayerInGame(i)) continue;
            
            SetActorProperty(Players(i).TID, APROP_Invulnerable, false);
            SpawnForced("DRPGTransportEffect", GetActorX(Players(i).TID), GetActorY(Players(i).TID), GetActorZ(Players(i).TID), 0, 0);
            ThingSound(Players(i).TID, "misc/transport", 96);
        };
        
        SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN); // In case we were in the menu
        Transported = false;
    };
    
    // Clear the Player's summons
    for (int i = 0; i < MAX_SUMMONS; i++)
        Player.SummonTID[i] = 0;
    Player.Summons = 0;
    
    // Initialize DropTID Array
    ArrayCreate(&Player.DropTID, "DRPS\x00", 64, sizeof(int));
    
    // Mission Initialization
    InitMission();
    
    // Small delay before initializing the scripts for mod compatibility
    Delay(4);
    
    // Reassignment is necessary for some mods
    if (CompatMode == COMPAT_DRLA)
        AssignTIDs();
    
    // Execute Game Loops
    Loop();
    PlayerDamage();
    ShieldTimer();
    WeaponSpeed();
    StatRandomizer();
    DamageNumbers();
    InfoPopoffs();
    HealthBars();
    ShopItemAutoHandler();
    
    // GUI
	CheckGUI();
	CheckCursor();
    // UpdateMenu();
};

// Loop Script
script void Loop()
{
    Start:
    
    // If we're on the title map, terminate
    if (InTitle)
    {
        SetActorProperty(0, APROP_Invulnerable, true);
        TeleportOther(Player.TID, 1003, false);
        return;
    };
    
    // If the player's dead, terminate
    if (GetActorProperty(0, APROP_Health) <= 0) return;
    
    // Update Functions
    CheckCombo();
    CheckStats();
    CheckStatBonus();
    CheckHardStatCaps();
    CheckRegen();
    CheckLuck();
    CheckHealth();
    CheckAugSlots();
    CheckAugs();
    CheckLevel();
    CheckRank();
    CheckSkills();
    CheckAuras();
    CheckBurnout();
    CheckStim();
    CheckPerks();
    CheckShields();
    CheckShieldAccessory();
    CheckStatBounds();
    CheckToxicity();
    CheckStatusEffects();
    CheckCapacity();
    CheckShopCard();
    CheckMission();
    CheckHUD();
    CheckKeys();
    
    // Handle the menu cursor color
    MenuCursorColor = CursorColors[(Timer() / 3) % 6];
    
    // Calculate Shop Discount
    Player.ShopDiscount = (int)((Player.RankLevel * 2.1) + (InBase ? (Player.ShopCard * 5) : 0));
    
    // Main Menu
    if (Player.InMenu)
        MenuLoop();
    
    // Shop Menu
    if (Player.InShop)
        ShopLoop();
    
    // Menu freezing/dimming
    if (Player.InMenu || Player.InShop || Player.OutpostMenu > 0)
    {
        if (GetCVar("drpg_menufreeze") && !InMultiplayer)
            GiveInventory("DRPGMenuFreezer", 1);
        if (GetCVar("drpg_menudim") && !Player.StatusType[SE_BLIND])
            FadeRange(0, 0, 0, 0.5, 0, 0, 0, 0.0, 0.25);
    };
    
    // Menu-specific Help
    if (Player.InMenu || Player.InShop || Player.OutpostMenu > 0 || Player.CrateOpen)
        MenuHelp();
    
    // Menu icon in multiplayer
    if (InMultiplayer && (Player.InMenu || Player.InShop || Player.OutpostMenu > 0))
    {
        fixed X = GetActorX(Player.TID);
        fixed Y = GetActorY(Player.TID);
        fixed Z = GetActorZ(Player.TID);
        fixed Height = GetActorPropertyFixed(Player.TID, APROP_Height);
        
        SpawnForced("DRPGMenuIcon", X, Y, Z + Height + 8.0, 0, 0);
    };
    
    // Display Stat HUD if enabled
    if (GetUserCVar(PlayerNumber(), "drpg_stats_alwaysshow") || GetCVar("drpg_hud_preview"))
        StatHUD();
    
    // Regeneration
    DoRegen();
    
    // Set mass stupid high when Invulnerable or transporting to prevent knockback
    if (CheckInventory("PowerInvulnerable") || Transported)
        Player.Mass *= 128;
    
    // Apply Stats
    SetActorPropertyFixed(Player.TID, APROP_DamageMultiplier, (1.0 + ((fixed)Player.TotalDamage / 100.0)) * (Player.DamageMult > 1 ? Player.DamageMult : 1));
    SetActorPropertyFixed(Player.TID, APROP_DamageFactor, Player.DamageFactor);
    SetActorProperty(Player.TID, APROP_Mass, Player.Mass);
    SetActorProperty(Player.TID, APROP_SpawnHealth, Player.HealthMax);
    SetActorPropertyFixed(Player.TID, APROP_Speed, Player.Speed);
    SetActorPropertyFixed(Player.TID, APROP_JumpZ, Player.JumpHeight);
    
    // Make you invincible while in the Menus and if menu freezing is enabled
    if ((Player.InMenu || Player.InShop) && GetCVar("drpg_menufreeze"))
        SetActorProperty(Player.TID, APROP_DamageFactor, 0);
    
    // Store your current weapon in the Player Weapon array
    PlayerWeapon[PlayerNumber()] = GetWeapon();
    
    // Loop
    Delay(1);
    
    goto Start;
};

// Damage Handler Entry Point
script void PlayerDamage()
{
    int BeforeDamage;
    int DamageTaken;
    int ShieldDamageAmount;
    bool CanSurvive;
    
    Start:
    
    // If the player's dead, terminate
    if (GetActorProperty(0, APROP_Health) <= 0) return;
    
    CanSurvive = Player.SurvivalBonus > 0 && RandomFixed(0.0, 100.0) <= Player.SurvivalBonus && !Player.LastLegs;
    
    if (Player.ActualHealth <= 0) // [KS] This is to make sure the player actually dies, even if they're shielded.
    {
        SetPlayerProperty(0, 0, PROP_BUDDHA);
        SetActorProperty(0, APROP_Health, 0);
        goto Start;
    };
    
    if (!Player.Shield.Active || !Player.Shield.Charge)
    {
        SetActorProperty(0, APROP_Health, Player.ActualHealth);
        
        if (Player.ActualHealth > 2)
            Player.LastLegs = false;
        
        if (CanSurvive || CheckInventory("DRPGContinue"))
            SetPlayerProperty(0, 1, PROP_BUDDHA)
        else
            SetPlayerProperty(0, 0, PROP_BUDDHA);
    }
    else
    {
        SetPlayerProperty(0, 0, PROP_BUDDHA);
        
        SetActorProperty(0, APROP_Health, SHIELD_HEALTH);
        
        // Hilarious hack to allow healing detection
        SetActorProperty(0, APROP_SpawnHealth, Player.ActualHealth < Player.HealthMax ? SHIELD_HEALTH * 2 : SHIELD_HEALTH);
    };
    
    BeforeDamage = GetActorProperty(Player.TID, APROP_Health);
    Player.DamageType = DT_NONE;
    
    Delay(1);
    
    DamageTaken = BeforeDamage - GetActorProperty(Player.TID, APROP_Health);
    ShieldDamageAmount = 0;
    
    if (DamageTaken > 0)
    {
        Player.AutosaveTimerReset = true;
        
        AugDamage(DamageTaken);
        ToxicityDamage();
        StatusDamage(DamageTaken);
        ResetRegen();
        DamageHUD(DamageTaken);
    };
    
    if (DamageTaken > 0 && Player.Shield.Active)
        ShieldTimerReset();
    
    if (DamageTaken > 0 && Player.Shield.Active && Player.Shield.Charge)
    {
        ShieldDamageAmount = DamageTaken; // For callback
        if (ShieldDamageAmount > Player.Shield.Charge)
            ShieldDamageAmount = Player.Shield.Charge;
        
        Player.Shield.Charge -= DamageTaken;
        Player.Shield.Full = false;
        
        ShieldDamage(ShieldDamageAmount);
        
        if (Player.Shield.Charge <= 0)
        {
            if (Player.Shield.Charge < 0)
            {
                DamageTaken = -Player.Shield.Charge;
                Player.ActualHealth -= DamageTaken;
                Player.Shield.Charge = 0;
            }
            else
                DamageTaken = 0;
            
            ShieldBroken();
        }
        else
            DamageTaken = 0;
    };
    
    if (DamageTaken > 0)
    {
        Player.ActualHealth -= DamageTaken;
        
        if (Player.ActualHealth <= 1) // Near-Death stuff
        {
            // Continue check
            if (CheckInventory("DRPGContinue"))
            {
                Player.ActualHealth = Player.HealthMax;
                ActivatorSound("health/resurrect", 127);
                TakeInventory("DRPGContinue", 1);
                
                SetHudSize(320, 200, false);
                PrintSpriteFade("CONTA0", 0, 172.0, 160.0, 0.5, 1.5);
                SetFont("BIGFONT");
                HudMessage("Used a Continue!\n", HUDMSG_FADEOUT, 0, CR_GOLD, 160.0, 140.0, 0.5, 1.5);
            };
            
            // Survival Bonus
            if (CanSurvive && Player.ActualHealth <= 1)
            {
                Player.ActualHealth = 2;
                Player.LastLegs = true;
                
                if (Player.Shield.Accessory && Player.Shield.Accessory->PassiveEffect == SHIELD_PASS_SURVIVECHARGE)
                    Player.Shield.Charge = Player.Shield.Capacity;
                
                ActivatorSound("health/survive", 127);
                SetHudSize(320, 200, false);
                SetFont("BIGFONT");
                HudMessage("Agility Save!\n", HUDMSG_FADEOUT, 0, CR_ORANGE, 160.0, 140.0, 0.5, 0.5);
                PrintSpriteFade("AGISAVE", 0, 160.0, 140.0, 0.5, 0.5);
            };
        };
        
        // Always Quick Heal if CVAR is set
        if (GetCVar("drpg_auto_heal"))
            QuickHeal(false);
    }
    else if (DamageTaken < 0)
    {
        DamageTaken = -DamageTaken;
        
        // Negative "damage" == We got health from an outside source (eg. RLA assembly unit)
        // We'll just need to assume it's a regular capped heal if we got it this way.
        // Anything that needs otherwise should be redefined anyway.
        
        if (Player.ActualHealth + DamageTaken > Player.HealthMax)
            DamageTaken = Player.HealthMax - Player.ActualHealth;
        
        Player.ActualHealth += DamageTaken;
    };
    
    goto Start;
};

acscript int AddHealth(int HealthPercent, int MaxPercent)
{
    int RealMax = Player.HealthMax * MaxPercent / 100;
    int HealthAmount = Player.HealthMax * HealthPercent / 100;
    
    if (Player.ActualHealth >= RealMax)
        return 0;
    
    if (Player.ActualHealth + HealthAmount > RealMax)
        HealthAmount = RealMax - Player.ActualHealth;
    
    // Add Vitality XP for using healing items
    if (GetCVar("drpg_levelup_natural"))
    {
        fixed Scale = GetCVarFixed("drpg_vitality_scalexp");
        if (GetCVar("drpg_allow_spec"))
        {
            if (GetCVar("drpg_character_spec") == 3)
                Scale *= 2;
        };
        
        int Factor = CalcPercent(HealthAmount, Player.HealthMax);
        Player.VitalityXP += (int)(Factor * Scale * 10);
    };
    
    Player.ActualHealth += HealthAmount;
    return 1;
};

acscript int AddHealthDirect(int HealthAmount, int MaxPercent)
{
    int RealMax = Player.HealthMax * MaxPercent / 100;
    
    if (Player.ActualHealth >= RealMax)
        return 0;
    
    if (Player.ActualHealth + HealthAmount > RealMax)
        HealthAmount = RealMax - Player.ActualHealth;
    
    // Add Vitality XP for using healing items
    if (GetCVar("drpg_levelup_natural"))
    {
        fixed Scale = GetCVarFixed("drpg_vitality_scalexp");
        if (GetCVar("drpg_allow_spec"))
        {
            if (GetCVar("drpg_character_spec") == 3)
                Scale *= 2;
        };
        
        int Factor = CalcPercent(HealthAmount, Player.HealthMax);
        Player.VitalityXP += (int)(Factor * Scale * 10);
    };
    
    Player.ActualHealth += HealthAmount;
    return 1;
};

// Handles Weapon Firing Speed
script void WeaponSpeed()
{
    Start:
    
    int Time;
    
    if (Player.Agility <= 100)
        Time = Abs(Round(Player.WeaponSpeed * 0.35 - 35.0))
    else
        Time = 0;
    
    if (GetCVar("drpg_stat_weaponspeed") || Player.Stim.PowerupTimer[STIM_RAGE] > 0)
        SetInventory("DRPGSpeed", 1);
    
    Delay((Player.Stim.PowerupTimer[STIM_RAGE] > 0 ? 1 : Time + 1));
    goto Start;
};

// Stat Randomizer Script
script void StatRandomizer()
{
    Start:
    
    if (GetCVar("drpg_auto_spend") && !Player.Stim.Active)
    {
        while (CheckInventory("DRPGStatToken") > 0 && !StatsCapped())
        {
            // Select Preferred Stat
            if (Random(1, 2) == 1 && GetCVar("drpg_auto_spend_pref") >= 0)
                IncreaseStat(GetCVar("drpg_auto_spend_pref"))
            else // Select Random Stat
                IncreaseStat(Random(0, STAT_MAX - 1));
            
            // Display Stat HUD
            StatHUD();
            
            Delay(1);
        };
    };
    
    Delay(1);
    goto Start;
};

// Handles autosaving
script void AutosaveHandler()
{
    // Terminate if the autosave CVar is disabled
    if (GetCVar("drpg_autosave") == 0 || (PlayerCount() > 1 && !Arbitrator)) return;
    
    int SaveTimer = GetCVar("drpg_autosave") * (35 * 60);
    bool Safe;
    int DamageTimer;
    
    while (true)
    {
        if (Player.AutosaveTimerReset)
            DamageTimer = 0
        else
            ++DamageTimer;
        Player.AutosaveTimerReset = false;
        
        if ((Player.InMenu || Player.InShop || Player.OutpostMenu > 0) && !GetCVar("drpg_menufreeze"))
            DamageTimer = ASAVE_SAFETIME;
        
        if (!SaveTimer)
        {
            Safe = true;
            
            if (DamageTimer < ASAVE_SAFETIME ||
                GetActorProperty(Player.TID, APROP_Health) <= GetActorProperty(Player.TID, APROP_SpawnHealth) / 10)
                Safe = false;
            
            if (Safe)
            {
                Autosave();
                SaveTimer = GetCVar("drpg_autosave") * (35 * 60);
            }
            else
                SaveTimer = ASAVE_RETRYTIME;
        }
        else
            --SaveTimer;
        
        Delay(1);
    };
};

script void ShopSpecialHandler() enter
{
    Start:
    
    // Reset the item
    if (ShopSpecialTimer <= 0)
    {
        bool ValidItem = false;
        int Tries = 0;
        int MinValue = 0;
        int MaxValue = 0;
        int Category = 0;
        int Index = 0;
        
        // Calculate min and max based on settings
        switch (GetCVar("drpg_shopspecial_type"))
        {
        case SHOPSPECIAL_MINMAX:
            MinValue = GetCVar("drpg_shopspecial_min");
            MaxValue = GetCVar("drpg_shopspecial_max");
            break;
        case SHOPSPECIAL_LEVEL:
            MinValue = AveragePlayerLevel() * MAX_LEVEL;
            MaxValue = AveragePlayerLevel() * (100 * MAX_LEVEL);
            break;
        case SHOPSPECIAL_RANK:
            MinValue = AveragePlayerRank() * (25 * MAX_RANK);
            MaxValue = AveragePlayerRank() * (2500 * MAX_RANK);
            break;
        case SHOPSPECIAL_CREDITS:
            MinValue = AveragePlayerCredits() / 10;
            MaxValue = AveragePlayerCredits() * 10;
            break;
        case SHOPSPECIAL_LUCK:
            MinValue = AveragePlayerLuck() * 500;
            MaxValue = AveragePlayerLuck() * 5000;
            break;
        };
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: Shop Special \c-Min/Max Calculated: \ca%d \c-/ \cd%d\n", MinValue, MaxValue);
        
        // Blank out the item until a new one is found
        ShopSpecialItem = GetBlankItem();
        
        while (!ValidItem)
        {
            ValidItem = true;
            
            Delay(1);
            
            // Pick an item
            Category = (GetCVar("drpg_shopspecial_category") >= 0 ? GetCVar("drpg_shopspecial_category") : Random(0, ItemCategories - 1));
            Index = Random(0, ItemMax[Category] - 1);
            
            // We're not having any luck meeting the criteria, or the min/max value are impossible values to meet (0 / 0)
            // Break and give up on generating a shop special this time
            if (Tries > 100 || (MinValue == 0 && MaxValue == 0))
            {
                ValidItem = false;
                break;
            };
            
            // Retry if you land on an item with no cost
            if (ItemData[Category][Index].Price == 0)
            {
                ValidItem = false;
                Tries++;
                continue;
            };
            
            // Skip Loot category entirely
            if (Category == 7)
            {
                ValidItem = false;
                Tries++;
                continue;
            };
            
            // Make sure the item is within the valid price range
            if (ItemData[Category][Index].Price < MinValue || ItemData[Category][Index].Price > MaxValue)
            {
                ValidItem = false;
                Tries++;
                continue;
            };
            
            // Item is valid, continue
            if (ValidItem)
                break;
        };
        
        if (ValidItem)
        {
            // Assign the item to the Shop Special item
            ShopSpecialItem = &ItemData[Category][Index];
            
            // Spawn the item if you're in the Outpost
            SpawnShopSpecialItem();
        };
        
        // Reset the timer and bought status
        ShopSpecialTimer = 35 * 60 * GetCVar("drpg_shopspecial_time");
        ShopSpecialBought = false;
        
        if (GetCVar("drpg_debug"))
        {
            if (ShopSpecialItem == GetBlankItem())
                Log("\cdDEBUG: Shop Special expired! \caNo new item generated\n")
            else
                Log("\cdDEBUG: Shop Special expired! Now \cj%s\n", ShopSpecialItem->Name);
        };
    };
    
    // Remove the item if it was bought
    if (InBase && ShopSpecialBought)
        Thing_Remove(ShopSpecialTID + 1);
    
    // Decrease the timer
    ShopSpecialTimer--;
    
    Delay(1);
    goto Start;
};

// Handles the Items dynamic array and associated behavior
script void ItemHandler()
{
    // Create the Items Array
    for (int i = 0; i < MAX_ITEMS; i++)
    {
        ItemTIDs[i] = -1;
        
        if ((Timer() % 5) == 0)
            Delay(1);
    };
    
    // Items array initialization complete
    ItemsInitialized = true;
    
    while (ItemsInitialized && !InBase)
    {
        for (int i = 0; i < MAX_ITEMS; i++)
        {
            // We've hit the end of the array
            if (ItemTIDs[i] == -1) break;
            
            // Invalid item, continue
            if (ItemTIDs[i] == 0) continue;
            
            // Iterate players and check distances
            bool NoClip = false;
            for (int j = 0; j < MAX_PLAYERS; j++)
            {
                // Skip this player if they aren't in the game
                if (!PlayerInGame(j)) continue;
                
                // Skip this player if they aren't Magnetic
                if (Players(j).Stim.PowerupTimer[STIM_MAGNETIC] <= 0) continue;
                
                // Skip this player if they are dead
                if (GetActorProperty(Players(j).TID, APROP_Health) <= 0) continue;
                
                fixed Dist = Distance(ItemTIDs[i], Players(j).TID);
                fixed Height = GetActorPropertyFixed(Players(j).TID, APROP_Height);
                fixed Divisor = (Dist - 16.0) + Dist;
                fixed Amount;
                fixed X;
                fixed Y;
                fixed Z;
                
                // Calculate the amount based on close versus far distance
                if (Dist < 16.0)
                    Amount = 1.0
                else
                    Amount = 16.0 / Divisor;
                
                // Calculate the lerped positions
                X = Lerp(GetActorX(ItemTIDs[i]), GetActorX(Players(j).TID), Amount);
                Y = Lerp(GetActorY(ItemTIDs[i]), GetActorY(Players(j).TID), Amount);
                Z = Lerp(GetActorZ(ItemTIDs[i]), GetActorZ(Players(j).TID) + 32.0, Amount);
                
                SetActorPosition(ItemTIDs[i], X, Y, Z, false);
                NoClip = true;
            };
            
            // Enable/Disable clipping on this item
            if (NoClip)
                SetActorInventory(ItemTIDs[i], "DRPGItemNoClip", 1)
            else
                SetActorInventory(ItemTIDs[i], "DRPGItemNoClipOff", 1);
        };
        
        Delay(1);
    };
};

// Initializes an item and adds it to the Items array
acscript void ItemInit()
{
    // Delay while the Items array is being initialized
    while (!ItemsInitialized) Delay(4);
    
    // [KS] Some items cease existing once they're added to inventory
    // If that's the case, return early so we don't add empty item info
    if (ClassifyActor(0) == ACTOR_WORLD)
        return;
    
    // Add to Items array
    for (int i = 0; i < MAX_ITEMS; i++)
        if (ItemTIDs[i] == -1)
        {
            //if (GetCVar("drpg_debug"))
            //    Log("\cdDEBUG: \c-Item \cd%s\c- added (Index \cd%d\c-)\n", GetActorClass(0), i);
            
            // Doesn't have a TID, so assign it one
            if (ActivatorTID() == 0)
            {
                int TID = UniqueTID();
                ItemTIDs[i] = TID;
                Thing_ChangeTID(0, TID);
            }
            else
                ItemTIDs[i] = ActivatorTID();
            
            break;
        };
};

acscript void ItemDump()
{
    Log("\cd  ===== ITEM ARRAY DATA =====\n");
    
    for (int i = 0; i < MAX_ITEMS; i++)
    {
        if (ItemTIDs[i] == -1) break;
        Log("\cd%d\c-: \cd%s\n", i, GetActorClass(ItemTIDs[i]));
    };
    
    Log("\cd  ===== ITEM ARRAY DATA END =====\n");
};

// Dynamic Loot Generation System
script void DynamicLootGenerator(str Actor, int MaxItems)
{
    fixed LowerX = GetActorX(0);
    fixed UpperX = GetActorX(0);
    fixed LowerY = GetActorY(0);
    fixed UpperY = GetActorY(0);
    int LevelNum = GetLevelInfo(LEVELINFO_LEVELNUM);
    int Items = 0;
    int Instructions = 0;
    int Iterations = 0;
    
    // Initial delay to make sure all items have been added/initialized in the level
    Delay(5);
    
    // Determine the max amount of items to create if it's not specifically specified
    if (MaxItems == 0)
        MaxItems = Random(LevelNum / GameSkill(), LevelNum) + ((AveragePlayerLuck() + AveragePlayerLevel()) / (GameSkill() * 2));
    
    if (MaxItems == 0)
    {
        if (GetCVar("drpg_debug"))
            Log("\cdDebug: \c-Skipped item generation.\n");
        return;
    }
    else if (MaxItems < 0)
    {
        // [KS] Negative luck? Na na nana na! *raspberry*
        MaxItems = -MaxItems;
        Actor = "DRPGGenericMonsterDropper";
    };
    
    // Find the furthest item from the player to determine some approximate boundaries to work with
    for (int i = 0; ItemTIDs[i] != -1; i++)
    {
        if (ClassifyActor(ItemTIDs[i]) == ACTOR_WORLD) continue;
        
        fixed ItemX = GetActorX(ItemTIDs[i]);
        fixed ItemY = GetActorY(ItemTIDs[i]);
        
        if (LowerX > ItemX) LowerX = ItemX;
        if (UpperX < ItemX) UpperX = ItemX;
        if (LowerY > ItemY) LowerY = ItemY;
        if (UpperY < ItemY) UpperY = ItemY;
    };
    
    Delay(1);
    
    while (Items < MaxItems)
    {
        int TID = UniqueTID();
        fixed X = RandomFixed(LowerX, UpperX);
        fixed Y = RandomFixed(LowerY, UpperY);
        fixed Z = 0;
        
        // Try to keep Z near the floor
        SpawnForced("MapSpot", X, Y, 0, TID, 0);
        Z = GetActorFloorZ(TID);
        Thing_Remove(TID);
        
        bool Spawned = Spawn(Actor, X, Y, Z, TID, 32 * Random(0, 7));
        if (Spawned)
        {
            bool Remove = true;
            
            for (int i = 0; ItemTIDs[i] != -1; i++)
            {
                // If this spot is blank, skip it
                if (ClassifyActor(ItemTIDs[i]) == ACTOR_WORLD) continue;
                
                // Randomly continue for variance
                if (Random(1, 4) == 1) continue;
                
                bool CanSee = CheckSight(ItemTIDs[i], TID, 0);
                
                // [KS] Don't spawn stuff on special-effects flats like skyfloor or blackness, or at extreme height differences, because more often than not those are used as void space filler or instakill floors.
                // Examples: Epic2 MAP14, SF2012 MAP02, some CC4 maps.
                bool BadFloor = (CheckActorFloorTexture(TID, "F_SKY1") || CheckActorFloorTexture(TID, "F_SKY2") || CheckActorFloorTexture(TID, "BLACK") || CheckActorFloorTexture(TID, "FBLACK") || CheckActorFloorTexture(TID, "ALLBLAKF"));
                
                if (CanSee && !BadFloor && Abs(Z - GetActorZ(ItemTIDs[i])) <= 128)
                {
                    Remove = false;
                    Items++;
                    break;
                };
                
                Instructions++;
                if ((Instructions % 500) == 0)
                    Delay(1);
            };
            
            if (Remove)
                Thing_Remove(TID);
        };
        
        if (GetCVar("drpg_debug"))
            HudMessage("\cfGenerating Loot\n\cd%d \cj/ \cd%d\n\n\cdActor: \c-%s\n\ccInstructions: %d\n\cdIteration: %d\n\ciBoundaries: %k-%k, %k-%k\n\nX: %k\nY: %k\nZ: %k\n", Items, MaxItems, Actor, Instructions, Iterations, LowerX, UpperX, LowerY, UpperY, X, Y, Z, HUDMSG_FADEOUT, MAKE_ID('L', 'O', 'O', 'T'), CR_WHITE, 1.5, 0.8, 1.5, 0.5);
        
        Iterations++;
    };
    
    if (GetCVar("drpg_debug"))
        Log("\cdDebug: \c-Dynamic Loot Generation created \cd%d\c- items of type \cd%s\n", MaxItems, Actor);
};

// Quick Heal
acscript void QuickHeal(int Quick) net
{
    // If the player's dead, terminate
    if (GetActorProperty(0, APROP_Health) <= 0) return;
    
    int Health = Player.ActualHealth;
    int Percent = GetCVar("drpg_auto_heal_percent");
    
    if ((Health < Player.HealthMax / Percent) || Quick)
    {
        if (GetCVar("drpg_auto_heal_order") == 1) // Smallest to Largest
        {
                 if (CheckInventory("DRPGStimPack"))            UseInventory("DRPGStimPack")
            else if (CheckInventory("DRPGMedikit"))             UseInventory("DRPGMedikit")
            else if (CheckInventory("DRPGLargeMedikit"))        UseInventory("DRPGLargeMedikit")
            else if (CheckInventory("DRPGXLMedikit"))           UseInventory("DRPGXLMedikit")
            else if (CheckInventory("DRPGMedPack"))             UseInventory("DRPGMedPack")
            else if (CheckInventory("DRPGSurgeryKit"))          UseInventory("DRPGSurgeryKit");
        }
        else if (GetCVar("drpg_auto_heal_order") == 2) // Largest to Smallest
        {
                 if (CheckInventory("DRPGSurgeryKit"))          UseInventory("DRPGSurgeryKit")
            else if (CheckInventory("DRPGMedPack"))             UseInventory("DRPGMedPack")
            else if (CheckInventory("DRPGXLMedikit"))           UseInventory("DRPGXLMedikit")
            else if (CheckInventory("DRPGLargeMedikit"))        UseInventory("DRPGLargeMedikit")
            else if (CheckInventory("DRPGMedikit"))             UseInventory("DRPGMedikit")
            else if (CheckInventory("DRPGStimPack"))            UseInventory("DRPGStimPack");
        };
    };
};

// Quickly buy EP
acscript void QuickEP() net
{
    /* Disable this for now to try and make everyone happy
    if (!GetCVar("drpg_shoptype") && !InBase)
    {
        ActivatorSound("menu/error", 127);
        return;
    }; */
    
    int Amount = Player.EPMax - Player.EP;
    
    if (CheckInventory("DRPGCredits") > 0 && Player.EP < Player.EPMax)
    {
        ActivatorSound("health/epcapsule", 127);
        
        if (CheckInventory("DRPGCredits") < Amount)
            Amount = CheckInventory("DRPGCredits");
        
        TakeInventory("DRPGCredits", Amount);
        AddEP(Amount, false);
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return;
    };
};

// Death Script
script void Dead() death
{
    // Reset menu vars
    Player.InMenu = false;
    Player.InShop = false;
    Player.OutpostMenu = 0;
    
    // Remove Aura
    RemoveAura();
    
    // Remove Shield
    SetInventory("DRPGShield", 0);
    
    // Remove Status Effect
    for (int i = 0; i < SE_MAX; i++)
        Player.StatusTimer[i] = 0;
    
    // Drop Credits
    if (GetCVar("drpg_multi_dropcredits") && CheckInventory("DRPGCredits") > 0)
    {
        int DropAmount = CheckInventory("DRPGCredits") / 100 * GetCVar("drpg_multi_dropcredits_percent");
        
        // Cap out at a million so if you have stupid amounts of Credits you don't freeze/nuke the game
        if (DropAmount > 1000000) DropAmount = 1000000;
        
        TakeInventory("DRPGCredits", DropAmount);
        DropMoney(PlayerNumber(), 0, DropAmount);
    };
    
    // Drop Inventory
    if (GetCVar("drpg_multi_dropinv"))
        DropInventory();
    
    // VENG-R Accessory
    for (int i = 0; i < MAX_PLAYERS; i++)
    {
        // Skip yourself
        if (Player.TID == Players(i).TID) continue;
        
        if (Players(i).Shield.Accessory && Players(i).Shield.Accessory->PassiveEffect == SHIELD_PASS_AVENGER)
        {
            GiveActorInventory(Players(i).TID, "DRPGShieldAvengerDamage", 1);
            GiveActorInventory(Players(i).TID, "DRPGShieldAvengerDefense", 1);
        };
    };
    
    // Remove TID
    Thing_ChangeTID(Player.TID, 0);
};

// Respawn
script void Respawn() respawn
{
    // Reassign TID
    if (CompatMode == COMPAT_DRLA)
        Delay(4);
    AssignTIDs();
    
    // Heal to max health
    Player.ActualHealth = Player.HealthMax;
    SetActorProperty(0, APROP_Health, Player.ActualHealth);
    
    // XP/Rank Penalty
    if (GetCVar("drpg_multi_takexp"))
    {
        long int XPPenalty = (long int)(XPTable[Player.Level] * GetCVar("drpg_multi_takexp_percent") / 100);
        long int RankPenalty = (long int)(RankTable[Player.RankLevel] * GetCVar("drpg_multi_takexp_percent") / 100);
        
        if (XPPenalty > 0 || RankPenalty > 0)
        {
            Player.XP -= XPPenalty;
            Player.Rank -= RankPenalty;
            SetFont("BIGFONT");
            HudMessage("\cjXP -%d\n\ckRank -%d\n", XPPenalty, RankPenalty, HUDMSG_FADEOUT | HUDMSG_LOG, 0, CR_WHITE, 1.5, 0.75, 2.0, 2.0);
        };
    };
    
    // Restore EP if CVAR is set
    if (GetCVar("drpg_multi_restoreep"))
        Player.EP = Player.EPMax;
    
    // Give a box of ammo if a specific ammo type is empty if the CVAR is set
    if (GetCVar("drpg_multi_restoreammo"))
    {
        if (CheckInventory("Clip") < GetAmmoAmount("Clip") * (Player.Capacity / 10))
            SetInventory("Clip", GetAmmoAmount("Clip") * (Player.Capacity / 10));
        if (CheckInventory("Shell") < GetAmmoAmount("Shell") * (Player.Capacity / 10))
            SetInventory("Shell", GetAmmoAmount("Shell") * (Player.Capacity / 10));
        if (CheckInventory("RocketAmmo") < GetAmmoAmount("RocketAmmo") * (Player.Capacity / 10))
            SetInventory("RocketAmmo", GetAmmoAmount("RocketAmmo") * (Player.Capacity / 10));
        if (CheckInventory("Cell") < GetAmmoAmount("Cell") * (Player.Capacity / 10))
            SetInventory("Cell", GetAmmoAmount("Cell") * (Player.Capacity / 10));
    };
    
    // Apply camera textures and vars
    SetCameraToTexture(Player.TID, StrParam("P%iVIEW\n", PlayerNumber() + 1), 110);
    SetCameraToTexture(Player.TID, StrParam("P%iSVIEW\n", PlayerNumber() + 1), 90);
    Player.PlayerView = PlayerNumber();
    
    // Run Scripts
    Loop();
    PlayerDamage();
    DamageNumbers();
    InfoPopoffs();
    HealthBars();
    ShieldTimer();
    
    // GUI
	CheckGUI();
	CheckCursor();
    // UpdateMenu();
    
    // NU-YU Accessory
    if (Player.Shield.Accessory && Player.Shield.Accessory->PassiveEffect == SHIELD_PASS_HYPERION)
    {
        ActivatorSound("shield/newu", 127);
        Player.Shield.Active = true;
        Player.Shield.Charge = Player.Shield.Capacity;
        GiveInventory("DRPGShieldNewUProtection", 1);
    };
    
    // Quick Teleport
    if (GetPlayerInput(PlayerNumber(), INPUT_BUTTONS) & BT_SPEED)
    {
        int PlayerNum = -1;
        while (PlayerNum == -1 || PlayerNum == PlayerNumber() || !PlayerInGame(PlayerNum))
            PlayerNum = Random(0, PlayerCount());
        PlayerTeleport(PlayerNum);
        Player.EP -= ScaleEPCost(50);
    };
};

// Gives the player their default loadout based on their starting options
script void DefaultLoadout()
{
    static str[LOADOUT_WEAPONS][3] WeaponInfo =
    {
        // CVAR, Vanilla Actor, Extras Actor
        
        { "drpg_start_weapon_chainsaw";         "DRPGChainsaw";         "Chainsaw1";        };
        { "drpg_start_weapon_pistol";           "DRPGPistol";           "Pistol1";          };
        { "drpg_start_weapon_shotgun";          "DRPGShotgun";          "Shotgun1";         };
        { "drpg_start_weapon_ssg";              "DRPGSuperShotgun";     "SSG";              };
        { "drpg_start_weapon_chaingun";         "DRPGChaingun";         "Chaingun1";        };
        { "drpg_start_weapon_rocketlauncher";   "DRPGRocketLauncher";   "RocketLauncher1";  };
        { "drpg_start_weapon_plasmarifle";      "DRPGPlasmaRIfle";      "Plasmagun";        };
        { "drpg_start_weapon_bfg";              "DRPGBFG9001";          "BFG9001";          };
    };
    static str[LOADOUT_ARMORS] ArmorInfo =
    {
        "DRPGGreenArmorEffect";
        "DRPGBlueArmorEffect";
        "DRPGYellowArmorEffect";
        "DRPGRedArmorEffect";
        "DRPGWhiteArmorEffect";
        "DRPGReinforcedGreenArmorEffect";
        "DRPGReinforcedBlueArmorEffect";
        "DRPGReinforcedYellowArmorEffect";
        "DRPGReinforcedRedArmorEffect";
        "DRPGReinforcedWhiteArmorEffect";
    };
    static str[LOADOUT_SHIELDPARTS] ShieldPartColorCodes =
    {
        "\cv";  // Capacity +
        "\ch";  // Capacity -
        "\cd";  // Charge Rate +
        "\cq";  // Charge Rate -
        "\cr";  // Delay Rate +
        "\cg";  // Delay Rate -
    };
    static str[LOADOUT_SHIELDACCS] ShieldAccessoryColorCodes =
    {
        "\cg";  // Strength / Damage
        "\ca";  // Vitality / Health
        "\ci";  // Agility / Speed
        "\cd";  // Defense / Armor
        "\cf";  // Luck / Money
        "\cn";  // Energy
        "\ch";  // Capacity / Ammo
        "\ck";  // Rank
        "\cc";  // Augmentation
        "\cq";  // Powerup
        "\cj";  // Misc / Multi-Category
    };
    static str[LOADOUT_DRLAWEAPONS] DRLAWeaponColorCodes =
    {
        "";     // Common
        "\cv";  // Assembled
        "\ct";  // Exotic
        "\ci";  // Superior
        "\cd";  // Unique
        "\cg";  // Demonic
        "\cf";  // Legendary
    };
    static str[LOADOUT_DRLAARMORS] DRLAArmorColorCodes =
    {
        "";     // Common
        "\cv";  // Assembled
        "\ct";  // Exotic
        "\cc";  // Onyx
        "\cd";  // Unique
        "\cf";  // Legendary
    };
    static str[LOADOUT_DRLAMODPACKS] DRLAModPacks =
    {
        "RLPowerModItem";
        "RLBulkModItem";
        "RLAgilityModItem";
        "RLTechnicalModItem";
        "RLSniperModItem";
        "RLFirestormModItem";
        "RLNanoModItem";
        "RLOnyxModItem";
    };
    
    // Shield Databases
    ItemInfoPtr [LOADOUT_SHIELDPARTS][MAX_PARTS * 3] ShieldPartTypes;
    ItemInfoPtr [LOADOUT_SHIELDACCS][MAX_ACCESSORIES] ShieldAccessoryTypes;
    int[LOADOUT_SHIELDPARTS] PartCount;
    int[LOADOUT_SHIELDACCS] AccessoryCount;
    
    // DRLA Databases
    ItemInfoPtr [LOADOUT_DRLAWEAPONS][ITEM_MAX] DRLAWeaponTypes;
    ItemInfoPtr [LOADOUT_DRLAARMORS][ITEM_MAX] DRLAArmorTypes;
    ItemInfoPtr [LOADOUT_DRLAARMORS][ITEM_MAX] DRLABootsTypes;
    int[LOADOUT_DRLAWEAPONS] DRLAWeaponCount;
    int[LOADOUT_DRLAARMORS] DRLAArmorCount;
    int[LOADOUT_DRLAARMORS] DRLABootsCount;
    
    // Delay to allow for item data to initialize
    Delay(4);
    
    // Build Shield and DRLA item databases based on their respective items' color codes
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < ShieldPartsMax[i]; j++)
            for (int k = 0; k < LOADOUT_SHIELDPARTS; k++)
                if (Contains(ShieldParts[i][j].Name, ShieldPartColorCodes[k]))
                {
                    ShieldPartTypes[k][PartCount[k]++] = FindItemInCategory(ShieldParts[i][j].Actor, 5);
                    break;
                };
    for (int i = 0; i < MAX_ACCESSORIES; i++)
        for (int j = 0; j < LOADOUT_SHIELDACCS; j++)
            if (Contains(ShieldAccessories[i].Name, ShieldAccessoryColorCodes[j]))
            {
                ShieldAccessoryTypes[j][AccessoryCount[j]++] = FindItemInCategory(ShieldAccessories[i].Actor, 5);
                break;
            };
    for (int i = 0; i < ItemMax[0]; i++)
        for (int j = 1; j < LOADOUT_DRLAWEAPONS; j++)
        {
            if (i < 10) // Special catch for Common
            {
                DRLAWeaponTypes[0][DRLAWeaponCount[0]++] = &ItemData[0][i];
                break;
            }
            else if (Contains(ItemData[0][i].Name, DRLAWeaponColorCodes[j]))
            {
                DRLAWeaponTypes[j][DRLAWeaponCount[j]++] = &ItemData[0][i];
                break;
            };
        };
    for (int i = 1; i < ItemMax[3]; i++)
        for (int j = 1; j < LOADOUT_DRLAARMORS; j++)
        {
            // Onyx is handled below
            if (j == 3) continue;
            
            if (i < 4) // Special catch for Common
            {
                DRLAArmorTypes[0][DRLAArmorCount[0]++] = &ItemData[3][i];
                break;
            }
            else if (Contains(ItemData[3][i].Name, "Onyx")) // Special catch for Onyx
            {
                DRLAArmorTypes[3][DRLAArmorCount[3]++] = &ItemData[3][i];
                break;
            }
            else if (Contains(ItemData[3][i].Name, DRLAArmorColorCodes[j]))
            {
                DRLAArmorTypes[j][DRLAArmorCount[j]++] = &ItemData[3][i];
                break;
            };
        };
    for (int i = 0; i < ItemMax[9]; i++)
        for (int j = 1; j < LOADOUT_DRLAARMORS; j++)
        {
            if (i < 3) // Special catch for Common
            {
                DRLABootsTypes[0][DRLABootsCount[0]++] = &ItemData[9][i];
                break;
            }
            else if (Contains(ItemData[9][i].Name, DRLAArmorColorCodes[j]))
            {
                DRLABootsTypes[j][DRLABootsCount[j]++] = &ItemData[9][i];
                break;
            };
        };
    
    // Weapons
    if (CompatMode != COMPAT_DRLA)
    {
        for (int i = 0; i < 8; i++)
        {
            if (GetCVar(WeaponInfo[i][0]))
            {
                if (CompatMode == COMPAT_EXTRAS)
                {
                    GiveInventory(WeaponInfo[i][2], 1);
                    SetWeapon(WeaponInfo[i][2]);
                }
                else
                {
                    GiveInventory(WeaponInfo[i][1], 1);
                    SetWeapon(WeaponInfo[i][1]);
                };
            }
            else
            {
                if (CompatMode == COMPAT_EXTRAS)
                    TakeInventory(WeaponInfo[i][2], 1)
                else
                    TakeInventory(WeaponInfo[i][1], 1);
            };
        };
    };
    
    // Ammo
    SetInventory("Clip", GetCVar("drpg_start_ammo_bullet"));
    SetInventory("Shell", GetCVar("drpg_start_ammo_shell"));
    SetInventory("RocketAmmo", GetCVar("drpg_start_ammo_rocket"));
    SetInventory("Cell", GetCVar("drpg_start_ammo_cell"));
    
    // Armor
    if (CompatMode != COMPAT_DRLA && GetCVar("drpg_start_armor") > 0)
        GiveInventory(ArmorInfo[GetCVar("drpg_start_armor") - 1], 1);
    
    // Active Augs
    int ActiveAugs = 0;
    while (ActiveAugs < GetCVar("drpg_start_aug_amount"))
    {
        int Type = Random(0, AUG_MAX - 1);
        
        // Skip this aug if it's already active
        if (Player.Augs.Level[Type] > 0) continue;
        
        Player.Augs.Level[Type]++;
        ActiveAugs++;
        
        if ((Timer() % 5) == 0)
            Delay(1);
    };
    
    // Aug Canisters/Upgrades
    int AugItems = 0;
    while (AugItems < GetCVar("drpg_start_aug_upgrades"))
    {
        int Type = Random(0, 1);
        
        // Check if one or the other is max
        if (CheckInventory("DRPGAugCanister") >= 100)
            Type = 1;
        if (CheckInventory("DRPGAugUpgradeCanister") >= 100)
            Type = 0;
        
        if (Type == 1)
            GiveInventory("DRPGAugCanister", 1)
        else
            GiveInventory("DRPGAugUpgradeCanister", 1);
        
        AugItems++;
        
        if ((Timer() % 5) == 0)
            Delay(1);
    };
    
    // Aug Slots
    SetInventory("DRPGAugSlotUpgrade", GetCVar("drpg_start_aug_slots"));
    
    // Shield Parts
    bool FoundPart = false;
    int Parts = 0;
    int Accessories = 0;
    
    // Bodies, Batteries, Capacitors
    while (Parts < GetCVar("drpg_start_shield_amount"))
    {
        for (int i = 0; i < LOADOUT_SHIELDPARTS; i++)
        {
            FoundPart = false;
        
            // If this shield type doesn't match what you selected, continue to the next category
            if (GetCVar("drpg_start_shield_type") > 0 && i != GetCVar("drpg_start_shield_type") - 1) continue;
            
            for (int j = 0; j < PartCount[i]; j++)
                if (Random(1, 4) == 1 && !CheckInventory(ShieldPartTypes[i][j]->Actor))
                {
                    GiveInventory(ShieldPartTypes[i][j]->Actor, 1);
                    Parts++;
                    FoundPart = true;
                    break;
                };
            
            if (FoundPart)
                break;
        };
        
        if ((Timer() % 5) == 0)
            Delay(1);
    };
    
    // Shield Accessories
    while (Accessories < GetCVar("drpg_start_shield_amount_acc"))
    {
        for (int i = 0; i < LOADOUT_SHIELDACCS; i++)
        {
            FoundPart = false;
        
            // If this shield type doesn't match what you selected, continue to the next category
            if (GetCVar("drpg_start_shield_type_acc") > 0 && i != GetCVar("drpg_start_shield_type_acc") - 1) continue;
            
            for (int j = 0; j < AccessoryCount[i]; j++)
                if (Random(1, 4) == 1 && !CheckInventory(ShieldAccessoryTypes[i][j]->Actor))
                {
                    GiveInventory(ShieldAccessoryTypes[i][j]->Actor, 1);
                    Accessories++;
                    FoundPart = true;
                    break;
                };
            
            if (FoundPart)
                break;
        };
        
        if ((Timer() % 5) == 0)
            Delay(1);
    };
    
    // Stims
    int Injectors = 0;
    int Vials = 0;
    while (Injectors < GetCVar("drpg_start_stim_injectors"))
    {
        switch (Random(1, 4))
        {
        case 1: // Small
            if (CheckInventory("DRPGStimSmall") >= 1000) continue;
            GiveInventory("DRPGStimSmall", 1);
            break;
        case 2: // Medium
            if (CheckInventory("DRPGStimMedium") >= 1000) continue;
            GiveInventory("DRPGStimMedium", 1);
            break;
        case 3: // Large
            if (CheckInventory("DRPGStimLarge") >= 1000) continue;
            GiveInventory("DRPGStimLarge", 1);
            break;
        case 4: // XL
            if (CheckInventory("DRPGStimXL") >= 1000) continue;
            GiveInventory("DRPGStimXL", 1);
            break;
        };
        
        Injectors++;
        
        if ((Timer() % 5) == 0)
            Delay(1);
    };
    while (Vials < GetCVar("drpg_start_stim_vials"))
    {
        int Type = Random(0, STIM_MAX - 1);
        bool Maxed = true;
        
        // Check to make sure all the vials aren't maxed
        for (int i = 0; i < STIM_MAX; i++)
            if (Player.Stim.Vials[i] < Player.Capacity * 10)
                Maxed = false;
        if (Maxed) break;
        
        // Don't include Boosters
        if (!GetCVar("drpg_start_stim_boosters") && Type >= StimStatsEnd && Type <= StimPowerupStart) continue;
        
        // Don't include Powerups
        if (!GetCVar("drpg_start_stim_powerups") && Type >= StimPowerupStart && Type <= StimPowerupEnd) continue;
        
        // Skip this one if this vial type is full
        if (Player.Stim.Vials[Type] >= Player.Capacity * 10) continue;
        
        Player.Stim.Vials[Type]++;
        Vials++;
        
        if ((Timer() % 5) == 0)
            Delay(1);
    };
    
    // Minigame Chips
    int Chips = 0;
    while (Chips < GetCVar("drpg_start_bonus_chips"))
    {
        int Type = Random(0, 1);
        
        // Check if one or the other is max
        if (CheckInventory("DRPGChipGold") >= 1000)
            Type = 1;
        if (CheckInventory("DRPGChipPlatinum") >= 1000)
            Type = 0;
        
        if (Type == 1)
            GiveInventory("DRPGChipGold", 1)
        else
            GiveInventory("DRPGChipPlatinum", 1);
        
        Chips++;
        
        if ((Timer() % 5) == 0)
            Delay(1);
    };
    
    // UAC Shop Card
    if (GetCVar("drpg_start_bonus_shopcard") > 0)
    {
        // Diamond Card
        if (GetCVar("drpg_start_bonus_shopcard") == 5)
            GiveInventory("DRPGDiamondUACCard", 1)
        else
            GiveInventory("DRPGUACCard", GetCVar("drpg_start_bonus_shopcard"));
    };
    
    // Payout Bonus
    Player.PayBonus = GetCVar("drpg_start_bonus_payout");
    
    // DRLA
    if (CompatMode == COMPAT_DRLA)
    {
        bool FoundWeapon = false;
        bool FoundArmor = false;
        bool FoundBoots = false;
        int WeaponCount = 0;
        int MaxWeaponCount = GetCVar("drpg_start_drla_weapon_amount");
        int ModPackCount = 0;
        int ModPackMax = GetCVar("drpg_start_drla_modpacks");
        
        // Weapons
        if (GetCVar("drpg_start_drla_weapon_type") > 0)
            if (MaxWeaponCount > DRLAWeaponCount[GetCVar("drpg_start_drla_weapon_type") - 1])
                MaxWeaponCount = DRLAWeaponCount[GetCVar("drpg_start_drla_weapon_type") - 1];
        while (WeaponCount < MaxWeaponCount)
        {
            for (int i = 0; i < LOADOUT_DRLAWEAPONS; i++)
            {
                FoundWeapon = false;
                
                // If this weapon type doesn't match what you selected, continue to the next category
                if (GetCVar("drpg_start_drla_weapon_type") > 0 && i != GetCVar("drpg_start_drla_weapon_type") - 1) continue;
                
                for (int j = 0; j < DRLAWeaponCount[i]; j++)
                    if (Random(1, 10) == 1 && !CheckInventory(DRLAWeaponTypes[i][j]->Actor))
                    {
                        GiveInventory(DRLAWeaponTypes[i][j]->Actor, 1);
                        WeaponCount++;
                        FoundWeapon = true;
                        break;
                    };
                
                if (FoundWeapon)
                    break;
            };
            
            if ((Timer() % 5) == 0)
                Delay(1);
        };
        GiveInventory("RLWeaponLimit", WeaponCount);
        
        // Armor
        if (GetCVar("drpg_start_drla_armor") >= 0)
            while (!FoundArmor)
            {
                for (int i = 0; i < LOADOUT_DRLAARMORS; i++)
                {
                    // If this armor type doesn't match what you selected, continue to the next category
                    if (GetCVar("drpg_start_drla_armor") >= 0 && i != GetCVar("drpg_start_drla_armor") - 1) continue;
                    
                    // If there is nothing in this category, skip it
                    if (GetCVar("drpg_start_drla_armor") >= 0 && DRLAArmorCount[GetCVar("drpg_start_drla_armor") - 1] == 0)
                    {
                        FoundArmor = true;
                        break;
                    };
                    
                    for (int j = 0; j < DRLAArmorCount[i]; j++)
                        if (Random(1, 10) == 1)
                        {
                            GiveInventory(DRLAArmorTypes[i][j]->Actor, 1);
                            FoundArmor = true;
                            break;
                        };
                    
                    if (FoundArmor)
                        break;
                };
                
                if ((Timer() % 5) == 0)
                    Delay(1);
            };
            
        // Boots
        if (GetCVar("drpg_start_drla_boots") >= 0)
            while (!FoundBoots)
            {
                for (int i = 0; i < LOADOUT_DRLAARMORS; i++)
                {
                    // If this armor type doesn't match what you selected, continue to the next category
                    if (GetCVar("drpg_start_drla_boots") >= 0 && i != GetCVar("drpg_start_drla_boots") - 1) continue;
                    
                    // If there is nothing in this category, skip it
                    if (GetCVar("drpg_start_drla_boots") >= 0 && DRLABootsCount[GetCVar("drpg_start_drla_boots") - 1] == 0)
                    {
                        FoundBoots = true;
                        break;
                    };
                    
                    for (int j = 0; j < DRLABootsCount[i]; j++)
                        if (Random(1, 10) == 1)
                        {
                            GiveInventory(DRLABootsTypes[i][j]->Actor, 1);
                            FoundBoots = true;
                            break;
                        };
                    
                    if (FoundBoots)
                        break;
                };
                
                if ((Timer() % 5) == 0)
                    Delay(1);
            };
        
        // Mod Packs
        if (PlayerClass(0) == 2)
            ModPackMax--;
        while (ModPackCount < ModPackMax)
        {
            int Type = Random(0, LOADOUT_DRLAMODPACKS - 1);
            
            // Stop if we're not the technician and we try and give over 4 mods
            if (PlayerClass(0) != 2 && ModPackCount >= 4) break;
            
            // Skip exotic modpacks if the selection is disabled
            if (Type > 3 && GetCVar("drpg_start_drla_modpacks_amount")) continue;
            
            GiveInventory(DRLAModPacks[Type], 1);
            ModPackCount++;
            
            if ((Timer() % 5) == 0)
                Delay(1);
        };
    };
};

// Apply values to global vars visible on the HUD
function void CheckHUD()
{
    int PlayerNum = PlayerNumber();
    
    // EP
    EP[PlayerNum] = Player.EP;
    
    // EP Bar on HUD
    if (Player.EPMax <= 0)
        SetInventory("DRPGEP", 0)
    else
        SetInventory("DRPGEP", Player.EP * 100 / Player.EPMax);
    
    // Shield
    if (Player.Shield.Capacity > 0)
    {
        Shield[PlayerNum] = Player.Shield.Charge;
        ShieldCapacity[PlayerNum] = Player.Shield.Capacity;
        ShieldHealth[PlayerNum] = Player.ActualHealth;
        SetInventory("DRPGShieldCapacity", (int)(((fixed)Player.Shield.Charge / (fixed)Player.Shield.Capacity) * 100.0));
        SetInventory("DRPGShield", Player.Shield.Active);
    };
    
    // Items
    Credits[PlayerNum] = CheckInventory("DRPGCredits");
};

function void CheckKeys()
{
    static str[6] Keycards =
    {
        "DRPGRedCard";
        "DRPGYellowCard";
        "DRPGBlueCard";
        "DRPGRedSkull";
        "DRPGYellowSkull";
        "DRPGBlueSkull";
    };
    
    // Don't bother if we're not in multiplayer
    if (!InMultiplayer) return;
    
    for (int i = 0; i < 6; i++)
    {
        if (CheckInventory(Keycards[i]))
        {
            for (int j = 0; j < MAX_PLAYERS; j++)
            {
                if (!PlayerInGame(j)) continue;
                if (CheckActorInventory(Players(j).TID, Keycards[i])) continue;
                SetActorInventory(Players(j).TID, Keycards[i], 1);
            };
        };
    };
};

function void CheckCompatibility()
{
    bool Success = false;
    int TID = UniqueTID();
    
    if (GetCVar("drpg_debug"))
        Log("\cdDEBUG: \c-Checking Compatibility...\n");
    
    CompatMode = COMPAT_NONE;
    
    // Extras
    Success = SpawnForced("DRPGExtrasIsLoaded", 0, 0, 0, TID, 0);
    if (Success)
    {
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: \caExtras\c- detected\n");
        CompatMode = COMPAT_EXTRAS;
        Thing_Remove(TID);
        return;
    };
    
    // DoomRL
    Success = SpawnForced("RLKateMatterstormHarnessArmorToken", 0, 0, 0, TID, 0);
    if (Success)
    {
        if (GetCVar("drpg_debug"))
            Log("\cdDEBUG: \cdDoomRL \c-detected\n");
        CompatMode = COMPAT_DRLA;
        SetInventory("DRPGDRLAActive", 1);
        Thing_Remove(TID);
        return;
    };
};

function void AssignTIDs()
{
    Player.TID = PLAYER_TID + PlayerNumber();
    Thing_ChangeTID(0, Player.TID);
    
    if (GetCVar("drpg_debug"))
        Log("\cdDEBUG: Player TID: %d\n", Player.TID);
};
