#include "Arena.dh"
#include "Globals.dh"
#include "Menu.dh"
#include "Monsters.dh"
#include "Outpost.dh"
#include "RPG.dh"
#include "Shop.dh"
#include "SkillData.dh"
#include "Skills.dh"
#include "Stats.dh"
#include "Utils.dh"

bool Overdrive;
int BulletTimeTimer;

int[MAX_CATEGORIES] SkillCategoryMax =
{
    7; 9; 9; 3; 17; 7;
};

// Skill Wheel
script void SkillWheel() enter
{
    Start:
    
    int Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
    int OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
    int Selected = -1;
    int LastSelected = -1;
    int Radius = 96;
    int CurrentRadius = 0;
    Skill *CurrentSkill;
    
    // Open the wheel
    if (Buttons & BT_USER1 && !((Player.InMenu && Player.Menu != 3) || Player.InShop || Player.OutpostMenu > 0))
    {
        ActivatorSound("menu/click", 127);
        Player.SkillWheelOpen = true;
    };
    
    // Wheel Loop
    while (Player.SkillWheelOpen)
    {
        SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
        
        // Check Input
        Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
        OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
        
        // Check for release
        if (!(Buttons & BT_USER1) && !(Buttons & BT_SPEED))
        {
            if (Selected != -1)
            {
                if (Player.InMenu && Player.Menu == 3)
                {
                    Player.SkillCategory[Selected] = Player.SkillPage;
                    Player.SkillIndex[Selected] = Player.MenuIndex;
                }
                else
                    Player.SkillSelected = Selected;
            };
            
            SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
            CurrentRadius = Radius;
            Player.SkillWheelOpen = false;
        };
        
        // Selection
        fixed MouseX = -GetPlayerInputFixed(PlayerNumber(), INPUT_YAW) * 1.2;
        fixed MouseY = GetPlayerInputFixed(PlayerNumber(), INPUT_PITCH);
        if (CurrentRadius >= Radius)
        {
            if (Buttons == (BT_USER1 | BT_FORWARD) && Selected != 0)
                Selected = 0
            else if (Buttons == (BT_USER1 | BT_FORWARD | BT_MOVERIGHT) && Selected != 1)
            {
                Selected = 1;
                Delay(5);
            }
            else if (Buttons == (BT_USER1 | BT_MOVERIGHT) && Selected != 2)
                Selected = 2
            else if (Buttons == (BT_USER1 | BT_MOVERIGHT | BT_BACK) && Selected != 3)
            {
                Selected = 3;
                Delay(5);
            }
            else if (Buttons == (BT_USER1 | BT_BACK) && Selected != 4)
                Selected = 4
            else if (Buttons == (BT_USER1 | BT_BACK | BT_MOVELEFT) && Selected != 5)
            {
                Selected = 5;
                Delay(5);
            }
            else if (Buttons == (BT_USER1 | BT_MOVELEFT) && Selected != 6)
                Selected = 6
            else if (Buttons == (BT_USER1 | BT_MOVELEFT | BT_FORWARD) && Selected != 7)
            {
                Selected = 7;
                Delay(5);
            }
            // There used to be non-working stuff here, but I fixed it to be working. -Kate
            else if ((FixedSqrt(MouseX * MouseX + MouseY * MouseY)) > 0.02)
            {
                if (VectorAngle(MouseX, MouseY) > 0.1875 && VectorAngle(MouseX, MouseY) < 0.3125)
                    Selected = 0
                else if (VectorAngle(MouseX, MouseY) > 0.0625 && VectorAngle(MouseX, MouseY) < 0.1875)
                    Selected = 1
                else if (VectorAngle(MouseX, MouseY) >= 0 && VectorAngle(MouseX, MouseY) < 0.0625)
                    Selected = 2
                else if (VectorAngle(MouseX, MouseY) <= 1 && VectorAngle(MouseX, MouseY) > 0.9375)
                    Selected = 2
                else if (VectorAngle(MouseX, MouseY) > 0.8125 && VectorAngle(MouseX, MouseY) < 0.9375)
                    Selected = 3
                else if (VectorAngle(MouseX, MouseY) > 0.6875 && VectorAngle(MouseX, MouseY) < 0.8125)
                    Selected = 4
                else if (VectorAngle(MouseX, MouseY) > 0.5625 && VectorAngle(MouseX, MouseY) < 0.6875)
                    Selected = 5
                else if (VectorAngle(MouseX, MouseY) > 0.4375 && VectorAngle(MouseX, MouseY) < 0.5625)
                    Selected = 6
                else if (VectorAngle(MouseX, MouseY) > 0.3125 && VectorAngle(MouseX, MouseY) < 0.4375)
                    Selected = 7;
            };
            // else
               // Selected = -1;
        };
        
        // Extra Input Handling
        if (Buttons & BT_SPEED && Selected != -1)
        {
            Skill *CurrentSkill = &Skills[Player.SkillCategory[Selected]][Player.SkillIndex[Selected]];
            
            // Decrease selected skill level
            if (Buttons & BT_MOVELEFT && !(OldButtons & BT_MOVELEFT) && CurrentSkill->CurrentLevel > 1)
            {
                CurrentSkill->CurrentLevel--;
                AmbientSound("menu/move", 127);
            };
            
            // Increase selected skill level
            if (Buttons & BT_MOVERIGHT && !(OldButtons & BT_MOVERIGHT) && CurrentSkill->CurrentLevel < CurrentSkill->Level)
            {
                CurrentSkill->CurrentLevel++;
                AmbientSound("menu/move", 127);
            };
            
            // Clear Skill
            if (Buttons & BT_USE)
            {
                Player.SkillCategory[Selected] = -1;
                Player.SkillIndex[Selected] = -1;
                AmbientSound("menu/move", 127);
            };
        };
        
        // Set Skill
        if (Selected >= 0 && Player.SkillCategory[Selected] != -1 && Player.SkillIndex[Selected] != -1)
            CurrentSkill = &Skills[Player.SkillCategory[Selected]][Player.SkillIndex[Selected]]
        else
            CurrentSkill = nullptr;
        
        // Play sound
        if (Selected != LastSelected && Selected >= 0)
            ActivatorSound("menu/click", 127);
        
        LastSelected = Selected;
        
        // Draw Wheel
        SetHudSize(640, 480, false);
        for (int i = 0; i < MAX_SKILLKEYS; i++)
        {
            fixed Angle = -0.25 + ((1.0 / MAX_SKILLKEYS) * i);
            fixed X = 320.0 + (CurrentRadius * Cos(Angle));
            fixed Y = 240.0 + (CurrentRadius * Sin(Angle));
            
            // Cursor
            if (i == Selected)
                PrintSprite("SelectBo", 0, (int)X, (int)Y, 0.05);
            
            // Icon
            if (Player.SkillCategory[i] != -1 && Player.SkillIndex[i] != -1)
            {
                if (StrLen(Skills[Player.SkillCategory[i]][Player.SkillIndex[i]].Icon) == 0)
                    PrintSpriteFade("SprNone", WHEEL_ID + i, (int)X, (int)Y, 0.05, 1.0)
                else
                    PrintSpriteFade(Skills[Player.SkillCategory[i]][Player.SkillIndex[i]].Icon, WHEEL_ID + i, (int)X, (int)Y, 0.05, 1.0);
            };
            
            // Box
            PrintSpriteFade("ItemBox", WHEEL_ID + MAX_SKILLKEYS + i, (int)X, (int)Y, 0.05, 1.0);
        };
        
        // Animate Wheel
        if (CurrentRadius < Radius)
            CurrentRadius += GetCVar("drpg_skill_wheelspeed");
        
        // Skill Info
        if (CurrentSkill != nullptr)
        {
            int Cost = ScaleEPCost(CurrentSkill->Cost * CurrentSkill->CurrentLevel * Player.SkillCostMult);
            str CostColor = (Player.EP < Cost ? "\cg" : "\cv");
            str Info;
            
            // Build info string
            Info = StrParam("\cd%s\n\n\n", CurrentSkill->Name);
            Info = StrParam("%s\cjLevel: %d/%d\n\n", Info, CurrentSkill->CurrentLevel, CurrentSkill->Level);
            Info = StrParam("%s%s%d EP\n", Info, CostColor, Cost);
            
            // Display
            SetFont("SMALLFONT");
            SetHudClipRect(0, 0, 0, 0, 128);
            HudMessage("%s\n", Info, HUDMSG_FADEOUT, WHEEL_ID + (MAX_SKILLKEYS * 2), CR_WHITE, 320.4, 240.0, 0.05, 1.0);
            SetHudClipRect(0, 0, 0, 0, 0);
        };
        
        Delay(1);
    };
    
    Delay(1);
    goto Start;
};

acscript void UseSkill() net
{
    // Current Skill
    int Index = (Player.InMenu && Player.Menu == 3 ? -1 : Player.SkillSelected);
    Skill *CurrentSkill = &Skills[Player.SkillCategory[Index]][Player.SkillIndex[Index]];
    
    // If you're dead, terminate
    if (GetActorProperty(Player.TID, APROP_Health) <= 0) return;
    
    // If you have no current skill selected, terminate
    if (Player.SkillSelected == -1 && !Player.InMenu) return;
    
    // If the key is unassigned, terminate
    if (Index != -1)
        if (Player.SkillCategory[Index] == -1 || Player.SkillIndex[Index] == -1) return;
    
    // Quickuse
    if (Index == -1)
        CurrentSkill = &Skills[Player.SkillPage][Player.MenuIndex];
    
    int Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
    int OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
    int EPCost = ScaleEPCost(CurrentSkill->Cost * CurrentSkill->CurrentLevel * Player.SkillCostMult);
    bool Success;
    
    // Overdrive?
    Overdrive = false;
    if (Buttons & BT_SPEED && (!Player.InMenu && !Player.InShop))
        Overdrive = true;
    
    // Overdriving an unlearnt skill will learn it
    if (Overdrive && CheckInventory("DRPGSkillToken") > 0 && CurrentSkill->Level == 0)
    {
        CurrentSkill->Level++;
        CurrentSkill->CurrentLevel++;
        TakeInventory("DRPGSkillToken", 1);
        FadeRange(0, 255, 255, 0.5, 0, 255, 255, 0.0, 0.5);
        return;
    };
    
    // Check if the Skill has been learned yet
    if (CurrentSkill->Level == 0)
    {
        SetFont("BIGFONT");
        HudMessage("You don't know this skill yet\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("skills/fail", 127);
        return;
    };

    // Can't use skills while burned out
    if (Player.EP < 0)
    {
        SetFont("BIGFONT");
        HudMessage("You can't use skills while burned out\n", HUDMSG_FADEOUT, 0, CR_BLUE, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("skills/fail", 127);
        return;
    };
    
    // Use the Skill
    if (Player.EP >= EPCost || Overdrive)
    {
        // Data to pass to the script pointer
        void *Data = nullptr;
        auto int DataCategory = (Index == -1 ? Player.SkillPage : Player.SkillCategory[Player.SkillSelected]);
        auto int DataIndex = (Index == -1 ? Player.MenuIndex : Player.SkillIndex[Player.SkillSelected]);
        
        // Powerups, Auras and Summons need their index passed
        if (DataCategory == 1 || DataCategory == 2 || DataCategory == 4)
            Data = &DataIndex;
        
        // Debugging
        if (GetCVar("drpg_debug"))
        {
            Log("\cdDEBUG: \c-EP Cost for %s (\cdLevel %d\c-): \cn%d\n", CurrentSkill->Name, CurrentSkill->CurrentLevel, EPCost);
            Log("\cdDEBUG: \c-Data Category/Index: \cd%d\c-, \cd%d\n", DataCategory, DataIndex);
            Log("\cdDEBUG: \c-Skill Data passed: \cd%d\n", *(int *)Data);
        };
        
        // Use Skill
        Success = CurrentSkill->Use(CurrentSkill, Data);
        
        // Check if the skill use was successful
        if (Success)
            Player.EP -= EPCost;
    }
    else // Not enough EP
    {
        SetFont("BIGFONT");
        HudMessage("Not enough EP to use this skill!\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("skills/fail", 127);
    };
};

acscript bool Heal(Skill *Self, void *Data)
{
    int HealAmount;
    
    // Calculate healing amount based on level
    switch (Self->CurrentLevel)
    {
        case 1: HealAmount = Player.HealthMax / 4;      break; // 25%
        case 2: HealAmount = Player.HealthMax / 2;      break; // 50%
        case 3: HealAmount = Player.HealthMax / 1.33;   break; // 75%
        case 4: HealAmount = Player.HealthMax;          break; // 100%
    };
    
    // Refund - If your health is max or above
    if (GetActorProperty(Player.TID, APROP_Health) >= GetActorProperty(Player.TID, APROP_SpawnHealth))
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    FadeRange(255, 0, 255, 0.5, 255, 0, 255, 0, 1.0);
    
    HealThing(HealAmount);
    ActivatorSound("skills/heal", 127);
    
    return true;
};

acscript bool HealSummons(Skill *Self, void *Data)
{
    // Refund - If you have no summoned monsters
    if (Player.Summons == 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    FadeRange(255, 0, 255, 0.5, 255, 0, 255, 0, 1.0);
    
    for (int i = 0; i < MAX_SUMMONS; i++)
        if (Player.SummonTID[i] > 0)
        {
            int Health = CalculateMonsterMaxHealth(Player.SummonTID[i]);
            SetActorProperty(Player.SummonTID[i], APROP_Health, Health);
        };
    
    ActivatorSound("skills/heal2", 127);
    
    return true;
};

acscript bool HealTeam(Skill *Self, void *Data)
{
    int PlayerTID = Player.TID;
    int HealAmount;
    
    // Calculate healing amount based on level
    switch (Self->CurrentLevel)
    {
        case 1: HealAmount = Player.HealthMax / 4;      break; // 25%
        case 2: HealAmount = Player.HealthMax / 2;      break; // 50%
        case 3: HealAmount = Player.HealthMax / 1.33;   break; // 75%
        case 4: HealAmount = Player.HealthMax;          break; // 100%
    };
    
    for (int i = 0; i < MAX_PLAYERS; i++)
        if (PlayerInGame(i))
        {
            // Calculate this player's max HP
            switch (Self->CurrentLevel)
            {
                case 1: HealAmount = Players(i).HealthMax / 4;      break; // 25%
                case 2: HealAmount = Players(i).HealthMax / 2;      break; // 50%
                case 3: HealAmount = Players(i).HealthMax / 1.33;   break; // 75%
                case 4: HealAmount = Players(i).HealthMax;          break; // 100%
            };
            
            SetActivator(Players(i).TID);
            FadeRange(255, 0, 255, 0.25, 255, 0, 255, 0, 1.0);
            HealThing(HealAmount);
            ActivatorSound("skills/heal", 127);
        };
     
    SetActivator(PlayerTID);
    
    return true;
};

acscript bool LifeLeech(Skill *Self, void *Data)
{
    int PlayerNum = PlayerNumber();
    
    SetActivatorToTarget(Players(PlayerNum).TID);
    
    // Refund - If the Player has no target
    if (ActivatorTID() == Players(PlayerNum).TID)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Refund - If the target isn't actually a valid monster
    if (!CheckInventory("DRPGMonsterInit"))
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    int LeechAmount = Round((fixed)GetActorProperty(0, APROP_Health) * ((fixed)Self->CurrentLevel / 10.0));
    
    // Refund -- If you leech 0 HP
    if (LeechAmount == 0)
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    DamageThing(LeechAmount);
    SetActivator(Players(PlayerNum).TID);
    HealThing(LeechAmount);
    
    FadeRange(255, 0, 255, 0.25, 255, 0, 255, 0, 1.0);
    ActivatorSound("skills/lifeleech", 127);
    return true;
};

acscript bool Decontaminate(Skill *Self, void *Data)
{
    if (Player.Toxicity <= 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    Player.Toxicity -= (25 * Self->CurrentLevel);
    Player.ToxicTimer = 0;
    Player.ToxicOffset = 0;
    Player.ToxicStage = 0;
    
    ActivatorSound("skills/decontaminate", 127);
    FadeRange(0, 255, 0, 0.5, 0, 255, 0, 0.0, 1.0 + (0.25 * Self->CurrentLevel));
    
    return true;
};

acscript bool Repair(Skill *Self, void *Data)
{
    int RepairAmount;
    
    // Calculate repair amount based on level
    switch (Self->CurrentLevel)
    {
        case 1: RepairAmount = Player.ArmorMax / 4;     break; // 25%
        case 2: RepairAmount = Player.ArmorMax / 2;     break; // 50%
        case 3: RepairAmount = Player.ArmorMax / 1.33;  break; // 75%
        case 4: RepairAmount = Player.ArmorMax;         break; // 100%
    };

    if (CheckInventory("Armor") > 0 && CheckInventory("Armor") < Player.ArmorMax)
    {
        FadeRange(0, 255, 0, 0.5, 0, 255, 0, 0, 1.0);
        GiveInventory("DRPGArmorBonus", RepairAmount);
        
        if (CheckInventory("Armor") > Player.ArmorMax)
        {
            int ArmorOverflow = CheckInventory("BasicArmor") - Player.ArmorMax;
            TakeInventory("BasicArmor", ArmorOverflow);
        };
        
        ActivatorSound("skills/repair", 127);
        return true;
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    return false;
};

acscript bool PlayerTeleport(Skill *Self, void *Data)
{
    str[MAX_PLAYERS] Names;
    int PlayerChoice;
    
    // Refund - If there is only one player or you aren't in multiplayer
    if (PlayerCount() <= 1 || !InMultiplayer)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };

    while (true)
    {
        fixed X = 48.1;
        fixed Y = 50.0;
        int Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
        int OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
        
        // Prevent the menus from being opened
        Player.InMenu = false;
        Player.InShop = false;
        
        SetPlayerProperty(false, 1, PROP_TOTALLYFROZEN);
        
        // Set the HUD Size
        SetHudSize(GetCVar("drpg_menu_width"), GetCVar("drpg_menu_height"), true);
        
        // Title
        SetFont("BIGFONT");
        HudMessage("Choose a Player\n", HUDMSG_PLAIN, 0, CR_GREEN, 24.1, 24.0, 0.05);
        
        // Input
        if (Buttons == BT_FORWARD && OldButtons != BT_FORWARD)
        {
            ActivatorSound("menu/move", 127);
            PlayerChoice--;
            if (PlayerChoice < 0) PlayerChoice = PlayerCount() - 1;
        };
        if (Buttons == BT_BACK && OldButtons != BT_BACK)
        {
            ActivatorSound("menu/move", 127);
            PlayerChoice++;
            if (PlayerChoice > PlayerCount() - 1) PlayerChoice = 0;
        };
        if (Buttons == BT_USE && OldButtons != BT_USE)
        {
            // You can't teleport to yourself
            if (PlayerChoice == PlayerNumber())
                ActivatorSound("menu/error", 127)
            else
            {
                // Teleport
                SetPlayerProperty(false, 0, PROP_TOTALLYFROZEN);
                GiveInventory("DRPGPlayerTeleportGhost", 1);
                SetActorPosition(Player.TID, GetActorX(Players(PlayerChoice).TID), GetActorY(Players(PlayerChoice).TID), GetActorZ(Players(PlayerChoice).TID), true);
                SetActorAngle(Player.TID, GetActorAngle(Players(PlayerChoice).TID));
                
                // Make sure you're not inside the other player before we solidify
                while (Distance(Player.TID, Players(PlayerChoice).TID) <= GetActorPropertyFixed(Players(PlayerChoice).TID, APROP_Radius))
                    Delay(35);
                
                // Solidify
                GiveInventory("DRPGPlayerTeleportNormal", 1);
                return true;
            };
        };
        if (Buttons == BT_SPEED && OldButtons != BT_SPEED)
        {
            SetPlayerProperty(false, 0, PROP_TOTALLYFROZEN);
            ActivatorSound("menu/move", 127);
            return false;
        };
        
        // Drawing
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            // Skip over players that aren't in the game
            if (!PlayerInGame(i))
            {
                // If you are highlighting someone who left, reset the cursor
                if (PlayerChoice == i)
                    PlayerChoice = 0;
                
                continue;
            };
            
            // Get Player Names
            for (int i = 0; i < MAX_PLAYERS; i++)
                Names[i] = StrParam("%N\n", i + 1);
            
            // Cursor
            if (i == PlayerChoice)
                HudMessage("-->\n", HUDMSG_PLAIN, 0, MenuCursorColor, X - 24.0, Y, 0.05);
            
            // Bonus String
            if (i == PlayerNumber())
                HudMessage("%s\n", Names[i], HUDMSG_PLAIN, 0, CR_GREEN, X, Y, 0.05)
            else
                HudMessage("%s (%k)\n", Names[i], Distance(Player.TID, Players(i).TID), HUDMSG_PLAIN, 0, CR_WHITE, X, Y, 0.05);
            
            // Move down Y
            Y += 16.0;
        };
        
        Delay(1);
    };
};

acscript bool Powerup(Skill *Self, void *Data)
{
    int Index = *(int *)Data;
    
    switch (Index)
    {
        case 0: // Invulnerability
            if (CheckInventory("PowerInvulnerable"))
            {
                ActivatorSound("menu/error", 127);
                return false;
            };
            ActivatorSound("powerups/protect", 127);
            GiveInventory(StrParam("DRPGSkillInvulnerability%d\n", Self->CurrentLevel), 1);
            break;
        case 1: // Invisibility
            if (CheckInventory("PowerShadow"))
            {
                ActivatorSound("menu/error", 127);
                return false;
            };
            ActivatorSound("powerups/invis", 127);
            GiveInventory(StrParam("DRPGSkillInvisibility%d\n", Self->CurrentLevel), 1);
            break;
        case 3: // Iron Feet
            if (CheckInventory("PowerIronFeet"))
            {
                ActivatorSound("menu/error", 127);
                return false;
            };
            ActivatorSound("powerups/suit", 127);
            GiveInventory("PowerIronFeet", 1);
            break;
        case 4: // Night Vision
            if (CheckInventory("PowerLightAmp"))
            {
                ActivatorSound("menu/error", 127);
                return false;
            };
            ActivatorSound("powerups/light", 127);
            GiveInventory("PowerLightAmp", 1);
            break;
        case 5: // Berserk
            ActivatorSound("powerups/berserk", 127);
            GiveInventory("PowerStrength", 1);
            break;
        case 6: // Mind Mapping
            ActivatorSound("powerups/map", 127);
            GiveInventory("DRPGAllMapRevealer", 1);
            GiveInventory("DRPGAllMapScanner", 1);
            break;
    };
    
    return true;
};

acscript bool BulletTime(Skill *Self, void *Data)
{
    
    if (Self->CurrentLevel == 1) // Stutter Time
    {
        BulletTimeTimer = 350;
        SpawnForced("DRPGTimeFreezerQuickSound", GetActorX(0), GetActorY(0), GetActorZ(0), 0, 0);
        TakeInventory("PowerTimeFreezer", 1);
        GiveInventory("DRPGTimeFreezerQuick", 1);
    };
    if (Self->CurrentLevel == 2) // Freeze Time
    {
        SpawnForced("DRPGTimeFreezerSound", GetActorX(0), GetActorY(0), GetActorZ(0), 0, 0);
        GiveInventory("DRPGTimeFreezer", 1);
    };
    
    return true;
};

acscript bool DropWeapon(Skill *Self, void *Data)
{
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0) + Cos(Angle) * 96.0;
    fixed Y = GetActorY(0) + Sin(Angle) * 96.0;
    fixed Z = GetActorZ(0) + 48.0;
    str Weapon;
    
    switch (Self->CurrentLevel)
    {
        case 1: Weapon = "Pistol";          break;
        case 2: Weapon = "Shotgun";         break;
        case 3: Weapon = "SuperShotgun";    break;
        case 4: Weapon = "Chaingun";        break;
        case 5: Weapon = "RocketLauncher";  break;
        case 6: Weapon = "PlasmaRifle";     break;
        case 7: Weapon = "BFG9000";         break;
    };
    
    if (Spawn(Weapon, X, Y, Z, 0, Angle))
    {
        ActivatorSound("skills/drop", 127);
        Spawn("TeleportFog", X, Y, Z, 0, Angle);
        return true;
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    return false;
};

acscript bool DropAmmo(Skill *Self, void *Data)
{
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0) + Cos(Angle) * 96.0;
    fixed Y = GetActorY(0) + Sin(Angle) * 96.0;
    fixed Z = GetActorZ(0) + 48.0;
    str Ammo;
    
    switch (Self->CurrentLevel)
    {
        case 1:         Ammo = "DRPGSmallBackpack"; break;
        case 2:         Ammo = "DRPGBackpack";      break;
        case 3: case 4: Ammo = "DRPGBigBackpack";   break;
    };
    
    if (Spawn(Ammo, X, Y, Z, 0, Angle))
    {
        if (Self->CurrentLevel == 4 && GetCVar("drpg_ext_doomrl"))
            Spawn("RLSupplyCrate", X, Y, Z, 0, Angle);
        
        ActivatorSound("skills/drop", 127);
        Spawn("TeleportFog", X, Y, Z, 0, Angle);
        return true;
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };

    return false;
};

acscript bool UseAura(Skill *Self, void *Data)
{
    int Index = *(int *)Data;
    
    ActivatorSound("skills/buff", 127);
    
    if (Player.Perks[STAT_ENERGY])
        Player.AuraTimer += (1050 + Player.Energy * 5.25) * (Player.AuraBonus ? 2 : 1)
    else
    {
        bool Stack = false;
        
        // Is the Aura you used the same as the one you already have active?
        if (Player.Aura[Index])
            Stack = true;
        
        // Remove all other Auras first
        for (int i = 0; i < AURA_MAX; i++)
            Player.Aura[i] = false;
        
        // Should the timer be stacked because you used the same Aura?
        if (Stack)
            Player.AuraTimer += (1050 + Player.Energy * 5.25) * (Player.AuraBonus ? 2 : 1)
        else
            Player.AuraTimer = (1050 + Player.Energy * 5.25) * (Player.AuraBonus ? 2 : 1);
    };
    
    // Apply Aura
    Player.Aura[Index] = true;
    
    return true;
};

acscript bool Weaken(Skill *Self, void *Data)
{
    int PlayerNum = PlayerNumber();
    int MonsterLevel;
    int MonsterAura;
    int MonsterStrength;
    int MonsterDefense;
    
    SetActivatorToTarget(Players(PlayerNum).TID);
    
    // Refund - If the Player has no target
    if (ActivatorTID() == Players(PlayerNum).TID)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Refund - If the target isn't actually a valid monster
    if (!CheckInventory("DRPGMonsterInit"))
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    // Get Monster Stats
    MonsterLevel = CheckInventory("DRPGMonsterLevel") / 2;
    MonsterStrength = CheckInventory("DRPGMonsterStrength") / 2;
    MonsterDefense = CheckInventory("DRPGMonsterDefense") / 2;
    MonsterAura = CheckInventory("DRPGMonsterAura");
    
    // Destroy Aura
    if (Self->CurrentLevel == 2) 
    {
        if (GetActorProperty(0, APROP_Health) > GetActorProperty(0, APROP_SpawnHealth))
            SetActorProperty(0, APROP_Health, GetActorProperty(0, APROP_SpawnHealth));
        
        MonsterAura = 0;
    };
    
    // Apply the stats to the monster
    SetInventory("DRPGMonsterLevel", MonsterLevel);
    SetInventory("DRPGMonsterStrength", MonsterStrength);
    SetInventory("DRPGMonsterDefense", MonsterDefense);
    SetInventory("DRPGMonsterAura", MonsterAura);
    
    // Re-run the Stats Script
    MonsterStats(CheckInventory("DRPGMonsterFlags"), SF_PLAYERTARGET);
    
    // Reset Activator
    SetActivator(Players(PlayerNum).TID);
    
    FadeRange(0, 0, 0, 0.25, 0, 0, 0, 0.0, 1.0);
    ActivatorSound("skills/weaken", 127);
    return true;
};

acscript bool Translocate(Skill *Self, void *Data)
{
    FireProjectile("DRPGTranslocateBall");
    return true;
};

acscript bool Repulse(Skill *Self, void *Data)
{
    SetInventory(StrParam("DRPGSkillBlast%d\n", Self->CurrentLevel), 1);
    UseInventory(StrParam("DRPGSkillBlast%d\n", Self->CurrentLevel));
    
    FadeRange(255, 255, 0, 0.1, 255, 255, 0, 0.0, 0.5 + (0.25 * Self->CurrentLevel));
    
    return true;
};

acscript bool Summon(Skill *Self, void *Data)
{
    int Index = *(int *)Data;
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0) + Cos(Angle) * 96.0;
    fixed Y = GetActorY(0) + Sin(Angle) * 96.0;
    fixed Z = GetActorZ(0);
    int NewID = UniqueTID();
    bool Success;
    
    str[][] DRLASummons =
    {
        // Former Human
        {
            "RLDRPGSummonedFormerHuman";
            "RLDRPGSummonedEliteHuman";
            "RLDRPGSummonedFormerCaptain";
        };
        
        // Former Sergeant
        {
            "RLDRPGSummonedFormerSergeant";
            "RLDRPGSummonedEliteSergeant";
        };
        
        // Former Commando
        {
            "RLDRPGSummonedFormerCommando";
            "RLDRPGSummonedEliteCommando";
            "RLDRPGSummonedEliteCaptain2";
        };
        
        // Imp
        {
            "RLDRPGSummonedImp";
            "RLDRPGSummonedNightmareImp";
            "RLDRPGSummonedCyberneticImp";
        };
        
        // Demon
        {
            "RLDRPGSummonedDemon";
            "RLDRPGSummonedSpectre";
            "RLDRPGSummonedNightmareDemon";
            "RLDRPGSummonedNightmareSpectre";
            "RLDRPGSummonedCyberneticDemon";
            "RLDRPGSummonedCyberneticSpectre";
        };
        
        // Cacodemon
        {
            "RLDRPGSummonedCacodemon";
            "RLDRPGSummonedNightmareCacodemon";
        };
        
        // Hell Knight
        {
            "RLDRPGSummonedHellKnight";
            "RLDRPGSummonedNightmareHellKnight";
            "RLDRPGSummonedCyberneticHellKnight";
        };
        
        // Baron of Hell
        {
            "RLDRPGSummonedBaronOfHell";
            "RLDRPGSummonedNightmareBaronOfHell";
            "RLDRPGSummonedCyberneticBaronOfHell";
        };
        
        // Lost Soul
        {
            "RLDRPGSummonedLostSoul";
            "RLDRPGSummonedNightmareLostSoul";
            "RLDRPGSummonedCyberneticLostSoul";
        };
        
        // Pain Elemental
        {
            "RLDRPGSummonedPainElemental";
            "RLDRPGSummonedNightmarePainElemental";
        };
        
        // Revenant
        {
            "RLDRPGSummonedRevenant";
            "RLDRPGSummonedNightmareRevenant";
            "RLDRPGSummonedCyberneticRevenant";
        };
        
        // Mancubus
        {
            "RLDRPGSummonedMancubus";
            "RLDRPGSummonedNightmareMancubus";
            "RLDRPGSummonedCyberneticMancubus";
        };
        
        // Arachnotron
        {
            "RLDRPGSummonedArachnotron";
            "RLDRPGSummonedNightmareArachnotron";
            "RLDRPGSummonedCyberneticArachnotron";
        };
        
        // Arch-Vile
        {
            "RLDRPGSummonedArchVile";
            "RLDRPGSummonedNightmareArchVile";
        };
        
        // Cyberdemon
        {
            "RLDRPGSummonedCyberdemon";
            "RLDRPGSummonedNightmareCyberdemon";
        };
        
        // Spider Mastermind
        {
            "RLDRPGSummonedSpiderMastermind";
            "RLDRPGSummonedCyberneticSpiderMastermind";
        };
    };
    
    // Stop if you already have the maximum amount of summons
    if (Player.Summons >= MAX_SUMMONS)
    {
        SetFont("BIGFONT");
        HudMessage("You cannot summon any more friendlies\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    if (Index == 0) // Marines
    {
        switch (Self->CurrentLevel)
        {
            case 1: Success = Spawn("MarinePistolRPG", X, Y, Z, NewID, Angle);                  break;
            case 2: Success = Spawn("MarineShotgunRPG", X, Y, Z, NewID, Angle);                 break;
            case 3: Success = Spawn("MarineSSGRPG", X, Y, Z, NewID, Angle);                     break;
            case 4: Success = Spawn("MarineChaingunRPG", X, Y, Z, NewID, Angle);;               break;
            case 5: Success = Spawn("MarineRocketRPG", X, Y, Z, NewID, Angle);                  break;
            case 6: Success = Spawn("MarinePlasmaRPG", X, Y, Z, NewID, Angle);                  break;
            case 7: Success = Spawn("MarineRailgunRPG", X, Y, Z, NewID, Angle);                 break;
            case 8: Success = Spawn("MarineBFGRPG", X, Y, Z, NewID, Angle);                     break;
        };
    }
    else // Monsters
    {
        if (GetCVar("drpg_ext_doomrl"))
            Success = Spawn(DRLASummons[Index - 1][Self->CurrentLevel - 1], X, Y, Z, NewID, Angle)
        else
        {
            switch (Index)
            {
                case 2:     Success = Spawn("Zombieman", X, Y, Z, NewID, Angle);                break;
                case 3:     Success = Spawn("ShotgunGuy", X, Y, Z, NewID, Angle);               break;
                case 4:     Success = Spawn("ChaingunGuy", X, Y, Z, NewID, Angle);              break;
                case 5:     Success = Spawn("DoomImp", X, Y, Z, NewID, Angle);                  break;
                case 6:     Success = Spawn("Demon", X, Y, Z, NewID, Angle);                    break;
                case 7:     Success = Spawn("Cacodemon", X, Y, Z, NewID, Angle);                break;
                case 8:     Success = Spawn("HellKnight", X, Y, Z, NewID, Angle);               break;
                case 9:     Success = Spawn("BaronOfHell", X, Y, Z, NewID, Angle);              break;
                case 10:    Success = Spawn("LostSoul", X, Y, Z, NewID, Angle);                 break;
                case 11:    Success = Spawn("PainElemental", X, Y, Z, NewID, Angle);            break;
                case 12:    Success = Spawn("Revenant", X, Y, Z, NewID, Angle);                 break;
                case 13:    Success = Spawn("Fatso", X, Y, Z, NewID, Angle);                    break;
                case 14:    Success = Spawn("Arachnotron", X, Y, Z, NewID, Angle);              break;
                case 15:    Success = Spawn("Archvile", X, Y, Z, NewID, Angle);                 break;
                case 16:    Success = Spawn("Cyberdemon", X, Y, Z, NewID, Angle);               break;
                case 17:    Success = Spawn("SpiderMastermind", X, Y, Z, NewID, Angle);         break;
            };
        };
    };
    
    if (Success)
    {
        SpawnForced("TeleportFog", X, Y, Z, 0, Angle);
        SetActorAngle(NewID, Angle);
        SetActorProperty(NewID, APROP_Friendly, 1);
        GiveActorInventory(NewID, "DRPGFriendlyBooster", 1);
        
        // Add summon to your summon array
        for (int i = 0; i < MAX_SUMMONS; i++)
            if (Player.SummonTID[i] == 0)
            {
                Player.SummonTID[i] = NewID;
                Player.Summons++;
                return true;
            };
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
};

acscript bool BreakdownArmor(Skill *Self, void *Data)
{
    int Armor = CheckInventory("BasicArmor");
    
    // Kind of hackish to prevent breaking down Armors that use high values for indestructibleness
    if (Armor > 1000)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    if (Armor > 0)
    {
        TakeInventory("BasicArmor", Armor);
        GiveInventory("DRPGCredits", Armor);
        
        // DoomRL Compatibility
        if (GetCVar("drpg_ext_doomrl"))
        {
            TakeInventory("RL100ArmorWorn", 1);
            TakeInventory("RL150ArmorWorn", 1);
            TakeInventory("RL200ArmorWorn", 1);
            TakeInventory("RL100RegenArmorWorn", 1);
            TakeInventory("RLIndestructibleArmorWorn", 1);
        };
        
        ActivatorSound("skills/breakdown", 127);
        return true;
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    return false;
};

acscript bool ForceWall(Skill *Self, void *Data)
{
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0) + Cos(Angle) * 96.0;
    fixed Y = GetActorY(0) + Sin(Angle) * 96.0;
    fixed Z = GetActorZ(0);
    
    Thing_Remove(1998);
    
    switch (Self->CurrentLevel)
    {
        case 1:
            if (!Spawn("DRPGForceField", X, Y, Z, 1998, Angle) == 0) {return true;}
            else
            {
                ActivatorSound("menu/error", 127);
                return false;
            };
            break;
        case 2:
            if (!Spawn("DRPGForceField2", X, Y, Z, 1998, Angle) == 0) {return true;}
            else
            {
                ActivatorSound("menu/error", 127);
                return false;
            };
            break;
    };

    return false;
};

acscript bool Rally(Skill *Self, void *Data)
{
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0);
    fixed Angle = GetActorAngle(0);
    
    // Fail if you have no summons active
    if (Player.Summons == 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    SpawnForced("TeleportFog", X, Y, Z, 0, Angle);
    
    for (int i = 0; i < MAX_SUMMONS; i++)
        if (Player.SummonTID[i] > 0)
            SetActorPosition(Player.SummonTID[i], X, Y, Z, 0);
    
    ActivatorSound("skills/rally", 127);
    return true;
};

acscript bool Unsummon(Skill *Self, void *Data)
{
    int EPAdd;
    
    // Fail if you have no summons active
    if (Player.Summons == 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    for (int i = 0; i < MAX_SUMMONS; i++)
    {
        // Continue if there's no summon in this slot
        if (Player.SummonTID[i] == 0) continue;
        
        if (Self->CurrentLevel == 2 && GetActorProperty(i, APROP_Health) > 0)
            EPAdd += 25;
        
        // Overdrive - Remove summons (teleport out) instead of killing them
        if (GetActorProperty(Player.SummonTID[i], APROP_Health) > 0)
        {
            SpawnForced("TeleportFog", GetActorX(Player.SummonTID[i]), GetActorY(Player.SummonTID[i]), GetActorZ(Player.SummonTID[i]), 0, 0);
            Thing_Remove(Player.SummonTID[i]);
        };
        
        // Remove the summon from the array
        Player.SummonTID[i] = 0;
    };
    
    
    if (Self->CurrentLevel == 2)
        Player.EP += EPAdd;

    Player.Summons = 0;
    
    FadeRange(192, 0, 0, 0.5, 192, 0, 0, 0.0, 1.0);
    ActivatorSound("skills/unsummon", 127);
    return true;
};

acscript bool Recall(Skill *Self, void *Data)
{
    // Fail if you're in the Arena or Marines are hostile
    if (ArenaActive || MarinesHostile)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
        
    SetInventory("ArtiTeleport", 1);
    UseInventory("ArtiTeleport");
    return true;
};

acscript bool WirelessLocker(Skill *Self, void *Data)
{
    Locker(true, Self->CurrentLevel);
    return true;
};

acscript bool Transport(Skill *Self, void *Data)
{
    // If you're dead, terminate
    if (GetActorProperty(Player.TID, APROP_Health) <= 0) return false;
    
    // Don't allow Transport while the arena is active, if the Marines are hostile, or you're in an Outpost-related menu
    if (ArenaActive || MarinesHostile || Player.OutpostMenu > 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Multiplayer
    if (InMultiplayer && PlayerCount() > 1)
    {
        int Players = PlayerCount();
        bool Ready;
        bool[MAX_PLAYERS] Voted;
        int PlayersApprove;
        int PlayersDeny;
        
        for (int i = 0; i < MAX_PLAYERS; i++)
            Voted[i] = false;
        
        while (!Ready)
        {
            // Freeze all players
            SetPlayerProperty(true, 1, PROP_TOTALLYFROZEN);
            
            // Input
            for (int i = 0; i < Players; i++)
            {
                // Skip input checks if you've already voted
                if (Voted[i]) continue;
                
                int Buttons = GetPlayerInput(i, INPUT_BUTTONS);
                int OldButtons = GetPlayerInput(i, INPUT_OLDBUTTONS);
                
                if (Buttons == BT_USE && OldButtons != BT_USE)
                {
                    ActivatorSound("menu/move", 127);
                    PlayersApprove++;
                    Voted[i] = true;
                };
                if (Buttons == BT_SPEED && OldButtons != BT_SPEED)
                {
                    ActivatorSound("menu/move", 127);
                    PlayersDeny++;
                    Voted[i] = true;
                };
            };
            
            // Check that everyone has voted
            Ready = true;
            for (int i = 0; i < Players; i++)
                if (!Voted[i]) Ready = false;
            
            // Drawing
            SetFont("BIGFONT");
            HudMessageBold("\cd%N has requested Transport\n\c-Players: %d (\cd%d\c-/\cg%d\c-)\n\n\cd%K\c- to Approve\n\cd%K\c- to Deny\n",
                           PlayerNumber() + 1, Players, PlayersApprove, PlayersDeny, "+use", "+speed",
                           HUDMSG_FADEOUT, MENU_ID, CR_WHITE, 0.5, 0.75, 1.0, 4.0);
            
            Delay(1);
        };
        
        // Ready - tally votes and confirm/deny Transport
        if (Ready)
        {
            SetPlayerProperty(true, 0, PROP_TOTALLYFROZEN);
            
            // Approved
            if (PlayersApprove > PlayersDeny)
            {
                for (int i = 0; i < MAX_PLAYERS; i++)
                    SetActorProperty(Players(i).TID, APROP_Invulnerable, true);
                HudMessageBold("\cdTransport Approved!\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.5, 1.0, 4.0);
                Delay(35 * 2);
                FadeRange(255, 255, 255, 0.0, 255, 255, 255, 1.0, 3.0);
                Delay(35 * 3);
            };
            
            // Denied
            if (PlayersDeny > PlayersApprove)
            {
                HudMessageBold("\cgTransport Denied!\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.5, 1.0, 2.0);
                return false;
            };
            
            // Draw
            if (PlayersApprove == PlayersDeny)
            {
                HudMessageBold("\cjDraw!\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.5, 1.0, 2.0);
                return false;
            };
        };
    }
    else // Single Player
    {
        // Fade Screen
        FadeRange(255, 255, 255, 0.0, 255, 255, 255, 1.0, 1.0);
        
        // Freeze Player
        SetActorProperty(0, APROP_Invulnerable, true);
        SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
        
        // Delay and unfreeze Player
        Delay(35);
        SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
        SetActorProperty(0, APROP_Invulnerable, false);
    };
    
    // Transport
    if (!InBase)
    {
        str LevelLump = StrParam("%N\n", PRINTNAME_LEVEL);
        for (int i = 0; i < 8 && i < StrLen(LevelLump); i++)
            LastVisited[i] = LevelLump[i];
        
        ChangeLevel("OUTPOST", 0, CHANGELEVEL_NOINTERMISSION, -1);
        InBase = true;
        Transported = true;
        return true;
    }
    else
    {
        ChangeLevel(StrParam("%s\n", LastVisited), 0, CHANGELEVEL_NOINTERMISSION, -1);
        InBase = false;
        Transported = true;
        return true;
    };
};

acscript void RemoveAura()
{
    for (int i = 0; i < AURA_MAX; i++)
        Player.Aura[i] = false;
    
    Player.AuraTimer = 0;
};

function int ScaleEPCost(int Cost)
{
    if (!GetCVar("drpg_skill_costscale")) return Cost;

    switch (GameSkill())
    {
        case 1: Cost = Cost / 2;        break;  // 0.5x
        case 2: Cost = Cost;            break;  // 1.0x
        case 3: Cost = Cost * 3 / 2;    break;  // 1.5x
        case 4: Cost = Cost * 2;        break;  // 2.0x
        case 5: Cost = Cost * 5 / 2;    break;  // 2.5x
        case 6: Cost = Cost * 3;        break;  // 3x
    };
    
    return Cost;
};

function void CheckSkills()
{
    // Aura-related vars to save typing :P
    int RedAuraLevel = Skills[2][0].CurrentLevel;
    int GreenAuraLevel = Skills[2][1].CurrentLevel;
    int WhiteAuraLevel = Skills[2][2].CurrentLevel;
    int PinkAuraLevel = Skills[2][3].CurrentLevel;
    int BlueAuraLevel = Skills[2][4].CurrentLevel;
    int PurpleAuraLevel = Skills[2][5].CurrentLevel;
    int OrangeAuraLevel = Skills[2][6].CurrentLevel;
    int DarkBlueAuraLevel = Skills[2][7].CurrentLevel;
    int YellowAuraLevel = Skills[2][8].CurrentLevel;
    fixed LuckMult = 1;
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0);
    int Angle = GetActorAngle(0) * 256;
    int AmmoRegenMult = 1;
    
    // Reset the Skill multiplier from the Blue Aura and Energy Augmentation
    Player.SkillCostMult = 1.0;
    
    // Level 4 and 5 of the Energy Augmentation reduce skill costs by 25% and 50%
    if (Player.Augs.Active[AUG_ENERGY])
        if (Player.Augs.Level[AUG_ENERGY] == 4)
            Player.SkillCostMult = 0.75
        else if (Player.Augs.Level[AUG_ENERGY] >= 5)
            Player.SkillCostMult = 0.5;
            
    // Give the player the Aura item while an Aura is active (for SBARINFO hax)
    if (Player.AuraTimer > 0)
        GiveInventory("DRPGAura", 1)
    else
        TakeInventory("DRPGAura", 1);
    
    // Make the Player's Aura appear in their Health Bar
    if (InMultiplayer)
        for (int i = 0; i < AURA_MAX; i++)
            if (Player.Aura[i])
            {
                SetInventory("DRPGMonsterAura", i + 1);
                break;
            };
    
    // DoomRL Compatibility
    if (GetCVar("drpg_ext_doomrl"))
    {
        // Add an extra level to the Ammo Drop to drop Supply Crates
        Skills[1][8].MaxLevel = 4;
        Skills[1][8].Description[3] = "Drops a Large Backpack full of ammo at your location\nDrops a Supply Crate at your location";
        
        // DoomRL Marines use slightly different weapons (Whenever Yholl decides to do them :P)
        // Skills[4][0].Description[2] = "Summons a Marine to fight with you\n\cjDouble Shotgun";
        // Skills[4][0].Description[3] = "Summons a Marine to fight with you\n\cjBattle Rifle";
        
        // Summoning Skills - Names
        Skills[4][1].Name = "Summon Former Human";
        Skills[4][2].Name = "Summon Former Sergeant";
        Skills[4][3].Name = "Summon Former Commando";
        
        // Summoning Skills - Levels
        Skills[4][1].MaxLevel = 3;
        Skills[4][2].MaxLevel = 2;
        Skills[4][3].MaxLevel = 3;
        Skills[4][4].MaxLevel = 3;
        Skills[4][5].MaxLevel = 6;
        Skills[4][6].MaxLevel = 2;
        Skills[4][7].MaxLevel = 3;
        Skills[4][8].MaxLevel = 3;
        Skills[4][9].MaxLevel = 3;
        Skills[4][10].MaxLevel = 2;
        Skills[4][11].MaxLevel = 3;
        Skills[4][12].MaxLevel = 3;
        Skills[4][13].MaxLevel = 3;
        Skills[4][14].MaxLevel = 2;
        Skills[4][15].MaxLevel = 2;
        Skills[4][16].MaxLevel = 2;
        Skills[4][17].MaxLevel = 2;
        
        // Summoning Skills - Descriptions
        Skills[4][1].Description[0] = "Summons a Former Human to fight with you";
        Skills[4][1].Description[1] = "Summons an Elite Human to fight with you";
        Skills[4][1].Description[2] = "Summons a Former Human Captain to fight with you";
        Skills[4][2].Description[0] = "Summons a Former Sergeant to fight with you";
        Skills[4][2].Description[1] = "Summons an Elite Sergeant to fight with you";
        Skills[4][3].Description[0] = "Summons a Former Commando to fight with you";
        Skills[4][3].Description[1] = "Summons an Elite Commando to fight with you";
        Skills[4][3].Description[2] = "Summons an Elite Human Captain to fight with you";
        Skills[4][4].Description[1] = "Summons a Nightmare Imp to fight with you";
        Skills[4][4].Description[2] = "Summons a Cyber-Imp to fight with you";
        Skills[4][5].Description[1] = "Summons a Spectre to fight with you";
        Skills[4][5].Description[2] = "Summons a Nightmare Demon to fight with you";
        Skills[4][5].Description[3] = "Summons a Nightmare Spectre to fight with you";
        Skills[4][5].Description[4] = "Summons a Mech-Demon to fight with you";
        Skills[4][5].Description[5] = "Summons a Mechtre to fight with you";
        Skills[4][6].Description[1] = "Summons a Nightmare Cacodemon to fight with you";
        Skills[4][7].Description[1] = "Summons a Nightmare Knight to fight with you";
        Skills[4][7].Description[2] = "Summons a Cybruiser to fight with you";
        Skills[4][8].Description[1] = "Summons a Baron of Nightmares to fight with you";
        Skills[4][8].Description[2] = "Summons a Techno-Lord to fight with you";
        Skills[4][9].Description[1] = "Summons a Nightmare Soul to fight with you";
        Skills[4][9].Description[2] = "Summons a Hellmine to fight with you";
        Skills[4][10].Description[1] = "Summons a Nightmare Elemental to fight with you";
        Skills[4][11].Description[1] = "Summons a Nightmare Revenant to fight with you";
        Skills[4][11].Description[2] = "Summons a Heavy Revenant to fight with you";
        Skills[4][12].Description[1] = "Summons a Nightmare Mancubus to fight with you";
        Skills[4][12].Description[2] = "Summons a Volacubus to fight with you";
        Skills[4][13].Description[1] = "Summons a Nightmare Arachnotron to fight with you";
        Skills[4][13].Description[2] = "Summons a Arachnsentinel to fight with you";
        Skills[4][14].Description[1] = "Summons a Nightmare Arch-Vile to fight with you";
        Skills[4][15].Description[1] = "Summons a Nightmare Cyberdemon to fight with you";
        Skills[4][16].Description[1] = "Summons a Spider Overmind to fight with you";
    };
    
    // Aura handling
    if (Player.AuraTimer > 0)
    {
        // Red Aura
        if (Player.Aura[AURA_RED])
        {
            SpawnAura(0, AURA_RED + 1, false);
            if (RedAuraLevel == 1)
                GiveInventory("DRPGRedAura2x", 1);
            if (RedAuraLevel >= 2)
                GiveInventory("DRPGRedAura4x", 1);
            if (RedAuraLevel >= 3)
                GiveInventory("DRPGRedAuraInfiniteAmmo", 1);
        };
        
        // Green Aura
        if (Player.Aura[AURA_GREEN])
        {
            SpawnAura(0, AURA_GREEN + 1, false);
            if (GreenAuraLevel == 1)
                Player.DamageFactor = Player.DamageFactor - Player.DamageFactor * 0.25;
            if (GreenAuraLevel == 2)
                Player.DamageFactor = Player.DamageFactor - Player.DamageFactor * 0.5;
            if (GreenAuraLevel == 3)
            {
                Player.DamageFactor = Player.DamageFactor - Player.DamageFactor * 0.75;
                GiveInventory("DRPGGreenAuraIronFeet", 1);
            };
        };
        
        // White Aura
        if (Player.Aura[AURA_WHITE])
        {
            SpawnAura(0, AURA_WHITE + 1, false);
            if (WhiteAuraLevel >= 2)
            {
                if (Player.Combo == 0) Player.Combo++;
                Player.ComboTimer = COMBO_MAX - 1;
            };
            if (WhiteAuraLevel == 3)
                if ((Timer() % (35 * 4)) == 1)
                    Player.XPGained += XPTable[Player.Level] / 100 / (Player.Level + 1);
            if (WhiteAuraLevel >= 4)
                if ((Timer() % (35 * 2)) == 1)
                    Player.XPGained += XPTable[Player.Level] / 100 / (Player.Level + 1);
        };
        
        // Pink Aura
        if (Player.Aura[AURA_PINK])
        {
            SpawnAura(0, AURA_PINK + 1, false);
            if (PinkAuraLevel >= 1)
                GiveInventory("DRPGPinkAuraDrain", 1);
            if (PinkAuraLevel >= 2)
                Player.HealthMax *= 2;
        };
        
        // Blue Aura
        if (Player.Aura[AURA_BLUE])
        {
            SpawnAura(0, AURA_BLUE + 1, false);
            if (BlueAuraLevel == 1)
                Player.SkillCostMult /= 1.33;
            if (BlueAuraLevel == 2)
                Player.SkillCostMult /= 2;
            if (BlueAuraLevel == 3)
                Player.SkillCostMult /= 4;
        };
        
        // Purple Aura
        if (Player.Aura[AURA_PURPLE])
        {
            SpawnAura(0, AURA_PURPLE + 1, false);
            if (PurpleAuraLevel == 1)
            {
                Player.HPAmount *= 2;
                Player.EPAmount *= 2;
            };
            if (PurpleAuraLevel == 2)
            {
                Player.HPAmount *= 3;
                Player.EPAmount *= 3;
            };
            if (PurpleAuraLevel == 3)
            {
                Player.HPAmount *= 4;
                Player.EPAmount *= 4;
            };
            if (PurpleAuraLevel == 4)
            {
                Player.HPAmount *= 4;
                Player.EPAmount *= 4;
                Player.HPTime /= 2;
                Player.EPTime /= 2;
            };
        };
        
        // Orange Aura
        if (Player.Aura[AURA_ORANGE])
        {
            SpawnAura(0, AURA_ORANGE + 1, false);
            if (OrangeAuraLevel >= 1)
                Player.Speed *= 2;
            if (OrangeAuraLevel >= 2)
                Player.JumpHeight *= 2;
            if (OrangeAuraLevel >= 3)
                Player.WeaponSpeed = 100;
        };

        // Dark Blue Aura
        if (Player.Aura[AURA_DARKBLUE])
        {
            SpawnAura(0, AURA_DARKBLUE + 1, false);
            if (DarkBlueAuraLevel == 5)
                AmmoRegenMult = 2;
            if (DarkBlueAuraLevel == 6)
                AmmoRegenMult = 4;
            if (DarkBlueAuraLevel >= 1)
                if ((Timer() % (35 / 2)) == 1)
                    GiveInventory("Clip", AmmoRegenMult);
            if (DarkBlueAuraLevel >= 2)
                if ((Timer() % 35) == 1)
                    GiveInventory("Shell", AmmoRegenMult);
            if (DarkBlueAuraLevel >= 3)
                if ((Timer() % (35 * 2)) == 1)
                    GiveInventory("RocketAmmo", AmmoRegenMult);
            if (DarkBlueAuraLevel >= 4)
                if ((Timer() % (35 / 2)) == 1)
                    GiveInventory("Cell", AmmoRegenMult);
        };
        
        // Yellow Aura
        if (Player.Aura[AURA_YELLOW])
        {
            SpawnAura(0, AURA_YELLOW + 1, false);
            if ((Timer() % (35 * (6 - YellowAuraLevel))) == 1)
                GiveInventory("DRPGCredits", (Player.RankLevel + 1));
            if (YellowAuraLevel == 1)
                LuckMult = 1.25;
            if (YellowAuraLevel == 2)
                LuckMult = 1.5;
            if (YellowAuraLevel == 3)
                LuckMult = 2;
            if (YellowAuraLevel == 4)
                LuckMult = 4;
            if (YellowAuraLevel == 5)
                LuckMult = 8;
            
            Player.CreditChance *= LuckMult;
            Player.HealthChance *= LuckMult;
            Player.EPChance *= LuckMult;
            Player.ArmorChance *= LuckMult;
            Player.PowerupChance *= LuckMult;
            Player.WeaponChance *= LuckMult;
            Player.TokenChance *= LuckMult;
            Player.AugChance *= LuckMult;
            Player.ShieldChance *= LuckMult;
            Player.StimChance *= LuckMult;
        };
    };
    
    // Decrease timer this tic and calculate HUD timer amount
    for (int i = 0; i < AURA_MAX; i++)
        if (Player.AuraTimer > 0 && Player.Aura[i])
            if (!CheckInventory("PowerTimeFreezer") && !CheckInventory("DRPGMenuFreezer"))
            {
                Player.AuraTimer--;
                break;
            };
    
    // Summoned Monsters Handling
    for (int i = 0; i < MAX_SUMMONS; i++)
        if (GetActorProperty(Player.SummonTID[i], APROP_Health) <= 0)
            Player.Summons--;
    
    // Force Wall Handling
    if (GetActorProperty(1998, APROP_Alpha) > 0)
    {
        fixed WallAngle = GetActorAngle(0);
        fixed WallX = GetActorX(0) + Cos(WallAngle) * 48;
        fixed WallY = GetActorY(0) + Sin(WallAngle) * 48;
        fixed WallZ = GetActorZ(0);
        
        SetActorPosition(1998, WallX, WallY, WallZ, false);
        SetActorAngle(1998, WallAngle);
    };
    
    // Bullet-Time timer handling
    if (BulletTimeTimer > 0)
    {
        if (BulletTimeTimer % 3)
            GiveInventory("DRPGTimeFreezerQuick", 1);
        
        BulletTimeTimer--;
    };
};
