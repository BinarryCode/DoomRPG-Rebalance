#include "RPG.dh"

#include "Arena.dh"
#include "Map.dh"
#include "Menu.dh"
#include "Monsters.dh"
#include "Outpost.dh"
#include "Shield.dh"
#include "Shop.dh"
#include "Skills.dh"
#include "Stats.dh"
#include "Utils.dh"

bool Overdrive;
int BulletTimeTimer;

int[MAX_CATEGORIES] SkillCategoryMax =
{
    4; 9; 9; 5; 17; 7;
};

AddressSpace MapArray SkillSpace;
SkillSpace Skill[MAX_CATEGORIES][MAX_SKILLS] SkillData =
{
    // Healing/Support
    {
        {
            "Heal"; 75; 4; Heal;
            {
                "Recover all of your health";
                "Recover all of your health\nHeals Status Effects";
                "Recover all of your health\nHeals Status Effects\n\caAlso Effects Teammates";
                "Recover to 200% of your maximum health\n\cgSlowly drains back down to 100% maximum health\nHeals Status Effects\n\caAlso Affects Teammates";
            };
        };
        {
            "Heal Summons"; 100; 1; HealSummons;
            {
                "Summons recover all of their health";
            };
        };
        {
            "Decontamination"; 300; 1; Decontaminate;
            {
                "Remove all of your Toxicity";
            };
        };
        {
            "Repair Armor"; 200; 1; Repair;
            {
                "Repair your currently worn armor";
            };
        };
    };
    
    // Powerups
    {
        {
            "Invulnerability"; 250; 2; Powerup;
            {
                "Invulnerability to all attacks\n\cd(30 Sec)";
                "Invulnerability to all attacks\nProjectiles are reflected back at enemies\n\cd(30 Sec)";
            };
        };
        {
            "Invisibility"; 100; 2; Powerup;
            {
                "Makes you invisible to enemies\n\cd(30 sec)";
                "Makes you invisible to enemies\nSome projectiles pass through you\n\cd(30 sec)";
            };
        };
        {
            "Time Freeze"; 200; 2; BulletTime;
            {
                "Stutter Time";
                "Freeze Time";
            };
        };
        {
            "Iron Feet"; 100; 1; Powerup;
            {
                "Protection from Damage Floors";
            };
        };
        {
            "Night Vision"; 200; 1; Powerup;
            {
                "Allows you to see in the dark";
            };
        };
        {
            "Berserk"; 200; 1; Powerup;
            {
                "Full Health\nIncreased Melee Damage";
            };
        };
        {
            "Mental Mapping"; 200; 1; Powerup;
            {
                "Full Map\nItem/Enemy Tracking";
            };
        };
        {
            "Weapon Drop"; 100; 7; DropWeapon;
            {
                "Drops a Weapon at your location\n\cjPistol";
                "Drops a Weapon at your location\n\cjShotgun";
                "Drops a Weapon at your location\n\cjSuper Shotgun";
                "Drops a Weapon at your location\n\cjChaingun";
                "Drops a Weapon at your location\n\cjRocket Launcher";
                "Drops a Weapon at your location\n\cjPlasma Rifle";
                "Drops a Weapon at your location\n\cjBFG9000";
            };
        };
        {
            "Ammo Drop"; 100; 3; DropAmmo;
            {
                "Drops a Small Backpack full of ammo at your location";
                "Drops a Backpack full of ammo at your location";
                "Drops a Large Backpack full of ammo at your location";
            };
        };
    };
    
    // Auras
    {
        {
            "Red Aura"; 100; 6; UseAura;
            {
                "1.25x Damage";
                "1.5x Damage";
                "1.75x Damage";
                "2x Damage";
                "3x Damage";
                "4x Damage";
            };
        };
        {
            "Green Aura"; 100; 5; UseAura;
            {
                "+5% Damage Reduction";
                "+10% Damage Reduction";
                "+15% Damage Reduction\nDamage Floor Protection";
                "+20% Damage Reduction\nDamage Floor Protection";
                "+25% Damage Reduction\nDamage Floor Protection";
            };
        };
        {
            "White Aura"; 100; 5; UseAura;
            {
                "Double Combo";
                "Double Combo\nConstant Combo";
                "Double Combo\nConstant Combo\n2x XP Per Kill";
                "Double Combo\nConstant Combo\n2x XP Per Kill\nSlow XP Gain";
                "Double Combo\nConstant Combo\n2x XP Per Kill\nFast XP Gain";
            };
        };
        {
            "Pink Aura"; 100; 2; UseAura;
            {
                "Immune to Status Effects";
                "Immune to Status Effects\nDrain Enemy HP";
            };
        };
        {
            "Blue Aura"; 100; 3; UseAura;
            {
                "25% Skill Cost Reduction";
                "50% Skill Cost Reduction";
                "75% Skill Cost Reduction";
            };
        };
        {
            "Purple Aura"; 100; 4; UseAura;
            {
                "2x HP/EP Regen Amount";
                "3x HP/EP Regen Amount";
                "4x HP/EP Regen Amount";
                "4x HP/EP Regen Amount\n-2x HP/EP Regen Timers";
            };
        };
        {
            "Orange Aura"; 100; 3; UseAura;
            {
                "Double Movement Speed";
                "Double Movement Speed\nDouble Jump Height";
                "Double Movement Speed\nDouble Jump Height\nDouble Firing Speed";
            };
        };
        {
            "Dark Blue Aura"; 100; 7; UseAura;
            {
                "Clip Regen";
                "Clip Regen\nShell Regen";
                "Clip Regen\nShell Regen\nRocket Regen";
                "Clip Regen\nShell Regen\nRocket Regen\nCell Regen";
                "Clip Regen\nShell Regen\nRocket Regen\nCell Regen\n2x Regen Speed";
                "Clip Regen\nShell Regen\nRocket Regen\nCell Regen\n4x Regen Speed";
                "Clip Regen\nShell Regen\nRocket Regen\nCell Regen\n4x Regen Speed\nInfinite Ammo";
            };
        };
        {
            "Yellow Aura"; 100; 5; UseAura;
            {
                "Slow Money Generation\n1.25x Drop Chances";
                "Medium Money Generation\n1.5x Drop Chances";
                "Fast Money Generation\n2x Drop Chances";
                "Very Fast Money Generation\n4x Drop Chances";
                "Mega Money Generation\n8x Drop Chances";
            };
        };
    };
    
    // Attacks
    {
        {
            "Weaken"; 200; 5; Weaken;
            {
                "Weakens an enemy\nReduces stats by 1/16th";
                "Weakens an enemy\nReduces stats by 1/8th";
                "Weakens an enemy\nReduces stats by 1/4th";
                "Weakens an enemy\nReduces stats by half";
                "Weakens an enemy\nReduces stats by half\nDestroys all active Auras";
            };
        };
        {
            "Translocate"; 50; 1; Translocate;
            {
                "Teleports a monster to a random location\nin the area";
            };
        };
        {
            "Repulsion"; 50; 4; Repulse;
            {
                "A small blast which slightly pushes enemies away";
                "A blast which pushes enemies away";
                "A large blast which greatly pushes enemies away";
                "A huge blast which launches enemies away";
            };
        };
        {
            "Aura Steal"; 500; 1; AuraSteal;
            {
                "Steals an enemies Auras, taking it from them and giving it to you\nTime based on their Energy";
            };
        };
        {
            "Soul Steal"; 100; 10; SoulSteal;
            {
                "Steal 10% of the target's maximum HP\nIf the enemy dies, they will drop their Soul";
                "Steal 20% of the target's maximum HP\nIf the enemy dies, they will drop their Soul";
                "Steal 30% of the target's maximum HP\nIf the enemy dies, they will drop their Soul";
                "Steal 40% of the target's maximum HP\nIf the enemy dies, they will drop their Soul";
                "Steal 50% of the target's maximum HP\nIf the enemy dies, they will drop their Soul";
                "Steal 60% of the target's maximum HP\nIf the enemy dies, they will drop their Soul";
                "Steal 70% of the target's maximum HP\nIf the enemy dies, they will drop their Soul";
                "Steal 80% of the target's maximum HP\nIf the enemy dies, they will drop their Soul";
                "Steal 90% of the target's maximum HP\nIf the enemy dies, they will drop their Soul";
                "Steal 100% of the target's maximum HP\nWhen the enemy dies, they will drop their Soul";
            };
        };
    };
    
    // Summons
    {
        {
            "Summon Marine"; 100; 7; Summon;
            {
                "Summons a Marine\n\cjPistol";
                "Summons a Marine\n\cjShotgun";
                "Summons a Marine\n\cjSuper Shotgun";
                "Summons a Marine\n\cjChaingun";
                "Summons a Marine\n\cjRocket Launcher";
                "Summons a Marine\n\cjPlasma Rifle";
                "Summons a Marine\n\cjBFG 9000";
            };
        };
        {
            "Summon Zombieman"; 25; 1; Summon;
            {
                "Summons a Zombieman";
            };
        };
        {
            "Summon Shotgun Guy"; 50; 1; Summon;
            {
                "Summons a Shotgun Guy";
            };
        };
        {
            "Summon Chaingun Guy"; 75; 1; Summon;
            {
                "Summons a Chaingun Guy";
            };
        };
        {
            "Summon Imp"; 75; 1; Summon;
            {
                "Summons a Imp";
            };
        };
        {
            "Summon Demon"; 75; 1; Summon;
            {
                "Summons a Demon";
            };
        };
        {
            "Summon Cacodemon"; 100; 1; Summon;
            {
                "Summons a Cacodemon";
            };
        };
        {
            "Summon Hell Knight"; 150; 1; Summon;
            {
                "Summons a Hell Knight";
            };
        };
        {
            "Summon Baron of Hell"; 200; 1; Summon;
            {
                "Summons a Baron of Hell";
            };
        };
        {
            "Summon Lost Soul"; 100; 1; Summon;
            {
                "Summons a Lost Soul";
            };
        };
        {
            "Summon Pain Elemental"; 500; 1; Summon;
            {
                "Summons a Pain Elemental";
            };
        };
        {
            "Summon Revenant"; 500; 1; Summon;
            {
                "Summons a Revenant";
            };
        };
        {
            "Summon Mancubus"; 500; 1; Summon;
            {
                "Summons a Mancubus";
            };
        };
        {
            "Summon Arachnotron"; 500; 1; Summon;
            {
                "Summons a Arachnotron";
            };
        };
        {
            "Summon Arch-Vile"; 750; 1; Summon;
            {
                "Summons a Arch-Vile";
            };
        };
        {
            "Summon Cyberdemon"; 1000; 1; Summon;
            {
                "Summons a Cyberdemon";
            };
        };
        {
            "Summon Spider Mastermind"; 1000; 1; Summon;
            {
                "Summons a Spider Mastermind";
            };
        };
    };
    
    // Utility
    {
        {
            "Breakdown Armor"; 250; 1; BreakdownArmor;
            {
                "Breaks down your current Armor into Credits";
            };
        };
        {
            "Force Wall"; 100; 1; ForceWall;
            {
                "Creates a wall of force in front of you which blocks hitscans, projectiles and monsters\nHealth is determined by your Energy";
            };
        };
        {
            "Rally"; 0; 1; Rally;
            {
                "Teleports your summoned monsters to you";
            };
        };
        {
            "Unsummon"; 0; 2; Unsummon;
            {
                "Banishes all of the friendly creatures under your control";
                "Banishes all of the friendly creatures under your control\nEach creature banished restores \cn1% EP";
            };
        };
        {
            "Recall"; 25; 1; Recall;
            {
                "Brings you to the beginning of the level";
            };
        };
        {
            "Magnetize"; 100; 1; Magnetize;
            {
                "Pulls dropped items to you";
            };
        };
        {
            "Transport"; 0; 1; Transport;
            {
                "Brings you to the UAC Outpost\nUse in Outpost to return to current level";
            };
        };
    };
};

// Skill Wheel
script void SkillWheel() enter
{
    Start:
    
    int Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
    int OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
    int Selected = -1;
    int LastSelected = -1;
    int Radius = 96;
    int CurrentRadius = 0;
    SkillPtr CurrentSkill;
    SkillLevelInfo *SkillLevel;
    
    // Open the wheel
    if (Buttons & BT_USER1 && !((Player.InMenu && Player.Menu != 3) || Player.InShop || Player.OutpostMenu > 0))
    {
        ActivatorSound("menu/click", 127);
        Player.SkillWheelOpen = true;
    };
    
    // Wheel Loop
    while (Player.SkillWheelOpen)
    {
        SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
        
        // Check Input
        Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
        OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
        
        // Check for release
        if (!(Buttons & BT_USER1) && !(Buttons & BT_SPEED))
        {
            if (Selected != -1)
            {
                if (Player.InMenu && Player.Menu == 3)
                {
                    Player.SkillCategory[Selected] = Player.SkillPage;
                    Player.SkillIndex[Selected] = Player.MenuIndex;
                }
                else
                    Player.SkillSelected = Selected;
            };
            
            SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
            CurrentRadius = Radius;
            Player.SkillWheelOpen = false;
        };
        
        // Selection
        fixed MouseX = -GetPlayerInputFixed(PlayerNumber(), INPUT_YAW) * 1.2;
        fixed MouseY = GetPlayerInputFixed(PlayerNumber(), INPUT_PITCH);
        if (CurrentRadius >= Radius)
        {
            if (Buttons == (BT_USER1 | BT_FORWARD) && Selected != 0)
                Selected = 0
            else if (Buttons == (BT_USER1 | BT_FORWARD | BT_MOVERIGHT) && Selected != 1)
            {
                Selected = 1;
                Delay(5);
            }
            else if (Buttons == (BT_USER1 | BT_MOVERIGHT) && Selected != 2)
                Selected = 2
            else if (Buttons == (BT_USER1 | BT_MOVERIGHT | BT_BACK) && Selected != 3)
            {
                Selected = 3;
                Delay(5);
            }
            else if (Buttons == (BT_USER1 | BT_BACK) && Selected != 4)
                Selected = 4
            else if (Buttons == (BT_USER1 | BT_BACK | BT_MOVELEFT) && Selected != 5)
            {
                Selected = 5;
                Delay(5);
            }
            else if (Buttons == (BT_USER1 | BT_MOVELEFT) && Selected != 6)
                Selected = 6
            else if (Buttons == (BT_USER1 | BT_MOVELEFT | BT_FORWARD) && Selected != 7)
            {
                Selected = 7;
                Delay(5);
            }
            // There used to be non-working stuff here, but I fixed it to be working. -Kate
            else if ((FixedSqrt(MouseX * MouseX + MouseY * MouseY)) > 0.02)
            {
                if (VectorAngle(MouseX, MouseY) > 0.1875 && VectorAngle(MouseX, MouseY) < 0.3125)
                    Selected = 0
                else if (VectorAngle(MouseX, MouseY) > 0.0625 && VectorAngle(MouseX, MouseY) < 0.1875)
                    Selected = 1
                else if (VectorAngle(MouseX, MouseY) >= 0 && VectorAngle(MouseX, MouseY) < 0.0625)
                    Selected = 2
                else if (VectorAngle(MouseX, MouseY) <= 1 && VectorAngle(MouseX, MouseY) > 0.9375)
                    Selected = 2
                else if (VectorAngle(MouseX, MouseY) > 0.8125 && VectorAngle(MouseX, MouseY) < 0.9375)
                    Selected = 3
                else if (VectorAngle(MouseX, MouseY) > 0.6875 && VectorAngle(MouseX, MouseY) < 0.8125)
                    Selected = 4
                else if (VectorAngle(MouseX, MouseY) > 0.5625 && VectorAngle(MouseX, MouseY) < 0.6875)
                    Selected = 5
                else if (VectorAngle(MouseX, MouseY) > 0.4375 && VectorAngle(MouseX, MouseY) < 0.5625)
                    Selected = 6
                else if (VectorAngle(MouseX, MouseY) > 0.3125 && VectorAngle(MouseX, MouseY) < 0.4375)
                    Selected = 7;
            };
            // else
               // Selected = -1;
        };
        
        // Set Skill
        if (Selected >= 0 && Player.SkillCategory[Selected] != -1 && Player.SkillIndex[Selected] != -1)
        {
            CurrentSkill = &Skills[Player.SkillCategory[Selected]][Player.SkillIndex[Selected]];
            SkillLevel = &Player.SkillLevel[Player.SkillCategory[Selected]][Player.SkillIndex[Selected]];
        }
        else
        {
            CurrentSkill = nullptr;
            SkillLevel = nullptr;
        };
        
        // Extra Input Handling
        if (Buttons & BT_SPEED && Selected != -1)
        {
            // Decrease selected skill level
            if (Buttons & BT_MOVELEFT && !(OldButtons & BT_MOVELEFT) && SkillLevel->CurrentLevel > 1)
            {
                SkillLevel->CurrentLevel--;
                AmbientSound("menu/move", 127);
            };
            
            // Increase selected skill level
            if (Buttons & BT_MOVERIGHT && !(OldButtons & BT_MOVERIGHT) && SkillLevel->CurrentLevel < SkillLevel->Level)
            {
                SkillLevel->CurrentLevel++;
                AmbientSound("menu/move", 127);
            };
            
            // Clear Skill
            if (Buttons & BT_USE)
            {
                Player.SkillCategory[Selected] = -1;
                Player.SkillIndex[Selected] = -1;
                AmbientSound("menu/move", 127);
            };
        };
        
        // Play sound
        if (Selected != LastSelected && Selected >= 0)
            ActivatorSound("menu/click", 127);
        
        LastSelected = Selected;
        
        // Draw Wheel
        SetHudSize(640, 480, false);
        for (int i = 0; i < MAX_SKILLKEYS; i++)
        {
            fixed Angle = -0.25 + ((1.0 / MAX_SKILLKEYS) * i);
            fixed X = 320.0 + (CurrentRadius * Cos(Angle));
            fixed Y = 240.0 + (CurrentRadius * Sin(Angle));
            
            // Cursor
            if (i == Selected)
                PrintSprite("SelectBo", 0, (int)X, (int)Y, 0.05);
            
            // Slot Number
            SetFont("SMALLFONT");
            HudMessage("%d\n", i + 1, HUDMSG_FADEOUT, WHEEL_ID - MAX_SKILLKEYS + i, CR_GREEN, (int)(X + 16), (int)(Y - 16), 0.05, 1.0);
            
            // Icon
            if (Player.SkillCategory[i] != -1 && Player.SkillIndex[i] != -1)
                PrintSpriteFade(Skills[Player.SkillCategory[i]][Player.SkillIndex[i]].Icon, WHEEL_ID + i, (int)X, (int)Y, 0.05, 1.0);
            
            // Box
            PrintSpriteFade("ItemBox", WHEEL_ID + MAX_SKILLKEYS + i, (int)X, (int)Y, 0.05, 1.0);
        };
        
        // Animate Wheel
        if (CurrentRadius < Radius)
            CurrentRadius += GetCVar("drpg_skill_wheelspeed");
        
        // Skill Info
        if (CurrentSkill != nullptr)
        {
            int Cost = ScaleEPCost(CurrentSkill->Cost * SkillLevel->CurrentLevel * Player.SkillCostMult);
            str CostColor = (Player.EP < Cost ? "\cg" : "\cv");
            str Info;
            
            // Build info string
            Info = StrParam("\cd%s\n\n\n", CurrentSkill->Name);
            Info = StrParam("%s\cjLevel: %d/%d\n\n", Info, SkillLevel->CurrentLevel, SkillLevel->Level);
            Info = StrParam("%s%s%d EP\n", Info, CostColor, Cost);
            
            // Display
            SetFont("SMALLFONT");
            SetHudClipRect(0, 0, 0, 0, 128);
            HudMessage("%s\n", Info, HUDMSG_FADEOUT, WHEEL_ID + (MAX_SKILLKEYS * 2), CR_WHITE, 320.4, 240.0, 0.05, 1.0);
            SetHudClipRect(0, 0, 0, 0, 0);
        };
        
        Delay(1);
    };
    
    Delay(1);
    goto Start;
};

acscript void UseSkill(int Key) net
{
    // Current Skill
    int Index = (Player.InMenu && Player.Menu == 3 ? -1 : Player.SkillSelected);
    SkillPtr CurrentSkill;
    SkillLevelInfo *SkillLevel;
    
    // Quick Use handling
    if (Key > 0)
    {
        CurrentSkill = &Skills[Player.SkillCategory[Key - 1]][Player.SkillIndex[Key - 1]];
        SkillLevel = &Player.SkillLevel[Player.SkillCategory[Key - 1]][Player.SkillIndex[Key - 1]];
    }
    else
    {
        CurrentSkill = &Skills[Player.SkillCategory[Index]][Player.SkillIndex[Index]];
        SkillLevel = &Player.SkillLevel[Player.SkillCategory[Index]][Player.SkillIndex[Index]];
    };
    
    // If you're dead, terminate
    if (GetActorProperty(0, APROP_Health) <= 0) return;
    
    // If you have no current skill selected, terminate
    if (Player.SkillSelected == -1 && !Player.InMenu) return;
    
    // If the key is unassigned, terminate
    if (Index != -1)
        if (Player.SkillCategory[Index] == -1 || Player.SkillIndex[Index] == -1) return;
    
    // You can't use skills if you're Silenced
    if (Player.StatusType[SE_SILENCE]) return;
    
    // Quickuse
    if (Index == -1)
    {
        CurrentSkill = &Skills[Player.SkillPage][Player.MenuIndex];
        SkillLevel = &Player.SkillLevel[Player.SkillPage][Player.MenuIndex];
    };
    
    int Buttons = GetPlayerInput(PlayerNumber(), INPUT_BUTTONS);
    int OldButtons = GetPlayerInput(PlayerNumber(), INPUT_OLDBUTTONS);
    int EPCost = ScaleEPCost(CurrentSkill->Cost * SkillLevel->CurrentLevel * Player.SkillCostMult);
    bool Success;
    
    // Overdrive?
    Overdrive = false;
    if (Buttons & BT_SPEED && (!Player.InMenu && !Player.InShop))
        Overdrive = true;
    
    // Overdriving an unlearnt skill will learn it
    if (Overdrive && CheckInventory("DRPGSkillToken") > 0 && SkillLevel->Level == 0)
    {
        SkillLevel->Level++;
        SkillLevel->CurrentLevel++;
        TakeInventory("DRPGSkillToken", 1);
        FadeRange(0, 255, 255, 0.5, 0, 255, 255, 0.0, 0.5);
        ActivatorSound("health/epcapsule", 127);
        return;
    };
    
    // Check if the Skill has been learned yet
    if (SkillLevel->Level == 0)
    {
        SetFont("BIGFONT");
        HudMessage("You don't know this skill yet\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("skills/fail", 127);
        return;
    };

    // Can't use skills while burned out
    if (Player.EP < 0)
    {
        SetFont("BIGFONT");
        HudMessage("You can't use skills while burned out\n", HUDMSG_FADEOUT, 0, CR_BLUE, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("skills/fail", 127);
        return;
    };
    
    // Use the Skill
    if (Player.EP >= EPCost || Overdrive)
    {
        // Data to pass to the script pointer
        void *Data = nullptr;
        auto int DataCategory = (Index == -1 ? Player.SkillPage : Player.SkillCategory[Player.SkillSelected]);
        auto int DataIndex = (Index == -1 ? Player.MenuIndex : Player.SkillIndex[Player.SkillSelected]);
        
        if (Key > 0)
        {
            DataCategory = Player.SkillCategory[Key - 1];
            DataIndex = Player.SkillIndex[Key - 1];
        };
        
        // Powerups, Auras and Summons need their index passed
        if (DataCategory == 1 || DataCategory == 2 || DataCategory == 4)
            Data = &DataIndex;
        
        // Debugging
        if (GetCVar("drpg_debug"))
        {
            Log("\cdDEBUG: \c-EP Cost for %s (\cdLevel %d\c-): \cn%d\n", CurrentSkill->Name, SkillLevel->CurrentLevel, EPCost);
            Log("\cdDEBUG: \c-Data Category/Index: \cd%d\c-, \cd%d\n", DataCategory, DataIndex);
            Log("\cdDEBUG: \c-Skill Data passed: \cd%d\n", *(int *)Data);
        };
        
        // PWAA-9001 Accessory Handling - Increase skill level intermittently
        if (Player.Shield.Accessory && Player.Shield.Accessory->PassiveEffect == SHIELD_PASS_SKILLPLUS && Player.Shield.Active && SkillLevel->CurrentLevel < CurrentSkill->MaxLevel)
            SkillLevel->CurrentLevel++;
        
        // Use Skill
        Success = CurrentSkill->Use(SkillLevel, Data);
        
        // PWAA-9001 Accessory Handling - Change back to previous level
        if (Player.Shield.Accessory && Player.Shield.Accessory->PassiveEffect == SHIELD_PASS_SKILLPLUS && Player.Shield.Active && SkillLevel->CurrentLevel < CurrentSkill->MaxLevel)
            SkillLevel->CurrentLevel--;
        
        // Check if the skill use was successful
        if (Success)
        {
            if (!Player.Shield.Accessory || Player.Shield.Accessory->PassiveEffect != SHIELD_PASS_MORESKILLS || Random(1, 4) != 1)
                Player.EP -= EPCost;
            
            if (Player.Shield.Active && Player.Shield.Accessory && Player.Shield.Accessory->PassiveEffect == SHIELD_PASS_SKILLTOSHIELD)
                Player.Shield.Charge += EPCost / 10;
        };
    }
    else // Not enough EP
    {
        SetFont("BIGFONT");
        HudMessage("Not enough EP to use this skill!\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("skills/fail", 127);
    };
};

acscript bool Heal(SkillLevelInfo *SkillLevel, void *Data)
{
    int PlayerTID = Player.TID;
    bool Team = (SkillLevel->CurrentLevel >= 3);
    
    // Refund - If your health is max or above at levels lower than 3 or you don't have a status effect
    if ((SkillLevel->CurrentLevel < 3 && Player.ActualHealth >= Player.HealthMax) && !HaveStatusEffect())
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Healing
    if (Team)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i)) continue;
            
            SetActivator(Players(i).TID);
            
            if (SkillLevel->CurrentLevel >= 4)
            {
                AddHealth(200, 200);
                Players(i).OverHeal = true;
            }
            else
                AddHealth(100, 100);
        };
        
        SetActivator(PlayerTID);
    }
    else
    {
        if (SkillLevel->CurrentLevel >= 4)
        {
            AddHealth(200, 200);
            Player.OverHeal = true;
        }
        else
            AddHealth(100, 100);
    };
    
    // Remove Status Effects
    if (SkillLevel->CurrentLevel >= 2)
    {
        if (Team)
        {
            for (int i = 0; i < MAX_PLAYERS; i++)
            {
                if (!PlayerInGame(i)) continue;
                
                SetActivator(Players(i).TID);
                
                ClearStatusEffects();
            };
            
            SetActivator(PlayerTID);
        }
        else
            ClearStatusEffects();
    };
    
    if (Team)
    {
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            if (!PlayerInGame(i)) continue;
            
            SetActivator(Players(i).TID);
            
            FadeRange(255, 0, 255, 0.5, 255, 0, 255, 0, 1.0);
            ActivatorSound("skills/heal", (Players(i).TID == PlayerTID ? 127 : 64));
        };
        
        SetActivator(PlayerTID);
    }
    else
    {
        FadeRange(255, 0, 255, 0.5, 255, 0, 255, 0, 1.0);
        ActivatorSound("skills/heal", 127);
    };
    
    return true;
};

acscript bool HealSummons(SkillLevelInfo *SkillLevel, void *Data)
{
    // Refund - If you have no summoned monsters
    if (Player.Summons == 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    FadeRange(255, 0, 255, 0.5, 255, 0, 255, 0, 1.0);
    
    for (int i = 0; i < MAX_SUMMONS; i++)
        if (Player.SummonTID[i] > 0)
        {
            MonsterStatsPtr Stats = &Monsters[GetMonsterID(Player.SummonTID[i])];
            SetActorProperty(Player.SummonTID[i], APROP_Health, Stats->HealthMax);
        };
    
    ActivatorSound("skills/heal2", 127);
    
    return true;
};

acscript bool Decontaminate(SkillLevelInfo *SkillLevel, void *Data)
{
    if (Player.Toxicity <= 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    Player.Toxicity = 0;
    ClearToxicityMeter();
    
    ActivatorSound("skills/decontaminate", 127);
    FadeRange(0, 255, 0, 0.5, 0, 255, 0, 0.0, 1.0);
    
    return true;
};

acscript bool Repair(SkillLevelInfo *SkillLevel, void *Data)
{
    if (CheckInventory("Armor") == 0 || CheckInventory("Armor") >= GetArmorInfo(ARMORINFO_SAVEAMOUNT))
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    FadeRange(0, 255, 0, 0.5, 0, 255, 0, 0, 1.0);
    GiveInventory(GetArmorInfoString(ARMORINFO_CLASSNAME), 1);
    
    ActivatorSound("skills/repair", 127);
    
    return true;
};

acscript bool Powerup(SkillLevelInfo *SkillLevel, void *Data)
{
    int Index = *(int *)Data;
    
    switch (Index)
    {
    case 0: // Invulnerability
        if (CheckInventory("PowerInvulnerable"))
        {
            ActivatorSound("menu/error", 127);
            return false;
        };
        ActivatorSound("powerups/protect", 127);
        GiveInventory(StrParam("DRPGSkillInvulnerability%d\n", SkillLevel->CurrentLevel), 1);
        break;
    case 1: // Invisibility
        if (CheckInventory("PowerShadow"))
        {
            ActivatorSound("menu/error", 127);
            return false;
        };
        ActivatorSound("powerups/invis", 127);
        GiveInventory(StrParam("DRPGSkillInvisibility%d\n", SkillLevel->CurrentLevel), 1);
        break;
    case 3: // Iron Feet
        if (CheckInventory("PowerIronFeet"))
        {
            ActivatorSound("menu/error", 127);
            return false;
        };
        ActivatorSound("powerups/suit", 127);
        GiveInventory("PowerIronFeet", 1);
        break;
    case 4: // Night Vision
        if (CheckInventory("PowerLightAmp"))
        {
            ActivatorSound("menu/error", 127);
            return false;
        };
        ActivatorSound("powerups/light", 127);
        GiveInventory("PowerLightAmp", 1);
        break;
    case 5: // Berserk
        ActivatorSound("powerups/berserk", 127);
        GiveInventory("PowerStrength", 1);
        break;
    case 6: // Mental Mapping
        ActivatorSound("powerups/map", 127);
        GiveInventory("DRPGAllMapRevealer", 1);
        GiveInventory("DRPGAllMapScanner", 1);
        break;
    };
    
    return true;
};

acscript bool BulletTime(SkillLevelInfo *SkillLevel, void *Data)
{
    if (SkillLevel->CurrentLevel == 1) // Stutter Time
    {
        BulletTimeTimer = 350;
        SpawnForced("DRPGTimeFreezerQuickSound", GetActorX(0), GetActorY(0), GetActorZ(0), 0, 0);
        TakeInventory("PowerTimeFreezer", 1);
        GiveInventory("DRPGTimeFreezerQuick", 1);
    };
    if (SkillLevel->CurrentLevel == 2) // Freeze Time
    {
        SpawnForced("DRPGTimeFreezerSound", GetActorX(0), GetActorY(0), GetActorZ(0), 0, 0);
        GiveInventory("DRPGTimeFreezer", 1);
    };
    
    return true;
};

acscript bool DropWeapon(SkillLevelInfo *SkillLevel, void *Data)
{
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0) + Cos(Angle) * 96.0;
    fixed Y = GetActorY(0) + Sin(Angle) * 96.0;
    fixed Z = GetActorZ(0) + 48.0;
    str Weapon;
    
    switch (SkillLevel->CurrentLevel)
    {
    case 1: Weapon = "Pistol";          break;
    case 2: Weapon = "Shotgun";         break;
    case 3: Weapon = "SuperShotgun";    break;
    case 4: Weapon = "Chaingun";        break;
    case 5: Weapon = "RocketLauncher";  break;
    case 6: Weapon = "PlasmaRifle";     break;
    case 7: Weapon = "BFG9000";         break;
    };
    
    if (Spawn(Weapon, X, Y, Z, 0, Angle))
    {
        ActivatorSound("skills/drop", 127);
        Spawn("TeleportFog", X, Y, Z, 0, Angle);
        return true;
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    return false;
};

acscript bool DropAmmo(SkillLevelInfo *SkillLevel, void *Data)
{
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0) + Cos(Angle) * 96.0;
    fixed Y = GetActorY(0) + Sin(Angle) * 96.0;
    fixed Z = GetActorZ(0) + 48.0;
    str Ammo;
    
    switch (SkillLevel->CurrentLevel)
    {
    case 1:         Ammo = "DRPGSmallBackpack"; break;
    case 2:         Ammo = "DRPGBackpack";      break;
    case 3: case 4: Ammo = "DRPGBigBackpack";   break;
    };
    
    if (Spawn(Ammo, X, Y, Z, 0, Angle))
    {
        if (SkillLevel->CurrentLevel == 4 && CompatMode == COMPAT_DRLA)
            Spawn("RLSupplyCrate", X, Y, Z, 0, Angle);
        
        ActivatorSound("skills/drop", 127);
        Spawn("TeleportFog", X, Y, Z, 0, Angle);
        return true;
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };

    return false;
};

acscript bool UseAura(SkillLevelInfo *SkillLevel, void *Data)
{
    int Index = *(int *)Data;
    bool Stack = false;
    
    // Is the Aura you used the same as the one you already have active?
    if (Player.Aura.Type[Index].Active)
        Stack = true;
    
    // Remove all other Auras first if you don't have the Energy
    if (!Player.Perks[STAT_ENERGY])
        for (int i = 0; i < AURA_MAX; i++)
            Player.Aura.Type[i].Active = false;
    
    // Should the timer be stacked because you used the same Aura?
    if (Stack || Player.Perks[STAT_ENERGY])
        Player.Aura.Time += AURA_CALCTIME
    else
        Player.Aura.Time = AURA_CALCTIME;
    
    // Apply Aura
    Player.Aura.Type[Index].Active = true;
    Player.Aura.Type[Index].Level = SkillLevel->CurrentLevel;
    
    // Aura Cost Multiplier
    Player.Aura.CostMult += 10;
    
    ActivatorSound("skills/buff", 127);
    return true;
};

acscript bool Weaken(SkillLevelInfo *SkillLevel, void *Data)
{
    int PlayerNum = PlayerNumber();
    int StatDivide;
    
    SetActivatorToTarget(Players(PlayerNum).TID);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    // Refund - If the Player has no target
    if (ActivatorTID() == Players(PlayerNum).TID)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Refund - If the target isn't actually a valid monster
    if (!Stats->Init || !(ClassifyActor(0) & ACTOR_MONSTER))
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    // Refund - If the target is immune to Weaken
    if (Stats->Flags & MF_NOWEAKEN)
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    // Determine stat division
    // TODO: formula-ify this?
    switch (SkillLevel->CurrentLevel)
    {
    case 1:         StatDivide = 16;    break;
    case 2:         StatDivide = 8;     break;
    case 3:         StatDivide = 4;     break;
    case 4: case 5: StatDivide = 2;     break;
    };
    
    // Bosses will double the divider
    if (Stats->Flags & MF_BOSS)
        StatDivide *= 2;
    
    // MegaBosses will quadruple the divider
    if (Stats->Flags & MF_MEGABOSS)
        StatDivide *= 4;
    
    // Halve the monster's level and stats
    Stats->Level -= (Stats->Level / StatDivide);
    Stats->Strength -= (Stats->Strength / StatDivide);
    Stats->Defense -= (Stats->Defense / StatDivide);
    Stats->Vitality -= (Stats->Vitality / StatDivide);
    Stats->Energy -= (Stats->Energy / StatDivide);
    Stats->Regeneration -= (Stats->Regeneration / StatDivide);
    Stats->Agility -= (Stats->Agility / StatDivide);
    Stats->Capacity -= (Stats->Capacity / StatDivide);
    Stats->Luck -= (Stats->Luck / StatDivide);
    
    // Destroy Aura
    if (SkillLevel->CurrentLevel >= 5)
        RemoveMonsterAura(Stats);
    
    // Cap Level
    if (Stats->Level < 1)
        Stats->Level = 1;
    
    // Re-calculate the monster's threat level
    Stats->Threat = CalculateMonsterThreatLevel(0);
    
    // Reset Activator
    SetActivator(Players(PlayerNum).TID);
    
    FadeRange(0, 0, 0, 0.25, 0, 0, 0, 0.0, 1.0);
    ActivatorSound("skills/weaken", 127);
    return true;
};

acscript bool Translocate(SkillLevelInfo *SkillLevel, void *Data)
{
    if (InBase)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    FireProjectile("DRPGTranslocateBall");
    return true;
};

acscript bool Repulse(SkillLevelInfo *SkillLevel, void *Data)
{
    SetInventory(StrParam("DRPGSkillBlast%d\n", SkillLevel->CurrentLevel), 1);
    UseInventory(StrParam("DRPGSkillBlast%d\n", SkillLevel->CurrentLevel));
    
    FadeRange(255, 255, 0, 0.1, 255, 255, 0, 0.0, 0.5 + (0.25 * SkillLevel->CurrentLevel));
    
    return true;
};

acscript bool AuraSteal(SkillLevelInfo *SkillLevel, void *Data)
{
    int PlayerNum = PlayerNumber();
    
    SetActivatorToTarget(Players(PlayerNum).TID);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    // Refund - If the Player has no target
    if (ActivatorTID() == Players(PlayerNum).TID)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Refund - If the target isn't actually a valid monster
    if (!Stats->Init || !(ClassifyActor(0) & ACTOR_MONSTER))
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    // Refund - If the target doesn't have an Aura
    if (!MonsterHasAura(Stats))
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    for (int i = 0; i < AURA_MAX; i++)
        if (Stats->Aura.Type[i].Active)
        {
            // Transfer
            Players(PlayerNum).Aura.Type[i].Active = true;
            
            // Determine Level
            int Level = Players(PlayerNum).Energy / 25 + 1;
            if (Level > Skills[2][i].MaxLevel)
                Level = Skills[2][i].MaxLevel;
            Players(PlayerNum).Aura.Type[i].Level = Level;
        };
    
    // Add Time
    Players(PlayerNum).Aura.Time += Stats->Aura.Time;
    
    // Remove from enemy
    RemoveMonsterAura(Stats);
    
    ActivatorSound("skills/aurasteal", 127);
    return true;
};

acscript bool SoulSteal(SkillLevelInfo *SkillLevel, void *Data)
{
    static str[SOUL_MAX] SoulTypes =
    {
        "DRPGSoulRed";
        "DRPGSoulGreen";
        "DRPGSoulWhite";
        "DRPGSoulPink";
        "DRPGSoulBlue";
        "DRPGSoulPurple";
        "DRPGSoulOrange";
        "DRPGSoulDarkBlue";
        "DRPGSoulYellow";
    };
    
    int PlayerNum = PlayerNumber();
    int UniqueMonsterTID = UniqueTID();
    int RealMonsterTID;
    int BeforeHealthAmount;
    int AfterHealthAmount;
    bool AllowsXP;
    
    // Move activation to the user's target
    SetActivatorToTarget(Players(PlayerNum).TID);
    
    // Pointer
    MonsterStatsPtr Stats = &Monsters[GetMonsterID(0)];
    
    // Refund - If the Player has no target
    if (ActivatorTID() == Players(PlayerNum).TID)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Refund - If the target isn't actually a valid monster
    if (!Stats->Init || !(ClassifyActor(0) & ACTOR_MONSTER))
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    // Refund - If the target is a boss or can never have an aura to begin with
    if (Stats->Flags & MF_BOSS || Stats->Flags & MF_NOAURA || CheckFlag(0, "BOSS"))
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    // Leech Amount
    int LeechAmount = (int)((fixed)Stats->HealthMax * ((fixed)SkillLevel->CurrentLevel / 10.0));
    if (LeechAmount < 1)
        LeechAmount = 1;
    
    AllowsXP = !(Stats->Flags & MF_NOXP);
    
    // Don't gain XP from this
    if (AllowsXP)
        Stats->Flags |= MF_NOXP;
    
    // Temporary changing of TID to handle giving XP properly
    RealMonsterTID = ActivatorTID();
    Thing_ChangeTID(0, UniqueMonsterTID);
    
    BeforeHealthAmount = GetActorProperty(0, APROP_Health);
    
    // Damage Enemy
    SetActivator(Players(PlayerNum).TID);
    SetActorProperty(UniqueMonsterTID, APROP_Health, GetActorProperty(UniqueMonsterTID, APROP_Health) - LeechAmount);
    SetActivator(UniqueMonsterTID);
    
    AfterHealthAmount = GetActorProperty(0, APROP_Health);
    if (AfterHealthAmount < 0)
        AfterHealthAmount = 0;
    
    LeechAmount = BeforeHealthAmount - AfterHealthAmount; // Only heal based on how much we *actually* took
    
    // Drop the Soul
    if (GetActorProperty(0, APROP_Health) <= 0)
    {
        if (MonsterHasAura(Stats))
        {
            for (int i = 0; i < AURA_MAX; i++)
                if (Stats->Aura.Type[i].Active)
                    DropMonsterItem(PlayerNum, 0, SoulTypes[i], 256);
        }
        else
            DropMonsterItem(PlayerNum, 0, SoulTypes[Random(0, SOUL_MAX - 1)], 256);
    }
    else if (AllowsXP) // Stats->Flags &= ~MF_NOXP; // TODO: Notify DavidPH that this doesn't work
        Stats->Flags &= ~0x02;
    
    // Move activation back to the user
    SetActivator(Players(PlayerNum).TID);
    
    // Reset the temporary TID
    Thing_ChangeTID(UniqueMonsterTID, RealMonsterTID);
    
    // Late Refund - If we did no damage to the target at all
    if (!LeechAmount)
    {
        ThingSound(Players(PlayerNum).TID, "menu/error", 127);
        return false;
    };
    
    // Heal the user
    AddHealthDirect(LeechAmount, 100);
    
    FadeRange(0, 0, 0, 0.5, 0, 0, 0, 0.0, 0.25);
    ActivatorSound("skills/soulsteal", 127);
    return true;
};

acscript bool Summon(SkillLevelInfo *SkillLevel, void *Data)
{
    int Index = *(int *)Data;
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0);
    int NewID = UniqueTID();
    bool Success;
    fixed Radius;
    str Name;
    
    str[] Summons =
    {
        "ZombieMan";
        "ShotgunGuy";
        "ChaingunGuy";
        "DoomImp";
        "Demon";
        "Cacodemon";
        "HellKnight";
        "BaronOfHell";
        "LostSoul";
        "PainElemental";
        "Revenant";
        "Fatso";
        "Arachnotron";
        "Archvile";
        "Cyberdemon";
        "SpiderMastermind";
    };
    
    str[][] DRLASummons =
    {
        // Former Human
        {
            "RLDRPGSummonedFormerHuman";
            "RLDRPGSummonedEliteHuman";
            "RLDRPGSummonedFormerCaptain";
        };
        
        // Former Sergeant
        {
            "RLDRPGSummonedFormerSergeant";
            "RLDRPGSummonedEliteSergeant";
        };
        
        // Former Commando
        {
            "RLDRPGSummonedFormerCommando";
            "RLDRPGSummonedEliteCommando";
            "RLDRPGSummonedEliteCaptain2";
        };
        
        // Imp
        {
            "RLDRPGSummonedImp";
            "RLDRPGSummonedNightmareImp";
            "RLDRPGSummonedCyberneticImp";
        };
        
        // Demon
        {
            "RLDRPGSummonedDemon";
            "RLDRPGSummonedSpectre";
            "RLDRPGSummonedNightmareDemon";
            "RLDRPGSummonedNightmareSpectre";
            "RLDRPGSummonedCyberneticDemon";
            "RLDRPGSummonedCyberneticSpectre";
        };
        
        // Cacodemon
        {
            "RLDRPGSummonedCacodemon";
            "RLDRPGSummonedNightmareCacodemon";
        };
        
        // Hell Knight
        {
            "RLDRPGSummonedHellKnight";
            "RLDRPGSummonedNightmareHellKnight";
            "RLDRPGSummonedCyberneticHellKnight";
        };
        
        // Baron of Hell
        {
            "RLDRPGSummonedBaronOfHell";
            "RLDRPGSummonedNightmareBaronOfHell";
            "RLDRPGSummonedCyberneticBaronOfHell";
        };
        
        // Lost Soul
        {
            "RLDRPGSummonedLostSoul";
            "RLDRPGSummonedNightmareLostSoul";
            "RLDRPGSummonedCyberneticLostSoul";
        };
        
        // Pain Elemental
        {
            "RLDRPGSummonedPainElemental";
            "RLDRPGSummonedNightmarePainElemental";
        };
        
        // Revenant
        {
            "RLDRPGSummonedRevenant";
            "RLDRPGSummonedNightmareRevenant";
            "RLDRPGSummonedCyberneticRevenant";
        };
        
        // Mancubus
        {
            "RLDRPGSummonedMancubus";
            "RLDRPGSummonedNightmareMancubus";
            "RLDRPGSummonedCyberneticMancubus";
        };
        
        // Arachnotron
        {
            "RLDRPGSummonedArachnotron";
            "RLDRPGSummonedNightmareArachnotron";
            "RLDRPGSummonedCyberneticArachnotron";
        };
        
        // Arch-Vile
        {
            "RLDRPGSummonedArchVile";
            "RLDRPGSummonedNightmareArchVile";
        };
        
        // Cyberdemon
        {
            "RLDRPGSummonedCyberdemon";
            "RLDRPGSummonedNightmareCyberdemon";
        };
        
        // Spider Mastermind
        {
            "RLDRPGSummonedSpiderMastermind";
            "RLDRPGSummonedCyberneticSpiderMastermind";
        };
    };
    
    // Stop if you're in the Outpost
    if (InBase)
    {
        SetFont("BIGFONT");
        HudMessage("You cannot summon friendlies here\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Stop if you already have the maximum amount of summons
    if (Player.Summons >= MAX_SUMMONS)
    {
        SetFont("BIGFONT");
        HudMessage("You cannot summon any more friendlies\n", HUDMSG_FADEOUT, 0, CR_RED, 0.5, 0.5, 2.0, 1.0);
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    if (Index == 0) // Marines
    {
        switch (SkillLevel->CurrentLevel)
        {
        case 1: Name = "DRPGMarineGuardPistolSummoned";    break;
        case 2: Name = "DRPGMarineShotgunSummoned";        break;
        case 3: Name = "DRPGMarineDoubleShotgunSummoned";  break;
        case 4: Name = "DRPGMarineChaingunSummoned";;      break;
        case 5: Name = "DRPGMarineRocketLauncherSummoned"; break;
        case 6: Name = "DRPGMarinePlasmaRifleSummoned";    break;
        case 7: Name = "DRPGMarineBFG9000Summoned";        break;
        };
    }
    else // Monsters
    {
        if (CompatMode == COMPAT_DRLA)
            Name = DRLASummons[Index - 1][SkillLevel->CurrentLevel - 1]
        else if (CompatMode == COMPAT_EXTRAS)
            Name = StrParam("DRPG%sExtras\n", Summons[Index - 1])
        else
            Name = StrParam("DRPG%s\n", Summons[Index - 1]);
    };
    
    // Perform a dummy summon to get the Radius and add it to X and Y
    SpawnForced(Name, 0, 0, 0, NewID, 0);
    Radius = GetActorPropertyFixed(NewID, APROP_Radius);
    X += Cos(Angle) * (Radius * 1.5 + 16.0);
    Y += Sin(Angle) * (Radius * 1.5 + 16.0);
    Thing_Remove(NewID);
    
    // With the new radius, try and summon the actual monster
    Success = Spawn(Name, X, Y, Z, NewID, Angle);
    
    if (Success)
    {
        SpawnForced("TeleportFog", X, Y, Z, 0, Angle);
        SetActorAngle(NewID, Angle);
        SetActorProperty(NewID, APROP_Friendly, 1);
        SetActorProperty(NewID, APROP_MasterTID, Player.TID);
        GiveActorInventory(NewID, "DRPGFriendlyBooster", 1);
        SetActorState(NewID, "See");
        
        // Setup Stats
        Delay(4); // We need this initial delay to make sure the ID is valid
        MonsterStatsPtr Stats = &Monsters[GetMonsterID(NewID)];
        fixed Modifier = 1.0 + (fixed)Player.Level * ((fixed)Player.Energy / 20.0);
        Stats->Level = Modifier;
        Stats->Strength = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Defense = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Vitality = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Energy = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Regeneration = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Agility = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Capacity = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Luck = Modifier + Random(0, Stats->Level / GameSkill());
        Stats->Threat = CalculateMonsterThreatLevel(&Monsters[GetMonsterID(NewID)]);
        Stats->Flags |= MF_NODROPS;
        Stats->NeedReinit = true;
        
        // Add summon to your summon array
        for (int i = 0; i < MAX_SUMMONS; i++)
            if (Player.SummonTID[i] == 0)
            {
                Player.SummonTID[i] = NewID;
                Player.Summons++;
                return true;
            };
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
};

acscript bool BreakdownArmor(SkillLevelInfo *SkillLevel, void *Data)
{
    int Armor = CheckInventory("BasicArmor");
    
    // Kind of hackish to prevent breaking down Armors that use high values for indestructibleness
    if (Armor > 1000)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    if (Armor > 0)
    {
        TakeInventory("BasicArmor", Armor);
        GiveInventory("DRPGCredits", Armor);
        
        // DoomRL Compatibility
        if (CompatMode == COMPAT_DRLA)
        {
            RemoveDRLAArmorToken(GetArmorInfoString(ARMORINFO_CLASSNAME));
            TakeInventory("RL100ArmorWorn", 1);
            TakeInventory("RL150ArmorWorn", 1);
            TakeInventory("RL200ArmorWorn", 1);
            TakeInventory("RL100RegenArmorWorn", 1);
            TakeInventory("RLIndestructibleArmorWorn", 1);
        };
        
        ActivatorSound("skills/breakdown", 127);
        return true;
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    return false;
};

acscript bool ForceWall(SkillLevelInfo *SkillLevel, void *Data)
{
    int TID = UniqueTID();
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0) + Cos(Angle) * 96.0;
    fixed Y = GetActorY(0) + Sin(Angle) * 96.0;
    fixed Z = GetActorZ(0);
    
    if (Spawn("DRPGForceWall", X, Y, Z, TID, Angle))
    {
        Delay(4);
        
        MonsterStatsPtr Stats = &Monsters[GetMonsterID(TID)];
        
        // Determine Defense and Health
        Stats->SpawnHealth = GetActorProperty(0, APROP_SpawnHealth);
        Stats->Defense = Player.Energy * 5;
        Stats->Vitality = Player.Energy * 5;
        Stats->HealthMax = CalculateMonsterMaxHealth(Stats);
        SetActorProperty(TID, APROP_Health, Stats->HealthMax);
        
        return true;
    }
    else
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
};

acscript bool Rally(SkillLevelInfo *SkillLevel, void *Data)
{
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0);
    fixed Angle = GetActorAngle(0);
    
    // Fail if you have no summons active
    if (Player.Summons == 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    SpawnForced("TeleportFog", X, Y, Z, 0, Angle);
    
    for (int i = 0; i < MAX_SUMMONS; i++)
        if (Player.SummonTID[i] > 0)
            SetActorPosition(Player.SummonTID[i], X, Y, Z, 0);
    
    ActivatorSound("skills/rally", 127);
    return true;
};

acscript bool Unsummon(SkillLevelInfo *SkillLevel, void *Data)
{
    int EPAdd;
    
    // Fail if you have no summons active
    if (Player.Summons == 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    for (int i = 0; i < MAX_SUMMONS; i++)
    {
        // Continue if there's no summon in this slot
        if (Player.SummonTID[i] == 0) continue;
        
        if (SkillLevel->CurrentLevel == 2 && GetActorProperty(Player.SummonTID[i], APROP_Health) > 0)
            EPAdd += (int)((fixed)Player.EPMax * 0.01) + 1;
        
        // Overdrive - Remove summons (teleport out) instead of killing them
        if (GetActorProperty(Player.SummonTID[i], APROP_Health) > 0)
        {
            SpawnForced("TeleportFog", GetActorX(Player.SummonTID[i]), GetActorY(Player.SummonTID[i]), GetActorZ(Player.SummonTID[i]), 0, 0);
            Thing_Remove(Player.SummonTID[i]);
        };
        
        // Remove the summon from the array
        Player.SummonTID[i] = 0;
    };
    
    
    Log("EPAdd: %d\n", EPAdd);
    if (SkillLevel->CurrentLevel == 2)
        Player.EP += EPAdd;

    Player.Summons = 0;
    
    FadeRange(192, 0, 0, 0.5, 192, 0, 0, 0.0, 1.0);
    ActivatorSound("skills/unsummon", 127);
    return true;
};

acscript bool Recall(SkillLevelInfo *SkillLevel, void *Data)
{
    // Fail if you're in the Arena or Marines are hostile
    if (ArenaActive || MarinesHostile)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
        
    SetInventory("ArtiTeleport", 1);
    UseInventory("ArtiTeleport");
    return true;
};

acscript bool Magnetize(SkillLevelInfo *SkillLevel, void *Data)
{
    int *TID = (int *)Player.DropTID.Data;
    fixed Angle = GetActorAngle(0);
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0) + (GetActorPropertyFixed(0, APROP_Height) / 2);
    int AngleDivide;
    fixed AngleAdd;
    int CreditCount;
    
    // Count Credits
    for (int i = 0; i < Player.DropTID.Position; i++)
        if (ThingCount(0, TID[i]) > 0 && StartsWith(GetActorClass(TID[i]), "DRPGCredits"))
        {
            if (GetActorClass(TID[i]) == "DRPGCredits1")
                CreditCount++;
            if (GetActorClass(TID[i]) == "DRPGCredits5")
                CreditCount += 5;
            if (GetActorClass(TID[i]) == "DRPGCredits10")
                CreditCount += 10;
            if (GetActorClass(TID[i]) == "DRPGCredits20")
                CreditCount += 20;
            if (GetActorClass(TID[i]) == "DRPGCredits50")
                CreditCount += 50;
            if (GetActorClass(TID[i]) == "DRPGCredits100")
                CreditCount += 100;
            if (GetActorClass(TID[i]) == "DRPGCredits1000")
                CreditCount += 1000;
            
            int HolderTID = UniqueTID();
            SpawnSpot("DRPGCreditsEmpty", TID[i], HolderTID, Random(0, 255));
            SetActorVelocity(HolderTID, RandomFixed(-8, 8), RandomFixed(-8, 8), RandomFixed(2, 8), false, false);
            Thing_Remove(TID[i]);
        };
    
    // Give calculated Credits
    if (CreditCount > 0)
    {
        if (Player.Shield.Accessory && Player.Shield.Accessory->PassiveEffect == SHIELD_PASS_DOSHMAGNET)
            CreditCount *= 3;
        
        GiveInventory("DRPGCredits", CreditCount);
        ActivatorSound("credits/pickup", 127);
    };
    
    CleanDropTIDArray();
    
    AngleDivide = Player.DropTID.Position;
    
    // Refund - If there are no items in the array
    if (Player.DropTID.Position == 0 && CreditCount == 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Overdrive - Pull the items on top of you and pick them all up
    if (Overdrive)
    {
        for (int i = 0; i < Player.DropTID.Position; i++)
        {
            SetActorPosition(TID[i], X, Y, Z, 0);
            SetActorVelocity(TID[i], 0, 0, 0, false, false);
            GiveActorInventory(TID[i], "DRPGMagnetizedItem", 1);
        };
        
        SetActorVelocity(0, 0.01, 0.01, 0, true, false);
        
        FadeRange(0, 0, 0, 0.5, 0, 0, 0, 0.0, 1.0);
        ActivatorSound("skills/magnet", 127);
        return true;
    };
    
    AngleAdd = 1.0 / AngleDivide;
    
    for (int i = 0; i < Player.DropTID.Position; i++)
    {
        X = GetActorX(0) + Cos(Angle) * 64.0;
        Y = GetActorY(0) + Sin(Angle) * 64.0;
        SetActorPosition(TID[i], X, Y, Z, 0);
        SetActorVelocity(TID[i], 0, 0, 0, false, false);
        GiveActorInventory(TID[i], "DRPGMagnetizedItem", 1);
        Angle += AngleAdd;
    };
    
    FadeRange(0, 0, 0, 0.5, 0, 0, 0, 0.0, 1.0);
    ActivatorSound("skills/magnet", 127);
    return true;
};

acscript bool Transport(SkillLevelInfo *SkillLevel, void *Data)
{
    // If you're dead, terminate
    if (GetActorProperty(0, APROP_Health) <= 0) return false;
    
    // Don't allow Transport while the arena is active, if the Marines are hostile, or you're in an Outpost-related menu
    if (ArenaActive || MarinesHostile || Player.OutpostMenu > 0)
    {
        ActivatorSound("menu/error", 127);
        return false;
    };
    
    // Multiplayer
    if (InMultiplayer && PlayerCount() > 1)
    {
        int Players = PlayerCount();
        bool Ready = false; 
        bool Force = (Arbitrator && Overdrive);
        bool[MAX_PLAYERS] Voted;
        int PlayersApprove = 0;
        int PlayersDeny = 0;
        
        for (int i = 0; i < MAX_PLAYERS; i++)
            Voted[i] = false;
        
        while (!Ready && !Force)
        {
            // Freeze all players
            SetPlayerProperty(1, 1, PROP_TOTALLYFROZEN);
            
            // Input
            for (int i = 0; i < Players; i++)
            {
                // Skip input checks if you've already voted
                if (Voted[i]) continue;
                
                int Buttons = GetPlayerInput(i, INPUT_BUTTONS);
                
                if (Buttons == BT_USE)
                {
                    ActivatorSound("menu/move", 127);
                    PlayersApprove++;
                    Voted[i] = true;
                };
                if (Buttons == BT_SPEED)
                {
                    ActivatorSound("menu/move", 127);
                    PlayersDeny++;
                    Voted[i] = true;
                };
            };
            
            // Check that everyone has voted
            Ready = true;
            for (int i = 0; i < Players; i++)
                if (!Voted[i])
                {
                    Ready = false;
                    break;
                };
            
            // Drawing
            SetFont("BIGFONT");
            HudMessageBold("\cd%N\c- has requested Transport\n\c-Players: %d (\cd%d\c-/\cg%d\c-)\n\n\cd%K\c- to Approve\n\cd%K\c- to Deny\n",
                           PlayerNumber() + 1, Players, PlayersApprove, PlayersDeny, "+use", "+speed",
                           HUDMSG_FADEOUT, MENU_ID, CR_WHITE, 0.5, 0.75, 1.0, 4.0);
            
            Delay(1);
        };
        
        // Ready - tally votes and confirm/deny Transport
        if (Ready || Force)
        {
            SetPlayerProperty(1, 0, PROP_TOTALLYFROZEN);
            
            // Approved
            if (PlayersApprove > PlayersDeny || Force)
            {
                for (int i = 0; i < MAX_PLAYERS; i++)
                    SetActorProperty(Players(i).TID, APROP_Invulnerable, true);
                SetFont("BIGFONT");
                HudMessageBold("\cdTransport Approved!\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.5, 1.0, 4.0);
                Delay(35 * 2);
                FadeRange(255, 255, 255, 0.0, 255, 255, 255, 1.0, 3.0);
                Delay(35 * 3);
            }
            
            // Denied
            else if (PlayersDeny > PlayersApprove)
            {
                SetFont("BIGFONT");
                HudMessageBold("\cgTransport Denied!\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.5, 1.0, 2.0);
                return false;
            }
            
            // Draw
            else if (PlayersApprove > 0 && PlayersDeny > 0 && PlayersApprove == PlayersDeny)
            {
                SetFont("BIGFONT");
                HudMessageBold("\cjDraw!\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.5, 1.0, 2.0);
                return false;
            }
            
            // Error
            else
            {
                SetFont("BIGFONT");
                HudMessageBold("\cgAn error has occured with the Transport System!\n", HUDMSG_FADEOUT, 0, CR_WHITE, 0.5, 0.5, 1.0, 2.0);
                if (GetCVar("drpg_debug")) // Output EVERYTHING for investigation
                {
                    Output Players;
                    Output Ready;
                    Output Force;
                    Output Voted;
                    Output PlayersApprove;
                    Output PlayersDeny;
                };
                return false;
            };
        };
    }
    else // Single Player
    {
        // Fade Screen
        FadeRange(255, 255, 255, 0.0, 255, 255, 255, 1.0, 1.0);
        
        // Freeze Player
        SetActorProperty(0, APROP_Invulnerable, true);
        SetPlayerProperty(0, 1, PROP_TOTALLYFROZEN);
        
        // Delay and unfreeze Player
        Delay(35);
        SetPlayerProperty(0, 0, PROP_TOTALLYFROZEN);
        SetActorProperty(0, APROP_Invulnerable, false);
    };
    
    // Transport
    if (!InBase)
    {
        LastVisitedLevel = FindLevelInfoIndex();
        
        // Just in case we warp to Outpost from a map with no index, default to MAP01
        if (LastVisitedLevel < 0) LastVisitedLevel = 0;
        
        ChangeLevel("OUTPOST", 0, CHANGELEVEL_NOINTERMISSION, -1);
        InBase = true;
        Transported = true;
        return true;
    }
    else
    {
        ChangeLevel(((LevelInfo *)KnownLevels.Data)[LastVisitedLevel].LumpName, 0, CHANGELEVEL_NOINTERMISSION, -1);
        InBase = false;
        Transported = true;
        return true;
    };
};

acscript void RemoveAura()
{
    Player.Aura.Time = 0;
    Player.Aura.Team = false;
    
    for (int i = 0; i < AURA_MAX; i++)
    {
        Player.Aura.Type[i].Active = false;
        Player.Aura.Type[i].Level = 0;
    };
};

acscript void ClearStatusEffects()
{
    for (int i = 0; i < SE_MAX; i++)
    {
        if (i == SE_RADIATION && Player.StatusType[i])
            StopSound(Player.TID, 7);
        
        Player.StatusType[i] = false;
        Player.StatusTypeHUD = 0;
        Player.StatusIntensity[i] = 0;
        Player.StatusTimer[i] = 0;
        Player.StatusTimerMax[i] = 0;
    };
};

script void CleanDropTIDArray()
{
    // [KS] !!WARNING!! THIS CANNOT BE A FUNCTION.
    int *TID = (int *)Player.DropTID.Data;
    for (int i = 0; i < Player.DropTID.Position; i++)
    {
        if (TID[i] == 0 || ClassifyActor(TID[i]) == ACTOR_NONE)
        {
            TID[i] = TID[Player.DropTID.Position - 1];
            TID[Player.DropTID.Position - 1] = 0;
            Player.DropTID.Position--;
            i -= 2;
            if (i < -1)
                i = -1;
        };
    };
};

function void BuildSkillData()
{
    // DoomRL Compatibility
    if (CompatMode == COMPAT_DRLA)
    {
        // Add an extra level to the Ammo Drop to drop Supply Crates
        Skills[1][8].MaxLevel = 4;
        Skills[1][8].Description[3] = "Drops a Large Backpack full of ammo at your location\nDrops a Supply Crate at your location";
        
        // DoomRL Marines use slightly different weapons
        Skills[4][0].Description[2] = "Summons a Marine\n\cjDouble Shotgun";
        Skills[4][0].Description[3] = "Summons a Marine\n\cjBattle Rifle";
        
        // Summoning Skills - Names
        Skills[4][1].Name = "Summon Former Human";
        Skills[4][2].Name = "Summon Former Sergeant";
        Skills[4][3].Name = "Summon Former Commando";
        
        // Summoning Skills - Levels
        Skills[4][1].MaxLevel = 3;
        Skills[4][2].MaxLevel = 2;
        Skills[4][3].MaxLevel = 3;
        Skills[4][4].MaxLevel = 3;
        Skills[4][5].MaxLevel = 6;
        Skills[4][6].MaxLevel = 2;
        Skills[4][7].MaxLevel = 3;
        Skills[4][8].MaxLevel = 3;
        Skills[4][9].MaxLevel = 3;
        Skills[4][10].MaxLevel = 2;
        Skills[4][11].MaxLevel = 3;
        Skills[4][12].MaxLevel = 3;
        Skills[4][13].MaxLevel = 3;
        Skills[4][14].MaxLevel = 2;
        Skills[4][15].MaxLevel = 2;
        Skills[4][16].MaxLevel = 2;
        
        // Summoning Skills - Descriptions
        Skills[4][1].Description[0] = "Summons a Former Human";
        Skills[4][1].Description[1] = "Summons an Elite Human";
        Skills[4][1].Description[2] = "Summons a Former Human Captain";
        Skills[4][2].Description[0] = "Summons a Former Sergeant";
        Skills[4][2].Description[1] = "Summons an Elite Sergeant";
        Skills[4][3].Description[0] = "Summons a Former Commando";
        Skills[4][3].Description[1] = "Summons an Elite Commando";
        Skills[4][3].Description[2] = "Summons an Elite Human Captain";
        Skills[4][4].Description[1] = "Summons a Nightmare Imp";
        Skills[4][4].Description[2] = "Summons a Cyber-Imp";
        Skills[4][5].Description[1] = "Summons a Spectre";
        Skills[4][5].Description[2] = "Summons a Nightmare Demon";
        Skills[4][5].Description[3] = "Summons a Nightmare Spectre";
        Skills[4][5].Description[4] = "Summons a Mech-Demon";
        Skills[4][5].Description[5] = "Summons a Mechtre";
        Skills[4][6].Description[1] = "Summons a Nightmare Cacodemon";
        Skills[4][7].Description[1] = "Summons a Nightmare Knight";
        Skills[4][7].Description[2] = "Summons a Cybruiser";
        Skills[4][8].Description[1] = "Summons a Baron of Nightmares";
        Skills[4][8].Description[2] = "Summons a Techno-Lord";
        Skills[4][9].Description[1] = "Summons a Nightmare Soul";
        Skills[4][9].Description[2] = "Summons a Hellmine";
        Skills[4][10].Description[1] = "Summons a Nightmare Elemental";
        Skills[4][11].Description[1] = "Summons a Nightmare Revenant";
        Skills[4][11].Description[2] = "Summons a Heavy Revenant";
        Skills[4][12].Description[1] = "Summons a Nightmare Mancubus";
        Skills[4][12].Description[2] = "Summons a Volacubus";
        Skills[4][13].Description[1] = "Summons a Nightmare Arachnotron";
        Skills[4][13].Description[2] = "Summons a Arachnsentinel";
        Skills[4][14].Description[1] = "Summons a Nightmare Arch-Vile";
        Skills[4][15].Description[1] = "Summons a Nightmare Cyberdemon";
        Skills[4][16].Description[1] = "Summons a Spider Overmind";
    };
    
    // Icons
    for (int i = 0; i < MAX_CATEGORIES; i++)
        for (int j = 0; j < MAX_SKILLS; j++)
            Skills[i][j].Icon = StrParam("SKIL%d_%d\n", i + 1, j + 1);
};

function int ScaleEPCost(int Cost)
{
    int ScaleCost = Cost;
    
    // Multiplier CVAR
    ScaleCost *= (GetCVarFixed("drpg_skill_costscale") * 100);
    ScaleCost /= 100;
    
    // Aura Multiplier
    if (Player.Aura.CostMult > 0)
        ScaleCost += (Player.Aura.CostMult * ScaleCost) / 100;
    
    return ScaleCost;
};

function void CheckSkills()
{
    // Reset the Skill multiplier from the Blue Aura and Energy Augmentation
    Player.SkillCostMult = 1.0;
    
    // Level 4 and 5 of the Energy Augmentation reduce skill costs by 25% and 50%
    if (Player.Augs.Active[AUG_ENERGY])
        if (Player.Augs.Level[AUG_ENERGY] == 4)
            Player.SkillCostMult = 0.75
        else if (Player.Augs.Level[AUG_ENERGY] >= 5)
            Player.SkillCostMult = 0.5;
    
    // Summoned Monsters Handling
    for (int i = 0; i < MAX_SUMMONS; i++)
        if (Player.SummonTID[i] != 0 && GetActorProperty(Player.SummonTID[i], APROP_Health) <= 0)
        {
            Player.SummonTID[i] = 0;
            Player.Summons--;
        };
    
    // Bullet-Time timer handling
    if (BulletTimeTimer > 0)
    {
        if (BulletTimeTimer % 3)
            GiveInventory("DRPGTimeFreezerQuick", 1);
        
        BulletTimeTimer--;
    };
};

function void CheckAuras()
{
    fixed LuckMult = 1;
    fixed X = GetActorX(0);
    fixed Y = GetActorY(0);
    fixed Z = GetActorZ(0);
    int Angle = GetActorAngle(0) * 256;
    int AmmoRegenMult = 1;
    bool Shadow = PlayerHasShadowAura(PlayerNumber());
    
    // Team Aura Handling
    if (InMultiplayer && Player.Aura.Time > 0)
        for (int i = 0; i < MAX_PLAYERS; i++)
        {
            // Skip yourself
            if (Player.TID == Players(i).TID) continue;
            
            if (Distance(Player.TID, Players(i).TID) <= Player.Aura.Range)
            {
                Players(i).Aura.Team = true;
                
                for (int j = 0; j < AURA_MAX; j++)
                    if (Player.Aura.Type[j].Active)
                        Players(i).Aura.Type[j] = Player.Aura.Type[j];
            }
            else
                Players(i).Aura.Team = false;
        };
    
    // TEEM-AU5 Shield Accessory Handling
    if (Player.Shield.Accessory && Player.Shield.Accessory->PassiveEffect == SHIELD_PASS_DATAURA && Player.Shield.Active)
        for (int i = 0; i < MAX_PLAYERS; i++)
            for (int j = 0; j < AURA_MAX; j++)
                if (Player.Aura.Type[j].Active && Players(i).Aura.Type[j].Active)
                {
                    Players(i).Aura.DefenseBoost = true;
                    break;
                };
    if (Player.Aura.DefenseBoost)
    {
        Player.DamageFactor += 0.2;
        Player.Aura.DefenseBoost = false;
    };
    
    // Aura handling
    if (Player.Aura.Time > 0 || Player.Aura.Team)
    {
        // Red Aura
        if (Player.Aura.Type[AURA_RED].Active)
            if (Player.SoulActive[SOUL_RED])
                GiveInventory("DRPGRedAuraDamage6", 1)
            else if (Player.Aura.Type[AURA_RED].Level >= 1)
                GiveInventory(StrParam("DRPGRedAuraDamage%d\n", Player.Aura.Type[AURA_RED].Level), 1);
        
        // Green Aura
        if (Player.Aura.Type[AURA_GREEN].Active)
        {
            if (Player.Aura.Type[AURA_GREEN].Level >= 1)
                Player.DamageFactor -= (fixed)Player.Aura.Type[AURA_GREEN].Level / 20.0;
            if (Player.Aura.Type[AURA_GREEN].Level >= 3 || Player.SoulActive[SOUL_GREEN])
                GiveInventory("DRPGGreenAuraIronFeet", 1);
        };
        
        // White Aura
        if (Player.Aura.Type[AURA_WHITE].Active && !CheckInventory("DRPGMenuFreezer"))
        {
            if (Player.Aura.Type[AURA_WHITE].Level >= 2 || Player.SoulActive[SOUL_WHITE])
            {
                if (Player.Combo == 0) Player.Combo++;
                Player.ComboTimer = COMBO_MAX - 1;
            };
            if (Player.Aura.Type[AURA_WHITE].Level == 3)
                if ((Timer() % (35 * 4)) == 1)
                    Player.XPGained += XPTable[Player.Level] / 100 / (Player.Level + 1);
            if (Player.Aura.Type[AURA_WHITE].Level >= 4 || Player.SoulActive[SOUL_WHITE])
                if ((Timer() % (35 * 2)) == 1)
                    Player.XPGained += XPTable[Player.Level] / 100 / (Player.Level + 1);
        };
        
        // Pink Aura
        if (Player.Aura.Type[AURA_PINK].Active)
            if (Player.Aura.Type[AURA_PINK].Level >= 2 || Player.SoulActive[SOUL_PINK])
                GiveInventory("DRPGPinkAuraDrain", 1);
        
        // Blue Aura
        if (Player.Aura.Type[AURA_BLUE].Active)
        {
            if (Player.Aura.Type[AURA_BLUE].Level == 1)
                Player.SkillCostMult /= 1.33;
            if (Player.Aura.Type[AURA_BLUE].Level == 2)
                Player.SkillCostMult /= 2;
            if (Player.Aura.Type[AURA_BLUE].Level >= 3 || Player.SoulActive[SOUL_BLUE])
                Player.SkillCostMult /= 4;
        };
        
        // Purple Aura
        if (Player.Aura.Type[AURA_PURPLE].Active)
        {
            if (Player.Aura.Type[AURA_PURPLE].Level == 1)
            {
                Player.HPAmount *= 2;
                Player.EPAmount *= 2;
            };
            if (Player.Aura.Type[AURA_PURPLE].Level == 2)
            {
                Player.HPAmount *= 3;
                Player.EPAmount *= 3;
            };
            if (Player.Aura.Type[AURA_PURPLE].Level == 3)
            {
                Player.HPAmount *= 4;
                Player.EPAmount *= 4;
            };
            if (Player.Aura.Type[AURA_PURPLE].Level >= 4 || Player.SoulActive[SOUL_PURPLE])
            {
                Player.HPAmount *= 4;
                Player.EPAmount *= 4;
                Player.HPTime /= 2;
                Player.EPTime /= 2;
            };
        };
        
        // Orange Aura
        if (Player.Aura.Type[AURA_ORANGE].Level)
        {
            if (Player.Aura.Type[AURA_ORANGE].Level >= 1 || Player.SoulActive[SOUL_ORANGE])
                Player.Speed *= 2;
            if (Player.Aura.Type[AURA_ORANGE].Level >= 2 || Player.SoulActive[SOUL_ORANGE])
                Player.JumpHeight *= 2;
            if (Player.Aura.Type[AURA_ORANGE].Level >= 3 || Player.SoulActive[SOUL_ORANGE])
                Player.WeaponSpeed = 100;
        };

        // Dark Blue Aura
        if (Player.Aura.Type[AURA_DARKBLUE].Active && !CheckInventory("DRPGMenuFreezer"))
        {
            if (Player.Aura.Type[AURA_DARKBLUE].Level == 5)
                AmmoRegenMult = 2;
            if (Player.Aura.Type[AURA_DARKBLUE].Level >= 6 || Player.SoulActive[SOUL_DARKBLUE])
                AmmoRegenMult = 4;
            if (Player.Aura.Type[AURA_DARKBLUE].Level >= 1 || Player.SoulActive[SOUL_DARKBLUE])
                if ((Timer() % (35 / 2)) == 0)
                    GiveInventory("Clip", AmmoRegenMult);
            if (Player.Aura.Type[AURA_DARKBLUE].Level >= 2 || Player.SoulActive[SOUL_DARKBLUE])
                if ((Timer() % 35) == 1)
                    GiveInventory("Shell", AmmoRegenMult);
            if (Player.Aura.Type[AURA_DARKBLUE].Level >= 3 || Player.SoulActive[SOUL_DARKBLUE])
                if ((Timer() % (35 * 2)) == 0)
                    GiveInventory("RocketAmmo", AmmoRegenMult);
            if (Player.Aura.Type[AURA_DARKBLUE].Level >= 4 || Player.SoulActive[SOUL_DARKBLUE])
                if ((Timer() % (35 / 2)) == 0)
                    GiveInventory("Cell", AmmoRegenMult);
            if (Player.Aura.Type[AURA_DARKBLUE].Level >= 7 || Player.SoulActive[SOUL_DARKBLUE])
                GiveInventory("DRPGDarkBlueAuraInfiniteAmmo", 1);
        };
        
        // Yellow Aura
        if (Player.Aura.Type[AURA_YELLOW].Active && !CheckInventory("DRPGMenuFreezer"))
        {
            if ((Timer() % (35 * (6 - Player.Aura.Type[AURA_YELLOW].Level))) == 1)
                GiveInventory("DRPGCredits", (Player.RankLevel + 1));
            if (Player.Aura.Type[AURA_YELLOW].Level == 1)
                LuckMult = 1.25;
            if (Player.Aura.Type[AURA_YELLOW].Level == 2)
                LuckMult = 1.5;
            if (Player.Aura.Type[AURA_YELLOW].Level == 3)
                LuckMult = 2;
            if (Player.Aura.Type[AURA_YELLOW].Level == 4)
                LuckMult = 4;
            if (Player.Aura.Type[AURA_YELLOW].Level >= 5 || Player.SoulActive[SOUL_YELLOW])
                LuckMult = 8;
            
            Player.HealthChance *= LuckMult;
            Player.EPChance *= LuckMult;
            Player.ArmorChance *= LuckMult;
            Player.PowerupChance *= LuckMult;
            Player.WeaponChance *= LuckMult;
            Player.TokenChance *= LuckMult;
            Player.AugChance *= LuckMult;
            Player.ShieldChance *= LuckMult;
            Player.StimChance *= LuckMult;
        };
        
        // Spawn Aura
        if (PlayerHasAura(PlayerNumber()))
            SpawnAuras(Player.TID, false);
    };
    
    // Decrease Aura Timer
    for (int i = 0; i < AURA_MAX; i++)
        if (Player.Aura.Time > 0 && Player.Aura.Type[i].Active)
            if (!CheckInventory("PowerTimeFreezer") && !CheckInventory("DRPGMenuFreezer"))
            {
                Player.Aura.Time--;
                break; // Remove this for Yholl-style behavior, still contemplating
            };
    
    // Decrease Aura Cost Multiplier
    if (Player.Aura.CostMult > 0)
        if ((Timer() % (35 * (30 + (GameSkill() * 5)))) == 0)
            Player.Aura.CostMult -= 10;
    
    // Reset Aura and Soul States
    if (Player.Aura.Time <= 0)
    {
        Player.Aura.Team = false;
        
        // Reset Auras
        for (int i = 0; i < AURA_MAX; i++)
            if (Player.Aura.Time <= 0)
            {
                Player.Aura.Type[i].Active = false;
                Player.Aura.Type[i].Level = 0;
            };
        
        // Reset Souls
        for (int i = 0; i < SOUL_MAX; i++)
            Player.SoulActive[i] = false;
    };
};